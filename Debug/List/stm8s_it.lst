###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM809/Apr/2016  20:06:11 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \stm8s_it.c                                              #
#    Command line =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \stm8s_it.c -e --enable_multibytes -Ohz --debug          #
#                    --code_model small --data_model medium -o                #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\ --dlib_config "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /user/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79 #
#                    _A0/user/src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/user/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_ #
#                    C-version\CH79_A0/addon/\ -I                             #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/addon/s #
#                    rc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /addon/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version #
#                    \CH79_A0/sys/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/sys/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C #
#                    -version\CH79_A0/sys/src/\ -I                            #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/\   #
#                    -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/ #
#                    src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A #
#                    0/lib/inc/\ --vregs 16                                   #
#    List file    =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\stm8s_it.lst                                         #
#    Object file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\stm8s_it.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src\stm8s_it.c
      1          /**
      2            ******************************************************************************
      3            * @file stm8s_it.c
      4            * @author STMicroelectronics - MCD Application Team
      5            * @version V2.0.0
      6            * @date 15-March-2011
      7            * @brief Main Interrupt Service Routines.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     19            ******************************************************************************
     20            */ 
     21          
     22          /* Includes ------------------------------------------------------------------
     23          */
     24          #include "stm8s_it.h"
     25          #include "stm8s_tim4.h"
     26          #include "sysctrl.h"
     27          //#include "uart.h"
     28          #include "iostm8s003f3.h" 
     29          #include "user.h"
     30          #include "macro_def.h"
     31          
     32          #define   DIS_GIE    asm("sim")
     33          #define   EN_GIE     asm("rim")
     34           
     35            
     36          /** @addtogroup TIM2_OC_ActiveMode
     37            * @{
     38            */
     39          #ifdef _COSMIC_
     40          /**
     41            * @brief  Dummy interrupt routine
     42            * @param  None
     43            * @retval None
     44            */
     45          INTERRUPT_HANDLER(NonHandledInterrupt, 25)
     46          {
     47            /* In order to detect unexpected events during development,
     48               it is recommended to set a breakpoint on the following instruction.
     49            */
     50            nop();
     51          }
     52          #endif /*_COSMIC_*/
     53          
     54          /**
     55            * @brief  TRAP interrupt routine
     56            * @param  None
     57            * @retval None
     58            */
     59          INTERRUPT_HANDLER_TRAP(TRAP_IRQHandler)
     60          {
     61            /* In order to detect unexpected events during development,
     62               it is recommended to set a breakpoint on the following instruction.
     63            */
     64            nop();
     65          }
     66          /**
     67            * @brief  Top Level Interrupt routine
     68            * @param  None
     69            * @retval None
     70            */
     71          INTERRUPT_HANDLER(TLI_IRQHandler, 0)
     72          {
     73            /* In order to detect unexpected events during development,
     74               it is recommended to set a breakpoint on the following instruction.
     75            */
     76            nop();
     77          }
     78          
     79          /**
     80            * @brief  Auto Wake Up Interrupt routine
     81            * @param  None
     82            * @retval None
     83            */
     84          INTERRUPT_HANDLER(AWU_IRQHandler, 1)
     85          {
     86            /* In order to detect unexpected events during development,
     87               it is recommended to set a breakpoint on the following instruction.
     88            */
     89             nop();
     90             AWU->CSR |= 0x00;
     91          }
     92          
     93          /**
     94            * @brief  Clock Controller Interrupt routine
     95            * @param  None
     96            * @retval None
     97            */
     98          INTERRUPT_HANDLER(CLK_IRQHandler, 2)
     99          {
    100            /* In order to detect unexpected events during development,
    101               it is recommended to set a breakpoint on the following instruction.
    102            */
    103            nop();
    104          }
    105          
    106          /**
    107            * @brief  External Interrupt PORTA Interrupt routine
    108            * @param  None
    109            * @retval None
    110            */
    111          INTERRUPT_HANDLER(EXTI_PORTA_IRQHandler, 3)
    112          {
    113            /* In order to detect unexpected events during development,
    114               it is recommended to set a breakpoint on the following instruction.
    115            */ 
    116              nop();
    117             
    118          }
    119          
    120          /**
    121            * @brief  External Interrupt PORTB Interrupt routine
    122            * @param  None
    123            * @retval None
    124            */
    125          INTERRUPT_HANDLER(EXTI_PORTB_IRQHandler, 4)
    126          {
    127            /* In order to detect unexpected events during development,
    128               it is recommended to set a breakpoint on the following instruction.
    129            */
    130            nop(); 
    131            //GPIO_Init(GPIOB, GPIO_PIN_5, GPIO_MODE_IN_PU_NO_IT);        //KEY1
    132          }
    133          ////////////////////////////////////////////////////////////////////////////////////////////////////////////
    134          /**
    135            * @brief  External Interrupt PORTC Interrupt routine
    136            * @param  None
    137            * @retval None
    138            */
    139          INTERRUPT_HANDLER(EXTI_PORTC_IRQHandler, 5)
    140          {
    141            /* In order to detect unexpected events during development,
    142               it is recommended to set a breakpoint on the following instruction.
    143            */
    144            nop();
    145            
    146          }
    147          
    148          /**
    149            * @brief  External Interrupt PORTD Interrupt routine
    150            * @param  None
    151            * @retval None
    152            */
    153          INTERRUPT_HANDLER(EXTI_PORTD_IRQHandler, 6)
    154          {
    155            /* In order to detect unexpected events during development,
    156               it is recommended to set a breakpoint on the following instruction.
    157            */
    158            nop();  
    159            /**/ 
    160            //LED1_ON();
    161            AWU->CSR |= 0x00;
    162            //LowPower_MCU_Entry_Flag = 0;
    163            //LowPower_Entry_Delay_t = 0;
    164          }
    165          
    166          /**
    167            * @brief  External Interrupt PORTE Interrupt routine
    168            * @param  None
    169            * @retval None
    170            */
    171          INTERRUPT_HANDLER(EXTI_PORTE_IRQHandler, 7)
    172          {
    173            /* In order to detect unexpected events during development,
    174               it is recommended to set a breakpoint on the following instruction.
    175            */
    176            nop();
    177          }
    178          #ifdef STM8S903
    179          /**
    180            * @brief  External Interrupt PORTF Interrupt routine
    181            * @param  None
    182            * @retval None
    183            */
    184           INTERRUPT_HANDLER(EXTI_PORTF_IRQHandler, 8)
    185          {
    186            /* In order to detect unexpected events during development,
    187               it is recommended to set a breakpoint on the following instruction.
    188            */
    189            nop();
    190          }
    191          #endif /*STM8S903*/
    192          
    193          #if defined (STM8S208) || defined (STM8AF52Ax)
    194          /**
    195            * @brief CAN RX Interrupt routine.
    196            * @param  None
    197            * @retval None
    198            */
    199           INTERRUPT_HANDLER(CAN_RX_IRQHandler, 8)
    200          {
    201            /* In order to detect unexpected events during development,
    202               it is recommended to set a breakpoint on the following instruction.
    203            */
    204          }
    205          
    206          /**
    207            * @brief  CAN TX Interrupt routine
    208            * @param  None
    209            * @retval None
    210            */
    211           INTERRUPT_HANDLER(CAN_TX_IRQHandler, 9)
    212          {
    213            /* In order to detect unexpected events during development,
    214               it is recommended to set a breakpoint on the following instruction.
    215            */
    216          }
    217          #endif /*STM8S208 || STM8AF52Ax */
    218          
    219          /**
    220            * @brief  SPI Interrupt routine
    221            * @param  None
    222            * @retval None
    223            */
    224          INTERRUPT_HANDLER(SPI_IRQHandler, 10)
    225          {
    226            /* In order to detect unexpected events during development,
    227               it is recommended to set a breakpoint on the following instruction.
    228            */
    229            nop();
    230          }
    231          
    232          /**
    233            * @brief  Timer1 Update/Overflow/Trigger/Break Interrupt routine
    234            * @param  None
    235            * @retval None
    236            */
    237          INTERRUPT_HANDLER(TIM1_UPD_OVF_TRG_BRK_IRQHandler, 11)
    238          {
    239            /* In order to detect unexpected events during development,
    240               it is recommended to set a breakpoint on the following instruction.
    241            */
    242            
    243          //FOR DEBUG  
    244          //1MS INTERRUPT FOR USER CODE 
    245            //TIM1_ClearFlag(TIM1_FLAG_UPDATE);  
    246            //TimerCnt();  
    247          //FOR DEBUG  
    248            nop();
    249          
    250            
    251          }
    252          
    253          /**
    254            * @brief  Timer1 Capture/Compare Interrupt routine
    255            * @param  None
    256            * @retval None
    257            */
    258          INTERRUPT_HANDLER(TIM1_CAP_COM_IRQHandler, 12)
    259          {
    260            /* In order to detect unexpected events during development,
    261               it is recommended to set a breakpoint on the following instruction.
    262            */
    263            nop();
    264          }
    265          
    266          #ifdef STM8S903
    267          /**
    268            * @brief  Timer5 Update/Overflow/Break/Trigger Interrupt routine
    269            * @param  None
    270            * @retval None
    271            */
    272           INTERRUPT_HANDLER(TIM5_UPD_OVF_BRK_TRG_IRQHandler, 13)
    273          {
    274            /* In order to detect unexpected events during development,
    275               it is recommended to set a breakpoint on the following instruction.
    276            */
    277            nop();
    278          }
    279          /**
    280            * @brief  Timer5 Capture/Compare Interrupt routine
    281            * @param  None
    282            * @retval None
    283            */
    284          
    285           INTERRUPT_HANDLER(TIM5_CAP_COM_IRQHandler, 14)
    286          {
    287            /* In order to detect unexpected events during development,
    288               it is recommended to set a breakpoint on the following instruction.
    289            */
    290            nop();
    291          }
    292          
    293          #else /*STM8S208, STM8S207, STM8S105 or STM8S103 or STM8AF62Ax or STM8AF52Ax or STM8AF626x */
    294          /**
    295            * @brief  Timer2 Update/Overflow/Break Interrupt routine
    296            * @param  None
    297            * @retval None
    298            */
    299           INTERRUPT_HANDLER(TIM2_UPD_OVF_BRK_IRQHandler, 13)
    300          {
    301            /* In order to detect unexpected events during development,
    302               it is recommended to set a breakpoint on the following instruction.
    303            */ 
    304            static uint8_t cntr100ms = 0; 
    305            static uint16_t Init_Soc_Flag_Delay = 0; 
    306            nop();
    307            TIM2_SR1 &= ~0x01;
    308            if(ChgExchangeMode_Cnt < 255)
    309            {
    310              ChgExchangeMode_Cnt += 1;
    311            }
    312            if(DisExchangeMode_Cnt < 255)
    313            {
    314              DisExchangeMode_Cnt += 1;
    315            }
    316            if(IdleExchangeMode_Cnt < 255)
    317            {
    318              IdleExchangeMode_Cnt += 1;
    319            }
    320            //===================================SOC
    321            if(Init_Soc_Flag == 0)
    322            {
    323              if((Init_Soc_Flag_Delay++) >= 200)
    324              {
    325                Init_Soc_Flag = 1;
    326                Init_Soc_Flag_Delay = 0;
    327              }
    328            }
    329            //if(Init_Soc_Flag ==1)
    330            {
    331              SOCAhIntergrate(); 
    332              if((cntr100ms++) >= 10)
    333              {
    334                cntr100ms = 0; 
    335                if(Init_Soc_Flag == 1)
    336                {
    337                  SOCCalculate(); // 100ms tick
    338                }
    339              }
    340            } 
    341            //======================================== 
    342            if(WorkMode != IDLE_MODE)
    343            {
    344              if(LedFlash_t < MAX_UINT16_T_NUM)
    345              {
    346                LedFlash_t += 1;
    347              } 
    348            }
    349            else
    350            {
    351              LedFlash_t = 0;
    352            }
    353            //=======================================
    354            if(Temp_Volt_Sample_Cnt < MAX_UINT16_T_NUM)
    355            {  
    356              Temp_Volt_Sample_Cnt += 1;
    357            }
    358            if(Cell_Volt_Sample_Cnt < MAX_UINT16_T_NUM)
    359            {  
    360              Cell_Volt_Sample_Cnt += 1;
    361            }
    362            if(CC_Volt_Sample_Cnt < MAX_UINT16_T_NUM)
    363            {  
    364              CC_Volt_Sample_Cnt += 1;
    365            } 
    366                if(Bits_flag.Bit.DisTemp || Bits_flag.Bit.ChgTemp )
    367                {
    368                  if(Temp_Protect_Delay_t < MAX_UINT16_T_NUM)
    369                  {
    370                    Temp_Protect_Delay_t += 1;
    371                  }
    372                }
    373            //=======================================
    374            if(WorkMode == CHARGE_MODE)
    375            {
    376               /*if(ChgTemp_cnt < 1000)
    377               {
    378                 ChgTemp_cnt += 1; 
    379               }*/
    380              if(Chg_Current_Val_Small_Errer_t < MAX_UINT16_T_NUM)
    381              {
    382                Chg_Current_Val_Small_Errer_t += 1;
    383              }
    384              if(Cell_Balance_Delay_t < MAX_UINT16_T_NUM)
    385              {
    386                Cell_Balance_Delay_t += 1;
    387              }
    388              if(ChgOv_t < MAX_UINT16_T_NUM)
    389              {
    390                ChgOv_t += 1;
    391              }
    392              if(ChgCurOv_t < MAX_UINT16_T_NUM)
    393              {
    394                ChgCurOv_t += 1;
    395              }
    396              if(Bits_flag.Bit.ChgCurOv )
    397              {
    398                if(ChgCurOv_Re_t < MAX_UINT16_T_NUM)
    399                {
    400                  ChgCurOv_Re_t += 1;
    401                }
    402              }
    403              else
    404              {
    405                ChgCurOv_Re_t = 0;
    406              }
    407            }
    408            else
    409            {
    410              //=======================================
    411              if(DisOv_t < MAX_UINT16_T_NUM)
    412              {
    413                DisOv_t += 1;
    414              }
    415              //=======================================
    416              /*
    417              if(Bits_flag.Bit.DisOv)
    418              {
    419                if( PowerOff_Delay_t < MAX_UINT16_T_NUM)
    420                {
    421                  PowerOff_Delay_t += 1;
    422                }
    423              }
    424              else
    425              {
    426                PowerOff_Delay_t = 0;
    427              } 
    428              */ 
    429              //=======================================
    430              if(WorkMode == DISCHARGE_MODE)
    431              { 
    432               if(DisTemp_cnt < 1000)
    433               {
    434                 DisTemp_cnt += 1; 
    435               }
    436                if(DisTemp_Lock_Cnt < 500)
    437                {
    438                  DisTemp_Lock_Cnt += 1;
    439                }
    440                //==============================
    441                if(Dis_First_Run_Flag == 0)
    442                {
    443                  if(Dis_First_Run_t < 200)
    444                  {
    445                    Dis_First_Run_t += 1;
    446                  }
    447                }
    448                else
    449                {
    450                  Dis_First_Run_t = 0;
    451                }
    452                //=======================================
    453                if(Bits_flag.Bit.DisCurShort)
    454                {
    455                  if( DisCurShort_Re_t < MAX_UINT16_T_NUM)
    456                  {
    457                    DisCurShort_Re_t += 1;
    458                  }
    459                }
    460                else
    461                {
    462                  DisCurShort_Re_t = 0;
    463                }
    464                //=======================================
    465                if(DisCurOv_t < MAX_UINT16_T_NUM)
    466                {
    467                  DisCurOv_t += 1;
    468                }
    469                //=======================================
    470                if(DisCurOv_t1 < MAX_UINT16_T_NUM)
    471                {
    472                  DisCurOv_t1 += 1;
    473                }
    474                //=======================================
    475                if(DisCurOv_t2 < MAX_UINT16_T_NUM)
    476                {
    477                  DisCurOv_t2 += 1;
    478                }
    479                //=======================================
    480                
    481                if(Bits_flag.Bit.DisCurOv)
    482                {
    483                  if( DisCurOv_Re_t < MAX_UINT16_T_NUM)
    484                  {
    485                    DisCurOv_Re_t += 1;
    486                  }
    487                }
    488                else
    489                {
    490                  DisCurOv_Re_t = 0;
    491                }
    492              } 
    493            }
    494            //=======================================
    495            if(Bits_flag.Bit.AfeErr)
    496            {
    497              /*if(DEVICE_XREADY_Re_t < MAX_UINT16_T_NUM)
    498              {
    499                DEVICE_XREADY_Re_t += 1;
    500              }*/
    501              if(AfeErr_t < MAX_UINT16_T_NUM)
    502              {
    503                AfeErr_t += 1;
    504              }
    505            }
    506            /*
    507            else
    508            {
    509              DEVICE_XREADY_Re_t = 0; 
    510            }*/
    511            //=======================================
    512            if(WorkMode ==IDLE_MODE)
    513            {
    514              if(LowPower_Entry_Delay_t < MAX_UINT16_T_NUM)
    515              {
    516                LowPower_Entry_Delay_t += 1;
    517              }
    518              if(PowerOff_Delay_t < MAX_UINT16_T_NUM)
    519              {
    520                PowerOff_Delay_t += 1;
    521              }
    522              if(LedFlash_Off_t < MAX_UINT16_T_NUM)
    523              {
    524                LedFlash_Off_t += 1;
    525              }
    526              
    527            } 
    528          }
    529          
    530          /**
    531            * @brief  Timer2 Capture/Compare Interrupt routine
    532            * @param  None
    533            * @retval None
    534            */
    535           INTERRUPT_HANDLER(TIM2_CAP_COM_IRQHandler, 14)
    536          {
    537            /* In order to detect unexpected events during development,
    538               it is recommended to set a breakpoint on the following instruction.
    539            */
    540            nop();
    541          }
    542          #endif /*STM8S903*/
    543          
    544          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S105) || defined (STM8AF62Ax) ||\
    545              defined (STM8AF52Ax) || defined (STM8AF626x)
    546          /**
    547            * @brief Timer3 Update/Overflow/Break Interrupt routine.
    548            * @param  None
    549            * @retval None
    550            */
    551           INTERRUPT_HANDLER(TIM3_UPD_OVF_BRK_IRQHandler, 15)
    552          {
    553            /* In order to detect unexpected events during development,
    554               it is recommended to set a breakpoint on the following instruction.
    555            */
    556            nop();
    557          }
    558          
    559          /**
    560            * @brief  Timer3 Capture/Compare Interrupt routine
    561            * @param  None
    562            * @retval None
    563            */
    564           INTERRUPT_HANDLER(TIM3_CAP_COM_IRQHandler, 16)
    565          {
    566            /* In order to detect unexpected events during development,
    567               it is recommended to set a breakpoint on the following instruction.
    568            */
    569            nop();
    570          }
    571          #endif /*STM8S208, STM8S207 or STM8S105 or STM8AF62Ax or STM8AF52Ax or STM8AF626x */
    572          
    573          #if defined (STM8S208) || defined(STM8S207) || defined(STM8S103) || defined (STM8AF62Ax) ||\
    574              defined (STM8AF52Ax) || defined (STM8S903)
    575          /**
    576            * @brief  UART1 TX Interrupt routine
    577            * @param  None
    578            * @retval None
    579            */
    580           INTERRUPT_HANDLER(UART1_TX_IRQHandler, 17)
    581          {
    582            /* In order to detect unexpected events during development,
    583               it is recommended to set a breakpoint on the following instruction.
    584            */
    585            nop();
    586            //UART1_ClearFlag(UART1_FLAG_RXNE); 
    587            //if(*str!=0)
    588            //UART1_SendData8(*srt);
    589            //srt++;
    590          
    591            
    592          }
    593          
    594          /**
    595            * @brief  UART1 RX Interrupt routine
    596            * @param  None
    597            * @retval None
    598            */
    599           INTERRUPT_HANDLER(UART1_RX_IRQHandler, 18)
    600          {
    601            /* In order to detect unexpected events during development,
    602               it is recommended to set a breakpoint on the following instruction.
    603            */
    604            
    605            //UART1_ClearFlag(UART1_FLAG_RXNE); 
    606            //Uart1DataReceived();
    607            //UART1_SR &=0xD7;
    608            //UART_Revc = UART1_DR; 
    609          }
    610          #endif /*STM8S105*/
    611          
    612          /**
    613            * @brief  I2C Interrupt routine
    614            * @param  None
    615            * @retval None
    616            */
    617          INTERRUPT_HANDLER(I2C_IRQHandler, 19)
    618          {
    619            /* In order to detect unexpected events during development,
    620               it is recommended to set a breakpoint on the following instruction.
    621            */
    622            nop();
    623            I2C->SR1 = 0; 
    624          }
    625          
    626          #if defined (STM8S105) || defined (STM8AF626x)
    627          /**
    628            * @brief  UART2 TX interrupt routine.
    629            * @param  None
    630            * @retval None
    631            */
    632           INTERRUPT_HANDLER(UART2_TX_IRQHandler, 20)
    633          {
    634              /* In order to detect unexpected events during development,
    635                 it is recommended to set a breakpoint on the following instruction.
    636              */
    637            nop();
    638            }
    639          
    640          /**
    641            * @brief  UART2 RX interrupt routine.
    642            * @param  None
    643            * @retval None
    644            */
    645           INTERRUPT_HANDLER(UART2_RX_IRQHandler, 21)
    646          {
    647              /* In order to detect unexpected events during development,
    648                 it is recommended to set a breakpoint on the following instruction.
    649              */
    650            nop();
    651            }
    652          #endif /* STM8S105*/
    653          
    654          #if defined(STM8S207) || defined(STM8S208) || defined (STM8AF52Ax) || defined (STM8AF62Ax)
    655          /**
    656            * @brief  UART3 TX interrupt routine.
    657            * @param  None
    658            * @retval None
    659            */
    660           INTERRUPT_HANDLER(UART3_TX_IRQHandler, 20)
    661          {
    662              /* In order to detect unexpected events during development,
    663                 it is recommended to set a breakpoint on the following instruction.
    664              */
    665            nop();
    666            }
    667          
    668          /**
    669            * @brief  UART3 RX interrupt routine.
    670            * @param  None
    671            * @retval None
    672            */
    673           INTERRUPT_HANDLER(UART3_RX_IRQHandler, 21)
    674          {
    675              /* In order to detect unexpected events during development,
    676                 it is recommended to set a breakpoint on the following instruction.
    677              */
    678            nop();
    679            }
    680          #endif /*STM8S208 or STM8S207 or STM8AF52Ax or STM8AF62Ax */
    681          
    682          #if defined(STM8S207) || defined(STM8S208) || defined (STM8AF52Ax) || defined (STM8AF62Ax)
    683          /**
    684            * @brief  ADC2 interrupt routine.
    685            * @param  None
    686            * @retval None
    687            */
    688           INTERRUPT_HANDLER(ADC2_IRQHandler, 22)
    689          {
    690          
    691              /* In order to detect unexpected events during development,
    692                 it is recommended to set a breakpoint on the following instruction.
    693              */
    694            nop();
    695              return;
    696          
    697          }
    698          #else /*STM8S105, STM8S103 or STM8S903 or STM8AF626x */
    699          /**
    700            * @brief  ADC1 interrupt routine.
    701            * @param  None
    702            * @retval None
    703            */
    704           INTERRUPT_HANDLER(ADC1_IRQHandler, 22)
    705          {
    706          
    707              /* In order to detect unexpected events during development,
    708                 it is recommended to set a breakpoint on the following instruction.
    709              */
    710            nop();
    711              return;
    712          
    713          }
    714          #endif /*STM8S208 or STM8S207 or STM8AF52Ax or STM8AF62Ax */
    715          
    716          #ifdef STM8S903
    717          /**
    718            * @brief  Timer6 Update/Overflow/Trigger Interrupt routine
    719            * @param  None
    720            * @retval None
    721            */
    722          INTERRUPT_HANDLER(TIM6_UPD_OVF_TRG_IRQHandler, 23)
    723          {
    724            /* In order to detect unexpected events during development,
    725               it is recommended to set a breakpoint on the following instruction.
    726            */
    727          //200uS INTERRUPT FOR USER CODE 
    728           TIM6_ClearFlag(TIM6_FLAG_UPDATE);
    729          
    730            nop();
    731           //TIM6_SR1 = 0x00;
    732          //--------------------test only
    733          
    734           //GPIO_WriteReverse(GPIOD, GPIO_PIN_2 | GPIO_PIN_3 |GPIO_PIN_4 |GPIO_PIN_5);
    735          
    736            
    737              
    738            }  
    739          #else /*STM8S208, STM8S207, STM8S105 or STM8S103 or STM8AF62Ax or STM8AF52Ax or STM8AF626x */
    740          /**
    741            * @brief  Timer4 Update/Overflow Interrupt routine
    742            * @param  None
    743            * @retval None
    744            */
    745           INTERRUPT_HANDLER(TIM4_UPD_OVF_IRQHandler, 23)
    746          { 
    747            
    748             TIM4->SR1 &= ~0x01;
    749             //-------------------extern unsigned int DisLedW_t,DisLedW_tt; 
    750             if(Delay_time_t > 0)
    751             {
    752               Delay_time_t -= 1;
    753             }
    754             
    755             //==================================== 
    756          }
    757          #endif /*STM8S903*/
    758          
    759          /**
    760            * @brief  Eeprom EEC Interrupt routine
    761            * @param  None
    762            * @retval None
    763            */
    764          INTERRUPT_HANDLER(EEPROM_EEC_IRQHandler, 24)
    765          {
    766            /* In order to detect unexpected events during development,
    767               it is recommended to set a breakpoint on the following instruction.
    768            */
    769          }
    770          
    771          /**
    772            * @}
    773            */
    774          
    775          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_TIM2_SR1                       1
     TRAP_IRQHandler                   2
     TLI_IRQHandler                    2
     AWU_IRQHandler                    8
     CLK_IRQHandler                    2
     EXTI_PORTA_IRQHandler             2
     EXTI_PORTB_IRQHandler             2
     EXTI_PORTC_IRQHandler             2
     EXTI_PORTD_IRQHandler             8
     EXTI_PORTE_IRQHandler             2
     SPI_IRQHandler                    2
     TIM1_UPD_OVF_TRG_BRK_IRQHandler
                                       2
     TIM1_CAP_COM_IRQHandler           2
     TIM2_UPD_OVF_BRK_IRQHandler     469
     cntr100ms                         1
     Init_Soc_Flag_Delay               2
     TIM2_CAP_COM_IRQHandler           2
     UART1_TX_IRQHandler               2
     UART1_RX_IRQHandler               1
     I2C_IRQHandler                    6
     ADC1_IRQHandler                   2
     TIM4_UPD_OVF_IRQHandler          14
     EEPROM_EEC_IRQHandler             1

 
   3 bytes in section .near.bss
   1 byte  in section .near.noinit
 533 bytes in section .near_func.text
 
 533 bytes of CODE memory
   3 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none
