###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM807/Apr/2016  16:33:16 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \Afe_bq769x0_user.c                                      #
#    Command line =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \Afe_bq769x0_user.c -e --enable_multibytes -Ohz --debug  #
#                    --code_model small --data_model medium -o                #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\ --dlib_config "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /user/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79 #
#                    _A0/user/src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/user/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_ #
#                    C-version\CH79_A0/addon/\ -I                             #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/addon/s #
#                    rc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /addon/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version #
#                    \CH79_A0/sys/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/sys/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C #
#                    -version\CH79_A0/sys/src/\ -I                            #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/\   #
#                    -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/ #
#                    src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A #
#                    0/lib/inc/\ --vregs 16                                   #
#    List file    =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\Afe_bq769x0_user.lst                                 #
#    Object file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\Afe_bq769x0_user.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src\Afe_bq769x0_user.c
      1          //
      2          #include "stm8s.h" 
      3          #include "user.h"
      4          #include "macro_def.h"
      5          #include "iostm8s003f3.h"
      6          #include "bq769x0.h"
      7          
      8          #if 1
      9          void Afe_CellBalance_Enable(uint16_t selct)
     10          { 
     11            //==============cell balance on
     12            CELLBAL1_Last = (uint8_t)(selct & 0x001F);
     13            I2C_Write(CELLBAL1_ADDR,CELLBAL1_Last);
     14            CELLBAL2_Last =  (uint8_t)(selct >> 5);
     15            I2C_Write(CELLBAL2_ADDR,CELLBAL2_Last);
     16          }
     17          void Afe_CellBalance_Disable(void)
     18          { 
     19            uint8_t tmp1 = 0x01;
     20            uint8_t tmp2 = 0x01;
     21              CellBal_Cntrl_Lock = 0;
     22              CellBalance_Cur_Selct = 0;
     23              //==============cell balance off
     24              CELLBAL1_Last = 0x00;
     25              I2C_Write(CELLBAL1_ADDR,CELLBAL1_Last);
     26              CELLBAL2_Last = 0x00;
     27              I2C_Write(CELLBAL2_ADDR,CELLBAL2_Last);
     28              
     29              I2C_Read(CELLBAL2_ADDR,&tmp1);
     30              if(tmp1 == 0x00)
     31              {
     32                I2C_Read(CELLBAL2_ADDR,&tmp2);
     33                if(tmp2 == 0x00)
     34                { 
     35                  CellBalance_Selct = 0;
     36                  CellBal_Cntrl_Lock = 0;
     37                }
     38              }   
     39          }
     40          //====================================================================
     41          uint16_t Afe_Get_Adc(uint8_t addr)
     42          { 
     43            uint8_t adcval,tmpval = 0; 
     44            uint16_t adv_result ;    
     45            I2C_Read(addr,&tmpval);
     46            adcval = tmpval;
     47            I2C_Read(addr + 1,&tmpval);
     48            adv_result = ((uint16_t)adcval << 8 ) + (uint16_t)tmpval;
     49            return adv_result; 
     50          }
     51          //==========================================================================
     52          /*      SYS_STAT (0x00)/RESET:0x00
     53                  BIT        7      6           5             4       3   2    1     0
     54                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
     55            Why is the DEVICE_XREADY bit high on my part and it cannot be cleared?
     56              For the bq76930 and bq76940 it typically indicates that the voltage on the bottom cell group is adequate,
     57              but one of the upper cell groups’ supply voltage is below VSHUT. Raise all cell group supply voltages above
     58              VPORA and clear the status bit. Another possibility is that the part has been damaged.
     59          */
     60          void ChgDis_AbnormalCheck(void)
     61          {
     62            static uint8_t AfeErr_Cnt = 0;
     63           
     64            //========================================
     65            if(WorkMode == CHARGE_MODE)
     66            {
     67              FAULT_DETECT_CTRL_ON();
     68              if((CC_Val < (-50)) || Bits_flag.Bit.AfeErr || IS_FAULT_ON() || Cell_Volt_Max >= 4250)         // 充电状态检测到放电电流
     69              {
     70                if((AfeErr_Cnt ++) >= 10)
     71                {
     72                  AfeErr_Cnt = 10;
     73                  Bits_flag.Bit.AfeErr = 1;
     74                }
     75              }
     76              else
     77              {
     78                AfeErr_Cnt = 0;
     79                AfeErr_t = 0;
     80              }
     81            }
     82            else if(WorkMode == DISCHARGE_MODE)
     83            {
     84              if((CC_Val >= 50) ||Bits_flag.Bit.AfeErr || Cell_Volt_Max >= 4250)         // 放电状态检测到充电电流
     85              {
     86                if((AfeErr_Cnt ++) >= 10)
     87                {
     88                  AfeErr_Cnt = 10;
     89                  Bits_flag.Bit.AfeErr = 1;
     90                }
     91              }
     92              else
     93              {
     94                AfeErr_Cnt = 0;
     95                AfeErr_t = 0;
     96              }
     97            }
     98            else
     99            {
    100              AfeErr_Cnt = 0;
    101            }
    102                
    103            /*  
    104            //====================================================
    105            
    106            if(SYS_STAT.Bit.DEVICE_XREADY)// || SYS_STAT.Bit.OVRD_ALERT)
    107            {
    108              Bits_flag.Bit.AfeErr = 1;
    109            } 
    110            if(Bits_flag.Bit.AfeErr )//&& DEVICE_XREADY_Re_t >= DEVICE_XREADY_Re_SET)//SYS_STAT.Bit.DEVICE_XREADY
    111            {
    112              SYS_STAT_Last |= 0x30;
    113              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    114              SYS_STAT_Last &= ~0x30;
    115              
    116              SYS_STAT.Bit.DEVICE_XREADY = 0;
    117              Bits_flag.Bit.AfeErr = 0;
    118              DEVICE_XREADY_Re_t = 0;
    119              Afe_Device_Init(); 
    120            } 
    121             */
    122          }
    123          
    124          void Afe_AbnormalCheck(void)
    125          {
    126            /* 
    127            if(SYS_STAT.Bit.DEVICE_XREADY)// || SYS_STAT.Bit.OVRD_ALERT)
    128            {
    129              Bits_flag.Bit.AfeErr = 1;
    130            } 
    131             
    132            if(SYS_STAT.Bit.OVRD_ALERT)
    133            {
    134              SYS_STAT_Last |= 0x10;
    135              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    136              SYS_STAT_Last &= ~0x10;
    137              SYS_STAT.Bit.OVRD_ALERT = 0;
    138            }*/
    139            if(Bits_flag.Bit.AfeErr )//&& DEVICE_XREADY_Re_t >= DEVICE_XREADY_Re_SET)//SYS_STAT.Bit.DEVICE_XREADY
    140            {
    141              SYS_STAT_Last |= 0x30;
    142              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    143              SYS_STAT_Last &= ~0x30;
    144              
    145              SYS_STAT.Bit.DEVICE_XREADY = 0;
    146              Bits_flag.Bit.AfeErr = 0;
    147              DEVICE_XREADY_Re_t = 0;
    148              Afe_Device_Init();
    149              /*
    150              Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);
    151              Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);
    152              Afe_OV_UV_Delay_Set(OV_DELAY_SET,UV_DELAY_SET); 
    153              Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, UV_THREHOLD_VAL_SET);
    154              */
    155            } 
    156               
    157          }
    158          //==========================================================================
    159          /*
    160            Waking from SHIP mode to NORMAL mode requires pulling the TS1 pin greater than VBOOT, which triggers the device boot-up sequence.
    161            In order to exit SHIP mode into NORMAL mode, the device must follow the standard boot sequence by applying a voltage greater than the VBOOT threshold on the TS1 pin.
    162            
    163          To enter SHIP mode from NORMAL mode, the [SHUT_A] and [SHUT_B] bits in the SYS_CTRL1 register must be written with specific patterns across two consecutive writes:
    164             Write #1: [SHUT_A] = 0, [SHUT_B] = 1
    165             Write #2: [SHUT_A] = 1, [SHUT_B] = 0
    166            Table 7-7. SYS_CTRL1 (0x04)/RESET:0x00
    167            BIT       7         6   5     4         3       2     1       0
    168            NAME  LOAD_PRESENT  ―  ―  ADC_EN  TEMP_SEL  RSVD  SHUT_A  SHUT_B
    169          */
    170          
    171          void Afe_EnterShipMode(void)
    172          {
    173            SYS_CTRL1_Last &= ~0x02;
    174            SYS_CTRL1_Last |= 0x01;
    175            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    176            
    177            SYS_CTRL1_Last |= 0x02;
    178            SYS_CTRL1_Last &= ~0x01;
    179            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    180          }
    181           void Afe_ADC_Disable(void)
    182           { 
    183            //==ADC enable command
    184            SYS_CTRL1_Last &= ~0x10;
    185            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    186           }
    187          //==========================================================================
    188          /* This bit is set automatically whenever the device enters NORMAL mode. 
    189             When enabled, the ADC ensures that the integrated OV and UV protections are functional.*/
    190          void Afe_ADC_Enable(void)
    191          {
    192            //==ADC enable command
    193            SYS_CTRL1_Last |= 0x10;
    194            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    195          }
    196           
    197          void Afe_Temp_Disable(void)
    198          {
    199            //==TEMP_SEL (Bit 3): TSx_HI and TSx_LO temperature source
    200            SYS_CTRL1_Last &= ~0x08;
    201            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    202          }
    203          //========================================================================== 
    204          void Afe_Temp_Enable(void)
    205          {
    206            //==TEMP_SEL (Bit 3): TSx_HI and TSx_LO temperature source
    207            SYS_CTRL1_Last |= 0x08;
    208            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    209          }
    210          
    211          //===============================================
    212          //ADCGAIN is stored in units of μV/LSB, while ADCOFFSET is stored in mV.
    213          void Afe_Get_GainOffset(void)
    214          {
    215            uint8_t tmpval = 0;
    216            uint8_t gain_val_tmp = 0;
    217            
    218            //==get adc gian value 
    219            I2C_Read(ADCGAIN1_ADDR,&tmpval);
    220            gain_val_tmp = (tmpval & 0x0C)>>2; 
    221            I2C_Read(ADCGAIN2_ADDR,&tmpval); 
    222            gain_val_tmp = (gain_val_tmp << 3) + ((tmpval & 0xE0) >> 5); 
    223            ADCGain_Val = 365 + gain_val_tmp;
    224            
    225            //===get adc offset value
    226            I2C_Read(ADCOFFSET_ADDR,&tmpval );
    227            ADCOffset_Val = tmpval ;
    228            
    229            
    230             // Uart_SendByte(gain_val_tmp); //0x0C =12
    231             // Uart_SendByte((uint8_t)(ADCGain_Val>>8)); //12
    232             // Uart_SendByte((uint8_t)ADCGain_Val); //12
    233             // Uart_SendByte(ADCOffset_Val); //0x31=49
    234          }
    235          //==========================================================================
    236          void Afe_Device_Init(void)
    237          { 
    238            uint8_t tmp = 0; 
    239            //==For optimal performance, these bits should be programmed to 0x19 upon device startup
    240            I2C_Write(CC_CFG_ADDR,CC_CFG_INIT_VAL);   // 初始化CC_CFG寄存器为0x19
    241           
    242            //Delay_ms(100); 
    243            I2C_Write(SYS_STAT_ADDR,0xFF);   // SYS_STAT寄存器清零，写"1"清零
    244            SYS_STAT_Last = 0x00;          
    245            ClrWdt(); 
    246            //Delay_us(50);  
    247             /**/
    248            Afe_CellBalance_Disable();       // 关闭充电均衡
    249            Afe_Get_SysStatus();             // 读取AFE IC的状态
    250            ClrWdt();                   
    251            Afe_ADC_Enable();                // 开启ADC模块，同时使能过放UV、过充OV硬件检测功能
    252            Afe_CC_Disable();                // 关闭电流检测模块
    253            ClrWdt(); 
    254            Afe_CC_1Shot_Set();              // 开启电流检测--单次采样模式
    255            Afe_Temp_Enable();               // 开启温度检测模块
    256            Afe_Get_GainOffset();            // 获取电芯采样值得Gain Offset值，用来电芯电压AD值换算实际电压值（单位mV）//ADCGain_Val = 377 ADCOffset_Val = 47
    257            ClrWdt();   
    258            Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);  // 设置短路电流保护值、及延时时间（参数虚设，请在函数内部进行修改）
    259            Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);  // 设置放电过流保护值及延时时间（参数虚设，请在函数内部进行修改）
    260            ClrWdt(); 
    261            Afe_OV_UV_Delay_Set(OV_DELAY_SET,UV_DELAY_SET);    // 设置过充OV、过放UV的保护电压值
    262            Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, UV_THREHOLD_VAL_SET);  // 设置过充OV、过放UV的保护的延时时间
    263          }
    264          
    265          //==========================================================================
    266          void Afe_SCD_Set(uint16_t SCD_val, uint16_t SCD_delay)//mA
    267          {
    268            uint8_t RSNS_mark = 0;
    269            uint8_t SCD_val_tmp = 0;
    270            uint8_t SCD_delay_tmp = 0;
    271            SCD_val = (uint16_t)((uint32_t)5*SCD_val/1000);
    272            if(SCD_val > 100)
    273            {
    274              RSNS_mark = 0x01; 
    275              if(SCD_val > 178)
    276              {
    277                SCD_val_tmp = 0x07;  // 200mV
    278              }
    279              else if(SCD_val > 155)
    280              {
    281                SCD_val_tmp = 0x06;  // 178mV
    282              }
    283              else if(SCD_val > 133)
    284              {
    285                SCD_val_tmp = 0x05;  // 155mV
    286              } 
    287              else if(SCD_val > 111)
    288              {
    289                SCD_val_tmp = 0x04;  // 133mV
    290              }
    291              else if(SCD_val > 89)
    292              {
    293                SCD_val_tmp = 0x03;  // 111mV
    294              } 
    295              else if(SCD_val > 67)
    296              {
    297                SCD_val_tmp = 0x02;  // 89mV
    298              }
    299              else if(SCD_val > 44)
    300              {
    301                SCD_val_tmp = 0x01;  // 67mV
    302              } 
    303              else
    304              {
    305                SCD_val_tmp = 0x00;  // 44mV
    306              } 
    307            }
    308            else
    309            {
    310              if(SCD_val > 89)
    311              {
    312                SCD_val_tmp = 0x07;  // 100mV
    313              }
    314              else if(SCD_val > 78)
    315              {
    316                SCD_val_tmp = 0x06;  // 89mV
    317              }
    318              else if(SCD_val > 67)
    319              {
    320                SCD_val_tmp = 0x05;  // 78mV
    321              } 
    322              else if(SCD_val > 56)
    323              {
    324                SCD_val_tmp = 0x04;  // 67mV
    325              }
    326              else if(SCD_val > 44)
    327              {
    328                SCD_val_tmp = 0x03;  // 56mV
    329              } 
    330              else if(SCD_val > 33)
    331              {
    332                SCD_val_tmp = 0x02;  // 44mV
    333              }
    334              else if(SCD_val > 22)
    335              {
    336                SCD_val_tmp = 0x01;  // 33mV
    337              } 
    338              else
    339              {
    340                SCD_val_tmp = 0x00;  // 22mV
    341              } 
    342            } 
    343            //========================
    344            if(SCD_delay > 200)
    345            {
    346              SCD_delay_tmp = 0x03;  // 400uS
    347            }
    348            else if(SCD_delay > 100)
    349            {
    350              SCD_delay_tmp = 0x02;  // 200uS
    351            }
    352            else if(SCD_delay > 70)
    353            {
    354              SCD_delay_tmp = 0x01;  // 100uS
    355            } 
    356            else
    357            {
    358              SCD_delay_tmp = 0x00;  // 70uS
    359            }
    360            //== Protect page36
    361            RSNS_mark = 1;
    362            //SCD_val_tmp = 0x02;    // 44mV
    363            SCD_val_tmp = 0x07;      // 200mV/5mR = 40A   
    364            SCD_delay_tmp = 0x00;    // 70uS
    365            PROTECT1_Last =  (RSNS_mark <<8) + (SCD_delay_tmp << 3) + SCD_val_tmp; //SCD
    366            I2C_Write(PROTECT1_ADDR,PROTECT1_Last);
    367          }
    368          
    369          //==========================================================================
    370          void Afe_OCD_Set(uint16_t OCD_val, uint16_t OCD_delay)
    371          { 
    372            uint8_t OCD_val_tmp,OCD_delay_tmp;
    373            //OCD_val = OCD_val/1000;
    374            OCD_val = (uint16_t)((uint32_t)5*OCD_val/1000);   //采样电阻阻值 5mR
    375            if(SCD_THREHOLD_VAL_SET >= 100000)
    376            { 
    377              if(OCD_val > 94)
    378              {
    379                OCD_val_tmp = 0x0F;  // 100 
    380              }
    381              else if(OCD_val > 89)
    382              {
    383                OCD_val_tmp = 0x0E;  //  94
    384              }
    385              else if(OCD_val > 83)
    386              {
    387                OCD_val_tmp = 0x0D;  //  89
    388              } 
    389              else if(OCD_val > 78)
    390              {
    391                OCD_val_tmp = 0x0C;  //  83
    392              }
    393              else if(OCD_val > 72)
    394              {
    395                OCD_val_tmp = 0x0B;  // 78 
    396              } 
    397              else if(OCD_val > 67)
    398              {
    399                OCD_val_tmp = 0x0A;  //  72
    400              }
    401              else if(OCD_val > 61)
    402              {
    403                OCD_val_tmp = 0x09;  //  67
    404              } 
    405              else if(OCD_val > 56)
    406              {
    407                OCD_val_tmp = 0x08;  //  61
    408              } 
    409              else if(OCD_val > 50)
    410              {
    411                OCD_val_tmp = 0x07;  //  56
    412              }
    413              else if(OCD_val > 44)
    414              {
    415                OCD_val_tmp = 0x06;  //  50
    416              }
    417              else if(OCD_val > 39)
    418              {
    419                OCD_val_tmp = 0x05;  //  44
    420              } 
    421              else if(OCD_val > 33)
    422              {
    423                OCD_val_tmp = 0x04;  //  39
    424              }
    425              else if(OCD_val > 28)
    426              {
    427                OCD_val_tmp = 0x03;  //  33
    428              } 
    429              else if(OCD_val > 22)
    430              {
    431                OCD_val_tmp = 0x02;  // 28 
    432              }
    433              else if(OCD_val > 17)
    434              {
    435                OCD_val_tmp = 0x01;  // 22mV
    436              } 
    437              else
    438              {
    439                OCD_val_tmp = 0x00;  // 17mV
    440              } 
    441            }
    442            else
    443            { 
    444              if(OCD_val > 47)
    445              {
    446                OCD_val_tmp = 0x0F;  //  50
    447              }
    448              else if(OCD_val > 44)
    449              {
    450                OCD_val_tmp = 0x0E;  //  47
    451              }
    452              else if(OCD_val > 42)
    453              {
    454                OCD_val_tmp = 0x0D;  //  44
    455              } 
    456              else if(OCD_val > 39)
    457              {
    458                OCD_val_tmp = 0x0C;  //  42
    459              }
    460              else if(OCD_val > 36)
    461              {
    462                OCD_val_tmp = 0x0B;  //  39
    463              } 
    464              else if(OCD_val > 33)
    465              {
    466                OCD_val_tmp = 0x0A;  //  36
    467              }
    468              else if(OCD_val > 31)
    469              {
    470                OCD_val_tmp = 0x09;  //  33
    471              } 
    472              else if(OCD_val > 28)
    473              {
    474                OCD_val_tmp = 0x08;  //  31
    475              } 
    476              else if(OCD_val > 25)
    477              {
    478                OCD_val_tmp = 0x07;  //  28
    479              }
    480              else if(OCD_val > 22)
    481              {
    482                OCD_val_tmp = 0x06;  //  25
    483              }
    484              else if(OCD_val > 19)
    485              {
    486                OCD_val_tmp = 0x05;  //  22
    487              } 
    488              else if(OCD_val > 17)
    489              {
    490                OCD_val_tmp = 0x04;  // 19 
    491              }
    492              else if(OCD_val > 14)
    493              {
    494                OCD_val_tmp = 0x03;  // 17 
    495              } 
    496              else if(OCD_val > 11)
    497              {
    498                OCD_val_tmp = 0x02;  // 14 
    499              }
    500              else if(OCD_val > 8)
    501              {
    502                OCD_val_tmp = 0x01;  //  11
    503              } 
    504              else
    505              {
    506                OCD_val_tmp = 0x00;  //  8
    507              } 
    508            } 
    509            //========================
    510            if(OCD_delay > 640)
    511            {
    512              OCD_delay_tmp = 0x07;  // 1280mS
    513            }
    514            else if(OCD_delay > 320)
    515            {
    516              OCD_delay_tmp = 0x06;  // 640mS
    517            }
    518            else if(OCD_delay > 160)
    519            {
    520              OCD_delay_tmp = 0x05;  // 320mS
    521            }
    522            else if(OCD_delay > 80)
    523            {
    524              OCD_delay_tmp = 0x04;  // 160mS
    525            }
    526            else if(OCD_delay > 40)
    527            {
    528              OCD_delay_tmp = 0x03;  // 80mS
    529            }
    530            else if(OCD_delay > 20)
    531            {
    532              OCD_delay_tmp = 0x02;  // 40mS
    533            }
    534            else if(OCD_delay > 8)
    535            {
    536              OCD_delay_tmp = 0x01;  // 20mS
    537            }
    538            else
    539            {
    540              OCD_delay_tmp = 0x00;  // 8mS
    541            }
    542            //== Protect page36
    543            OCD_delay_tmp = 0x06;   // 640mS
    544            OCD_val_tmp = 0x07;     //  56mV/5mR = 11A 
    545            PROTECT2_Last = (OCD_delay_tmp << 4) + OCD_val_tmp; //OCD
    546            I2C_Write(PROTECT2_ADDR,PROTECT2_Last); 
    547          }
    548          
    549          //==========================================================================
    550          //== OV_delay 为过充保护延时时间（s）、 UV_delay 为过放保护延时时间（s）
    551          void Afe_OV_UV_Delay_Set(uint8_t OV_delay, uint8_t UV_delay)
    552          {
    553            if(OV_delay > 4)
    554            {
    555              OV_delay = 0x30;  // 8s
    556            }
    557            else if(OV_delay > 2)
    558            {
    559              OV_delay = 0x20;  // 4s
    560            }
    561            else if(OV_delay > 1)
    562            {
    563              OV_delay = 0x10;  // 2s
    564            }
    565            else
    566            {
    567              OV_delay = 0x00;  // 1s
    568            }
    569            //==============================
    570            if(UV_delay > 8)
    571            {
    572              UV_delay = 0x30;
    573            }
    574            else if(UV_delay > 4)
    575            {
    576              UV_delay = 0x20;
    577            }
    578            else if(UV_delay > 2)
    579            {
    580              UV_delay = 0x10;
    581            }
    582            else
    583            {
    584              UV_delay = 0x00;
    585            }
    586            PROTECT3_Last = (UV_delay << 2) + OV_delay ; //OV, UV delay time 4s
    587            I2C_Write(PROTECT3_ADDR,PROTECT3_Last);
    588          }
    589          
    590          //==========================================================================
    591          //== OV_val为过充保护电压值（mV）、 UV_val为过放保护电压值（mV）
    592          void Afe_OV_UV_Threshold_Set(uint16_t OV_val, uint16_t UV_val)
    593          { 
    594            //==OV UV threshold setting
    595            /*
    596            if(OV_val >= 4250)
    597            {
    598              OV_val = 4250;
    599            }
    600            if(UV_val <= 2000)
    601            {
    602              UV_val = 2000;
    603            } */
    604            OV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (OV_val - ADCOffset_Val)/ADCGain_Val) >> 4);  
    605            if(0 == UV_val)
    606            {
    607              UV_TRIP_Last = 0;
    608            }
    609            else
    610            {
    611              UV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (UV_val - ADCOffset_Val)/ADCGain_Val) >> 4);  
    612            }
    613            I2C_Write(UV_TRIP_ADDR,UV_TRIP_Last);
    614            I2C_Write(OV_TRIP_ADDR,OV_TRIP_Last);  
    615          }
    616          
    617          //==========================================================================
    618          void Afe_CC_Disable(void)
    619          { 
    620            // 电流采样结束标志位，写"1"清零
    621            SYS_STAT_Last |= 0x80;
    622            I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    623            SYS_STAT_Last &= ~0x80;
    624              
    625            SYS_CTRL2.Bit.CC_EN = 0;       // 关闭电流连续采样模式
    626            SYS_CTRL2.Bit.CC_ONESHOT = 0;  // 开启电流单次采样模式
    627            SYS_CTRL2.Bit.DELAY_DIS = 0;   // 强制为0
    628            SYS_CTRL2_Last = SYS_CTRL2.Byte;
    629            
    630            //SYS_CTRL2_Last &= ~0x40;
    631            //SYS_CTRL2_Last |= 0x20;
    632            //I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last); 
    633            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    634            //SYS_CTRL2_Last = 0x20;
    635          }
    636          //==========================================================================
    637          void Afe_CC_1Shot_Set(void)
    638          { 
    639            // 电流采样结束标志位，写"1"清零
    640            SYS_STAT_Last |= 0x80;
    641            I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    642            SYS_STAT_Last &= ~0x80;
    643            
    644            SYS_CTRL2.Bit.CC_EN = 0;       // 关闭电流连续采样模式
    645            SYS_CTRL2.Bit.CC_ONESHOT = 1;  // 开启电流单次采样模式
    646            SYS_CTRL2.Bit.DELAY_DIS = 0;   // 强制为0
    647            SYS_CTRL2_Last = SYS_CTRL2.Byte;
    648            
    649            //SYS_CTRL2_Last &= ~0x40;
    650            //SYS_CTRL2_Last |= 0x20;
    651            //I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last); 
    652            
    653            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    654            //SYS_CTRL2_Last = 0x20;
    655          }
    656          
    657          
    658          //==========================================================================
    659          void Afe_CC_AlwaysOn_Set(void)
    660          {
    661            SYS_CTRL2_Last |= 0x40;   // 开启电流连续采样模式
    662            SYS_CTRL2_Last &= ~0x20;
    663            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last); 
    664          }
    665          
    666          //==========================================================================
    667          /*-------------------------------------------------------------------------
    668                SYS_STAT (0x00)/RESET:0x00
    669                BIT      7      6           5             4       3   2    1     0
    670                NAME CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    671          -------------------------------------------------------------------------*/
    672          void Afe_Get_SysStatus(void)
    673          { 
    674              I2C_Read(SYS_STAT_ADDR,&SYS_STAT_Last); 
    675              SYS_STAT.Byte = SYS_STAT_Last;
    676              I2C_Read(SYS_CTRL1_ADDR,&SYS_CTRL1_Last); 
    677              SYS_CTRL1.Byte = SYS_CTRL1_Last;
    678              I2C_Read(SYS_CTRL2_ADDR,&SYS_CTRL2_Last); 
    679              SYS_CTRL2.Byte = SYS_CTRL2_Last;
    680              
    681             // I2C_Read(PROTECT1_ADDR,&PROTECT1_Last_Copy); 
    682             // I2C_Read(PROTECT2_ADDR,&PROTECT2_Last_Copy); 
    683             // I2C_Read(PROTECT3_ADDR,&PROTECT3_Last_Copy); 
    684          }
    685          /*---------------------------------------------------------
    686            打开充电MOS、打开放电MOS
    687          ---------------------------------------------------------*/
    688          void Afe_FET_ChgOn_DisOn(void)
    689          {
    690            SYS_CTRL2_Last |= 0x03;
    691            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    692          }
    693          /*---------------------------------------------------------
    694            打开充电MOS、关闭放电MOS
    695          ---------------------------------------------------------*/
    696          void Afe_FET_ChgOn_DisOff(void)
    697          {
    698            SYS_CTRL2_Last |= 0x01;
    699            SYS_CTRL2_Last &= ~0x02;
    700            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    701          }
    702          /*---------------------------------------------------------
    703            关闭充电MOS、打开放电MOS
    704          ---------------------------------------------------------*/
    705          void Afe_FET_ChgOff_DisOn(void)
    706          {
    707            SYS_CTRL2_Last &= ~0x01;
    708            SYS_CTRL2_Last |= 0x02;
    709            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    710          }
    711          /*---------------------------------------------------------
    712            关闭充电MOS、关闭放电MOS
    713          ---------------------------------------------------------*/
    714          void Afe_FET_ChgOff_DisOff(void)
    715          {
    716            SYS_CTRL2_Last &= ~0x03;
    717            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    718          }
    719          
    720          //==========================================================================
    721          /*
    722                SYS_STAT (0x00)/RESET:0x00
    723                BIT      7      6           5             4       3   2    1     0
    724                NAME CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    725            
    726                      CHG, DSG Response Under Various System Events
    727              EVENT                         [CHG_ON]              [DSG_ON]
    728              OV Fault                      Set to 0              ―
    729              UV Fault                      ―                    Set to 0
    730              OCD Fault                     ―                    Set to 0  
    731              SCD Fault                     ―                    Set to 0
    732              ALERT Override                Set to 0              Set to 0
    733              DEVICE_XREADY is set          Set to 0              Set to 0
    734              Enter SHIP mode from NORMAL   Set to 0              Set to 0
    735          */
    736          void Afe_FET_ChgDis_Cntrl(void)
    737          { 
    738            if(WorkMode == IDLE_MODE)
    739            {
    740              Afe_FET_ChgOff_DisOff(); // 关闭充电MOS、关闭放电MOS
    741              ALERT_PIN_HIGH();
    742            }
    743            else if(WorkMode == CHARGE_MODE)
    744            { 
    745              if(Bits_flag.Bit.ChgOv || Bits_flag.Bit.ChgTemp || Bits_flag.Bit.ChgCurOv || Bits_flag.Bit.AfeErr)
    746              {
    747                Afe_FET_ChgOff_DisOff();  // 关闭充电MOS、关闭放电MOS
    748                ALERT_PIN_HIGH();
    749              }
    750              else
    751              { 
    752                ALERT_PIN_LOW();
    753                Afe_FET_ChgOn_DisOn();  // 开启充电MOS、开启放电MOS
    754              }
    755            }
    756            else if(WorkMode == DISCHARGE_MODE)
    757            { 
    758              if(Bits_flag.Bit.DisOv || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisCurShort)
    759              {
    760                Afe_FET_ChgOff_DisOff();  // 关闭充电MOS、关闭放电MOS
    761                ALERT_PIN_HIGH();
    762              }
    763              else
    764              { 
    765                ALERT_PIN_LOW();
    766                Afe_FET_ChgOn_DisOn();  // 开启充电MOS、开启放电MOS
    767              }
    768            }
    769          }
    770          
    771          #endif

   Section sizes:

     Function/Label          Bytes
     --------------          -----
     _A_PC_ODR                  1
     _A_PD_IDR                  1
     Afe_CellBalance_Enable    38
     Afe_CellBalance_Disable   71
     Afe_Get_Adc               54
     ChgDis_AbnormalCheck     133
     ?Subroutine3              14
     AfeErr_Cnt                 1
     ?Subroutine5               2
     ??Subroutine6_0            4
     Afe_AbnormalCheck         40
     Afe_EnterShipMode         34
     ?Subroutine2               8
     Afe_ADC_Disable           10
     Afe_ADC_Enable            10
     Afe_Temp_Disable          10
     Afe_Temp_Enable           10
     Afe_Get_GainOffset        72
     Afe_Device_Init           95
     Afe_SCD_Set               13
     Afe_OCD_Set               13
     Afe_OV_UV_Delay_Set       73
     Afe_OV_UV_Threshold_Set   74
     ?Subroutine4              29
     Afe_CC_Disable            11
     ?Subroutine1              18
     ?Subroutine0               3
     ??Subroutine7_0            8
     Afe_CC_1Shot_Set          13
     Afe_CC_AlwaysOn_Set       13
     Afe_Get_SysStatus         42
     Afe_FET_ChgOn_DisOn       11
     Afe_FET_ChgOn_DisOff      13
     Afe_FET_ChgOff_DisOn      13
     Afe_FET_ChgOff_DisOff     11
     Afe_FET_ChgDis_Cntrl      34

 
   1 byte  in section .near.bss
   2 bytes in section .near.noinit
 997 bytes in section .near_func.text
 
 997 bytes of CODE memory
   1 byte  of DATA memory (+ 2 bytes shared)

Errors: none
Warnings: 1
