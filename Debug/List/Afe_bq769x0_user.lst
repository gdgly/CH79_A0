###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM830/Mar/2016  19:50:05 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\GitPath\CH79_A0\sys\src\Afe_bq769x0_user. #
#                    c                                                        #
#    Command line =  D:\ProjectPath\GitPath\CH79_A0\sys\src\Afe_bq769x0_user. #
#                    c -e -Ohz --debug --code_model small --data_model        #
#                    medium -o D:\ProjectPath\GitPath\CH79_A0\Debug\Obj\      #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0 Evaluation\stm8\LIB\dlstm8smn.h" -lcN      #
#                    D:\ProjectPath\GitPath\CH79_A0\Debug\List\ -I            #
#                    D:\ProjectPath\GitPath\CH79_A0/user/\ -I                 #
#                    D:\ProjectPath\GitPath\CH79_A0/user/src/\ -I             #
#                    D:\ProjectPath\GitPath\CH79_A0/user/inc/\ -I             #
#                    D:\ProjectPath\GitPath\CH79_A0/addon/\ -I                #
#                    D:\ProjectPath\GitPath\CH79_A0/addon/src/\ -I            #
#                    D:\ProjectPath\GitPath\CH79_A0/addon/inc/\ -I            #
#                    D:\ProjectPath\GitPath\CH79_A0/sys/\ -I                  #
#                    D:\ProjectPath\GitPath\CH79_A0/sys/inc/\ -I              #
#                    D:\ProjectPath\GitPath\CH79_A0/sys/src/\ -I              #
#                    D:\ProjectPath\GitPath\CH79_A0/lib/\ -I                  #
#                    D:\ProjectPath\GitPath\CH79_A0/lib/src/\ -I              #
#                    D:\ProjectPath\GitPath\CH79_A0/lib/inc/\ --vregs 16      #
#    List file    =  D:\ProjectPath\GitPath\CH79_A0\Debug\List\Afe_bq769x0_us #
#                    er.lst                                                   #
#    Object file  =  D:\ProjectPath\GitPath\CH79_A0\Debug\Obj\Afe_bq769x0_use #
#                    r.o                                                      #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\GitPath\CH79_A0\sys\src\Afe_bq769x0_user.c
      1          //
      2          #include "stm8s.h" 
      3          #include "user.h"
      4          #include "macro_def.h"
      5          #include "iostm8s003f3.h"
      6          #include "bq769x0.h"
      7          
      8          #if 1
      9          void Afe_CellBalance_Enable(uint16_t selct)
     10          { 
     11            //==============cell balance on
     12            CELLBAL1_Last = (uint8_t)(selct & 0x001F);
     13            I2C_Write(CELLBAL1_ADDR,CELLBAL1_Last);
     14            CELLBAL2_Last =  (uint8_t)(selct >> 5);
     15            I2C_Write(CELLBAL2_ADDR,CELLBAL2_Last);
     16          }
     17          void Afe_CellBalance_Disable(void)
     18          { 
     19            uint8_t tmp1 = 0x01;
     20            uint8_t tmp2 = 0x01;
     21              CellBal_Cntrl_Lock = 0;
     22              CellBalance_Cur_Selct = 0;
     23              //==============cell balance off
     24              CELLBAL1_Last = 0x00;
     25              I2C_Write(CELLBAL1_ADDR,CELLBAL1_Last);
     26              CELLBAL2_Last = 0x00;
     27              I2C_Write(CELLBAL2_ADDR,CELLBAL2_Last);
     28              
     29              I2C_Read(CELLBAL2_ADDR,&tmp1);
     30              if(tmp1 == 0x00)
     31              {
     32                I2C_Read(CELLBAL2_ADDR,&tmp2);
     33                if(tmp2 == 0x00)
     34                { 
     35                  CellBalance_Selct = 0;
     36                  CellBal_Cntrl_Lock = 0;
     37                }
     38              }   
     39          }
     40          //====================================================================
     41          uint16_t Afe_Get_Adc(uint8_t addr)
     42          { 
     43            uint8_t adcval,tmpval = 0; 
     44            uint16_t adv_result ;    
     45            I2C_Read(addr,&tmpval);
     46            adcval = tmpval;
     47            I2C_Read(addr + 1,&tmpval);
     48            adv_result = ((uint16_t)adcval << 8 ) + (uint16_t)tmpval;
     49            return adv_result; 
     50          }
     51          //==========================================================================
     52          /*      SYS_STAT (0x00)/RESET:0x00
     53                  BIT        7      6           5             4       3   2    1     0
     54                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
     55          Why is the DEVICE_XREADY bit high on my part and it cannot be cleared?
     56              For the bq76930 and bq76940 it typically indicates that the voltage on the bottom cell group is adequate,
     57              but one of the upper cell groups¨ supply voltage is below VSHUT. Raise all cell group supply voltages above
     58              VPORA and clear the status bit. Another possibility is that the part has been damaged.
     59          */
     60          void Afe_AbnormalCheck(void)
     61          {
     62            /* 
     63            if(SYS_STAT.Bit.DEVICE_XREADY)// || SYS_STAT.Bit.OVRD_ALERT)
     64            {
     65              Bits_flag.Bit.AfeErr = 1;
     66            } 
     67             
     68            if(SYS_STAT.Bit.OVRD_ALERT)
     69            {
     70              SYS_STAT_Last |= 0x10;
     71              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
     72              SYS_STAT_Last &= ~0x10;
     73              SYS_STAT.Bit.OVRD_ALERT = 0;
     74            }*/
     75            if(Bits_flag.Bit.AfeErr )//&& DEVICE_XREADY_Re_t >= DEVICE_XREADY_Re_SET)//SYS_STAT.Bit.DEVICE_XREADY
     76            {
     77              SYS_STAT_Last |= 0x30;
     78              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
     79              SYS_STAT_Last &= ~0x30;
     80              SYS_STAT.Bit.DEVICE_XREADY = 0;
     81              Bits_flag.Bit.AfeErr = 0;
     82              DEVICE_XREADY_Re_t = 0;
     83              Afe_Device_Init();
     84              /*Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);
     85              Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);
     86              Afe_OV_UV_Delay_Set(OV_DELAY_SET,UV_DELAY_SET); 
     87              Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, UV_THREHOLD_VAL_SET);*/
     88            } 
     89              
     90            if(0)//(SYS_STAT.Bit.CC_READY) //CC_Volt_Sample_Cnt >= 26 (0)//IS_ALERT()&& 
     91            {
     92              //CC_Volt_Sample_Cnt = 0;
     93              //CC_AD = Afe_Get_Adc(CC_HI_ADDR); 
     94              //CC_Val = (int32_t)CC_AD * 820/100; //mA (int32_t)
     95              SYS_STAT_Last |= 0x80;
     96              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
     97              SYS_STAT_Last &= ~0x80;
     98              Afe_CC_1Shot_Set();
     99            }
    100          }
    101          
    102          //==========================================================================
    103          /*
    104            Waking from SHIP mode to NORMAL mode requires pulling the TS1 pin greater than VBOOT, which triggers the device boot-up sequence.
    105            In order to exit SHIP mode into NORMAL mode, the device must follow the standard boot sequence by applying a voltage greater than the VBOOT threshold on the TS1 pin.
    106            
    107          To enter SHIP mode from NORMAL mode, the [SHUT_A] and [SHUT_B] bits in the SYS_CTRL1 register must be written with specific patterns across two consecutive writes:
    108             Write #1: [SHUT_A] = 0, [SHUT_B] = 1
    109             Write #2: [SHUT_A] = 1, [SHUT_B] = 0
    110            Table 7-7. SYS_CTRL1 (0x04)/RESET:0x00
    111            BIT       7         6   5     4         3       2     1       0
    112            NAME  LOAD_PRESENT  ！  ！  ADC_EN  TEMP_SEL  RSVD  SHUT_A  SHUT_B
    113          */
    114          
    115          void Afe_EnterShipMode(void)
    116          {
    117            SYS_CTRL1_Last &= ~0x02;
    118            SYS_CTRL1_Last |= 0x01;
    119            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    120            
    121            SYS_CTRL1_Last |= 0x02;
    122            SYS_CTRL1_Last &= ~0x01;
    123            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    124          }
    125           void Afe_ADC_Disable(void)
    126           { 
    127            //==ADC enable command
    128            SYS_CTRL1_Last &= ~0x10;
    129            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    130           }
    131          //==========================================================================
    132          /* This bit is set automatically whenever the device enters NORMAL mode. 
    133             When enabled, the ADC ensures that the integrated OV and UV protections are functional.*/
    134          void Afe_ADC_Enable(void)
    135          {
    136            //==ADC enable command
    137            SYS_CTRL1_Last |= 0x10;
    138            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    139          }
    140           
    141            void Afe_Temp_Disable(void)
    142          {
    143            //==TEMP_SEL (Bit 3): TSx_HI and TSx_LO temperature source
    144            SYS_CTRL1_Last &= ~0x08;
    145            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    146          }
    147          //========================================================================== 
    148          void Afe_Temp_Enable(void)
    149          {
    150            //==TEMP_SEL (Bit 3): TSx_HI and TSx_LO temperature source
    151            SYS_CTRL1_Last |= 0x08;
    152            I2C_Write(SYS_CTRL1_ADDR,SYS_CTRL1_Last);
    153          }
    154          
    155          //===============================================
    156          //ADCGAIN is stored in units of μV/LSB, while ADCOFFSET is stored in mV.
    157          void Afe_Get_GainOffset(void)
    158          {
    159            uint8_t tmpval = 0;
    160            uint8_t gain_val_tmp = 0;
    161            
    162            //==get adc gian value 
    163            I2C_Read(ADCGAIN1_ADDR,&tmpval);
    164            gain_val_tmp = (tmpval & 0x0C)>>2; 
    165            I2C_Read(ADCGAIN2_ADDR,&tmpval); 
    166            gain_val_tmp = (gain_val_tmp << 3) + ((tmpval & 0xE0) >> 5); 
    167            ADCGain_Val = 365 + gain_val_tmp;
    168            
    169            //===get adc offset value
    170            I2C_Read(ADCOFFSET_ADDR,&tmpval );
    171            ADCOffset_Val = tmpval ;
    172            
    173            
    174             // Uart_SendByte(gain_val_tmp); //0x0C =12
    175             // Uart_SendByte((uint8_t)(ADCGain_Val>>8)); //12
    176             // Uart_SendByte((uint8_t)ADCGain_Val); //12
    177             // Uart_SendByte(ADCOffset_Val); //0x31=49
    178          }
    179          //==========================================================================
    180          void Afe_Device_Init(void)
    181          { 
    182            uint8_t tmp = 0; 
    183            //==For optimal performance, these bits should be programmed to 0x19 upon device startup
    184            I2C_Write(CC_CFG_ADDR,CC_CFG_INIT_VAL); 
    185             
    186            //Delay_ms(100); 
    187            I2C_Write(SYS_STAT_ADDR,0xFF); 
    188            SYS_STAT_Last = 0x00; 
    189            ClrWdt(); 
    190            //Delay_us(50);  
    191             /**/
    192            Afe_CellBalance_Disable(); 
    193            Afe_Get_SysStatus(); 
    194            ClrWdt(); 
    195            Afe_ADC_Enable();
    196            Afe_CC_Disable();
    197            ClrWdt(); 
    198            Afe_CC_1Shot_Set();
    199            Afe_Temp_Enable();
    200            Afe_Get_GainOffset();
    201            ClrWdt();   
    202            Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);
    203            Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);
    204            ClrWdt(); 
    205            Afe_OV_UV_Delay_Set(OV_DELAY_SET,UV_DELAY_SET); 
    206            Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, UV_THREHOLD_VAL_SET);
    207          }
    208          
    209          //==========================================================================
    210          void Afe_SCD_Set(uint16_t SCD_val, uint16_t SCD_delay)//mA
    211          {
    212            uint8_t RSNS_mark = 0;
    213            uint8_t SCD_val_tmp = 0;
    214            uint8_t SCD_delay_tmp = 0;
    215            SCD_val = (uint16_t)((uint32_t)5*SCD_val/1000);
    216            if(SCD_val > 100)
    217            {
    218              RSNS_mark = 0x01; 
    219              if(SCD_val > 178)
    220              {
    221                SCD_val_tmp = 0x07;  // 200mV
    222              }
    223              else if(SCD_val > 155)
    224              {
    225                SCD_val_tmp = 0x06;  // 178mV
    226              }
    227              else if(SCD_val > 133)
    228              {
    229                SCD_val_tmp = 0x05;  // 155mV
    230              } 
    231              else if(SCD_val > 111)
    232              {
    233                SCD_val_tmp = 0x04;  // 133mV
    234              }
    235              else if(SCD_val > 89)
    236              {
    237                SCD_val_tmp = 0x03;  // 111mV
    238              } 
    239              else if(SCD_val > 67)
    240              {
    241                SCD_val_tmp = 0x02;  // 89mV
    242              }
    243              else if(SCD_val > 44)
    244              {
    245                SCD_val_tmp = 0x01;  // 67mV
    246              } 
    247              else
    248              {
    249                SCD_val_tmp = 0x00;  // 44mV
    250              } 
    251            }
    252            else
    253            {
    254              if(SCD_val > 89)
    255              {
    256                SCD_val_tmp = 0x07;  // 100mV
    257              }
    258              else if(SCD_val > 78)
    259              {
    260                SCD_val_tmp = 0x06;  // 89mV
    261              }
    262              else if(SCD_val > 67)
    263              {
    264                SCD_val_tmp = 0x05;  // 78mV
    265              } 
    266              else if(SCD_val > 56)
    267              {
    268                SCD_val_tmp = 0x04;  // 67mV
    269              }
    270              else if(SCD_val > 44)
    271              {
    272                SCD_val_tmp = 0x03;  // 56mV
    273              } 
    274              else if(SCD_val > 33)
    275              {
    276                SCD_val_tmp = 0x02;  // 44mV
    277              }
    278              else if(SCD_val > 22)
    279              {
    280                SCD_val_tmp = 0x01;  // 33mV
    281              } 
    282              else
    283              {
    284                SCD_val_tmp = 0x00;  // 22mV
    285              } 
    286            } 
    287            //========================
    288            if(SCD_delay > 200)
    289            {
    290              SCD_delay_tmp = 0x03;  // 400uS
    291            }
    292            else if(SCD_delay > 100)
    293            {
    294              SCD_delay_tmp = 0x02;  // 200uS
    295            }
    296            else if(SCD_delay > 70)
    297            {
    298              SCD_delay_tmp = 0x01;  // 100uS
    299            } 
    300            else
    301            {
    302              SCD_delay_tmp = 0x00;  // 70uS
    303            }
    304            //== Protect page36
    305            RSNS_mark = 1;
    306            //SCD_val_tmp = 0x02;    // 44mV
    307            SCD_val_tmp = 0x07;    // 200mV/5mR = 40A   
    308            SCD_delay_tmp = 0x03;  // 400uS
    309            PROTECT1_Last =  (RSNS_mark <<8) + (SCD_delay_tmp << 3) + SCD_val_tmp; //SCD
    310            I2C_Write(PROTECT1_ADDR,PROTECT1_Last);
    311            
    312            //PROTECT1_Last = 0x98 + 0x07; //SCD
    313            //I2C_Write(PROTECT1_ADDR,PROTECT1_Last);
    314            //Uart_SendByte(0x02);Uart_SendByte(PROTECT1_Last);
    315          }
    316          
    317          //==========================================================================
    318          void Afe_OCD_Set(uint16_t OCD_val, uint16_t OCD_delay)
    319          { 
    320            uint8_t OCD_val_tmp,OCD_delay_tmp;
    321            //OCD_val = OCD_val/1000;
    322            OCD_val = (uint16_t)((uint32_t)5*OCD_val/1000);
    323            if(SCD_THREHOLD_VAL_SET >= 100000)
    324            { 
    325              if(OCD_val > 94)
    326              {
    327                OCD_val_tmp = 0x0F;  // 100 
    328              }
    329              else if(OCD_val > 89)
    330              {
    331                OCD_val_tmp = 0x0E;  //  94
    332              }
    333              else if(OCD_val > 83)
    334              {
    335                OCD_val_tmp = 0x0D;  //  89
    336              } 
    337              else if(OCD_val > 78)
    338              {
    339                OCD_val_tmp = 0x0C;  //  83
    340              }
    341              else if(OCD_val > 72)
    342              {
    343                OCD_val_tmp = 0x0B;  // 78 
    344              } 
    345              else if(OCD_val > 67)
    346              {
    347                OCD_val_tmp = 0x0A;  //  72
    348              }
    349              else if(OCD_val > 61)
    350              {
    351                OCD_val_tmp = 0x09;  //  67
    352              } 
    353              else if(OCD_val > 56)
    354              {
    355                OCD_val_tmp = 0x08;  //  61
    356              } 
    357              else if(OCD_val > 50)
    358              {
    359                OCD_val_tmp = 0x07;  //  56
    360              }
    361              else if(OCD_val > 44)
    362              {
    363                OCD_val_tmp = 0x06;  //  50
    364              }
    365              else if(OCD_val > 39)
    366              {
    367                OCD_val_tmp = 0x05;  //  44
    368              } 
    369              else if(OCD_val > 33)
    370              {
    371                OCD_val_tmp = 0x04;  //  39
    372              }
    373              else if(OCD_val > 28)
    374              {
    375                OCD_val_tmp = 0x03;  //  33
    376              } 
    377              else if(OCD_val > 22)
    378              {
    379                OCD_val_tmp = 0x02;  // 28 
    380              }
    381              else if(OCD_val > 17)
    382              {
    383                OCD_val_tmp = 0x01;  // 22mV
    384              } 
    385              else
    386              {
    387                OCD_val_tmp = 0x00;  // 17mV
    388              } 
    389            }
    390            else
    391            { 
    392              if(OCD_val > 47)
    393              {
    394                OCD_val_tmp = 0x0F;  //  50
    395              }
    396              else if(OCD_val > 44)
    397              {
    398                OCD_val_tmp = 0x0E;  //  47
    399              }
    400              else if(OCD_val > 42)
    401              {
    402                OCD_val_tmp = 0x0D;  //  44
    403              } 
    404              else if(OCD_val > 39)
    405              {
    406                OCD_val_tmp = 0x0C;  //  42
    407              }
    408              else if(OCD_val > 36)
    409              {
    410                OCD_val_tmp = 0x0B;  //  39
    411              } 
    412              else if(OCD_val > 33)
    413              {
    414                OCD_val_tmp = 0x0A;  //  36
    415              }
    416              else if(OCD_val > 31)
    417              {
    418                OCD_val_tmp = 0x09;  //  33
    419              } 
    420              else if(OCD_val > 28)
    421              {
    422                OCD_val_tmp = 0x08;  //  31
    423              } 
    424              else if(OCD_val > 25)
    425              {
    426                OCD_val_tmp = 0x07;  //  28
    427              }
    428              else if(OCD_val > 22)
    429              {
    430                OCD_val_tmp = 0x06;  //  25
    431              }
    432              else if(OCD_val > 19)
    433              {
    434                OCD_val_tmp = 0x05;  //  22
    435              } 
    436              else if(OCD_val > 17)
    437              {
    438                OCD_val_tmp = 0x04;  // 19 
    439              }
    440              else if(OCD_val > 14)
    441              {
    442                OCD_val_tmp = 0x03;  // 17 
    443              } 
    444              else if(OCD_val > 11)
    445              {
    446                OCD_val_tmp = 0x02;  // 14 
    447              }
    448              else if(OCD_val > 8)
    449              {
    450                OCD_val_tmp = 0x01;  //  11
    451              } 
    452              else
    453              {
    454                OCD_val_tmp = 0x00;  //  8
    455              } 
    456            } 
    457            //========================
    458            if(OCD_delay > 640)
    459            {
    460              OCD_delay_tmp = 0x07;  // 1280mS
    461            }
    462            else if(OCD_delay > 320)
    463            {
    464              OCD_delay_tmp = 0x06;  // 640mS
    465            }
    466            else if(OCD_delay > 160)
    467            {
    468              OCD_delay_tmp = 0x05;  // 320mS
    469            }
    470            else if(OCD_delay > 80)
    471            {
    472              OCD_delay_tmp = 0x04;  // 160mS
    473            }
    474            else if(OCD_delay > 40)
    475            {
    476              OCD_delay_tmp = 0x03;  // 80mS
    477            }
    478            else if(OCD_delay > 20)
    479            {
    480              OCD_delay_tmp = 0x02;  // 40mS
    481            }
    482            else if(OCD_delay > 8)
    483            {
    484              OCD_delay_tmp = 0x01;  // 20mS
    485            }
    486            else
    487            {
    488              OCD_delay_tmp = 0x00;  // 8mS
    489            }
    490            //== Protect page36
    491            OCD_delay_tmp = 0x07;   // 1280mS
    492            //OCD_val_tmp = 0x01;     //  11A 
    493            OCD_val_tmp = 0x07;     //  56mV/5mR = 11A 
    494            PROTECT2_Last = (OCD_delay_tmp << 4) + OCD_val_tmp; //OCD
    495            I2C_Write(PROTECT2_ADDR,PROTECT2_Last);
    496            //PROTECT2_Last = 0x7F; //OCD
    497            //I2C_Write(PROTECT2_ADDR,PROTECT2_Last);
    498          }
    499          
    500          //==========================================================================
    501          void Afe_OV_UV_Delay_Set(uint8_t OV_delay, uint8_t UV_delay)
    502          {
    503            if(OV_delay > 4)
    504            {
    505              OV_delay = 0x30;  // 8s
    506            }
    507            else if(OV_delay > 2)
    508            {
    509              OV_delay = 0x20;  // 4s
    510            }
    511            else if(OV_delay > 1)
    512            {
    513              OV_delay = 0x10;  // 2s
    514            }
    515            else
    516            {
    517              OV_delay = 0x00;  // 1s
    518            }
    519            //==============================
    520            if(UV_delay > 8)
    521            {
    522              UV_delay = 0x30;
    523            }
    524            else if(UV_delay > 4)
    525            {
    526              UV_delay = 0x20;
    527            }
    528            else if(UV_delay > 2)
    529            {
    530              UV_delay = 0x10;
    531            }
    532            else
    533            {
    534              UV_delay = 0x00;
    535            }
    536            PROTECT3_Last = (UV_delay << 2) + OV_delay ; //OV, UV delay time 4s
    537            I2C_Write(PROTECT3_ADDR,PROTECT3_Last);
    538          }
    539          
    540          //==========================================================================
    541          void Afe_OV_UV_Threshold_Set(uint16_t OV_val, uint16_t UV_val)
    542          { 
    543            //==OV UV threshold setting
    544            if(OV_val >= 4250)
    545            {
    546              OV_val = 4250;
    547            }
    548            if(UV_val <= 2000)
    549            {
    550              UV_val = 2000;
    551            } 
    552            OV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (OV_val - ADCOffset_Val)/ADCGain_Val) >> 4);  
    553            UV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (UV_val - ADCOffset_Val)/ADCGain_Val) >> 4);  
    554            I2C_Write(UV_TRIP_ADDR,UV_TRIP_Last);
    555            I2C_Write(OV_TRIP_ADDR,OV_TRIP_Last);  
    556          }
    557          
    558          //==========================================================================
    559          void Afe_CC_Disable(void)
    560          { 
    561              SYS_STAT_Last |= 0x80;
    562              I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    563              SYS_STAT_Last &= ~0x80;
    564            SYS_CTRL2.Bit.CC_EN = 0;
    565            SYS_CTRL2.Bit.CC_ONESHOT = 0;
    566            SYS_CTRL2.Bit.DELAY_DIS = 0;
    567            SYS_CTRL2_Last = SYS_CTRL2.Byte;
    568            //SYS_CTRL2_Last &= ~0x40;
    569            //SYS_CTRL2_Last |= 0x20;
    570            //I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last); 
    571            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    572            //SYS_CTRL2_Last = 0x20;
    573          }
    574          //==========================================================================
    575          void Afe_CC_1Shot_Set(void)
    576          { 
    577            SYS_STAT_Last |= 0x80;
    578            I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    579            SYS_STAT_Last &= ~0x80;
    580            SYS_CTRL2.Bit.CC_EN = 0;
    581            SYS_CTRL2.Bit.CC_ONESHOT = 1;
    582            SYS_CTRL2.Bit.DELAY_DIS = 0;
    583            SYS_CTRL2_Last = SYS_CTRL2.Byte;
    584            //SYS_CTRL2_Last &= ~0x40;
    585            //SYS_CTRL2_Last |= 0x20;
    586            //I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last); 
    587            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    588            //SYS_CTRL2_Last = 0x20;
    589          }
    590          
    591          
    592          //==========================================================================
    593          void Afe_CC_AlwaysOn_Set(void)
    594          {
    595            SYS_CTRL2_Last |= 0x40;
    596            SYS_CTRL2_Last &= ~0x20;
    597            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last); 
    598          }
    599          
    600          //==========================================================================
    601          /*-------------------------------------------------------------------------
    602                SYS_STAT (0x00)/RESET:0x00
    603                BIT      7      6           5             4       3   2    1     0
    604                NAME CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    605          -------------------------------------------------------------------------*/
    606          void Afe_Get_SysStatus(void)
    607          { 
    608              I2C_Read(SYS_STAT_ADDR,&SYS_STAT_Last); 
    609              SYS_STAT.Byte = SYS_STAT_Last;
    610              I2C_Read(SYS_CTRL1_ADDR,&SYS_CTRL1_Last); 
    611              SYS_CTRL1.Byte = SYS_CTRL1_Last;
    612              I2C_Read(SYS_CTRL2_ADDR,&SYS_CTRL2_Last); 
    613              SYS_CTRL2.Byte = SYS_CTRL2_Last;
    614              
    615             // I2C_Read(PROTECT1_ADDR,&PROTECT1_Last_Copy); 
    616             // I2C_Read(PROTECT2_ADDR,&PROTECT2_Last_Copy); 
    617             // I2C_Read(PROTECT3_ADDR,&PROTECT3_Last_Copy); 
    618          }
    619          
    620          void Afe_FET_ChgOn_DisOn(void)
    621          {
    622            SYS_CTRL2_Last |= 0x03;
    623            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    624          }
    625          void Afe_FET_ChgOn_DisOff(void)
    626          {
    627            SYS_CTRL2_Last |= 0x01;
    628            SYS_CTRL2_Last &= ~0x02;
    629            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    630          }
    631          void Afe_FET_ChgOff_DisOn(void)
    632          {
    633            SYS_CTRL2_Last &= ~0x01;
    634            SYS_CTRL2_Last |= 0x02;
    635            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    636          }
    637          void Afe_FET_ChgOff_DisOff(void)
    638          {
    639            SYS_CTRL2_Last &= ~0x03;
    640            I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    641          }
    642          
    643          //==========================================================================
    644          /*
    645                SYS_STAT (0x00)/RESET:0x00
    646                BIT      7      6           5             4       3   2    1     0
    647                NAME CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    648            
    649                      CHG, DSG Response Under Various System Events
    650              EVENT                         [CHG_ON]              [DSG_ON]
    651              OV Fault                      Set to 0              ！
    652              UV Fault                      ！                    Set to 0
    653              OCD Fault                     ！                    Set to 0  
    654              SCD Fault                     ！                    Set to 0
    655              ALERT Override                Set to 0              Set to 0
    656              DEVICE_XREADY is set          Set to 0              Set to 0
    657              Enter SHIP mode from NORMAL   Set to 0              Set to 0
    658          */
    659          void Afe_FET_ChgDis_Cntrl(void)
    660          { 
    661            if(WorkMode == IDLE_MODE)
    662            {
    663              Afe_FET_ChgOff_DisOff(); 
    664            }
    665            else if(WorkMode == CHARGE_MODE)
    666            { 
    667              if(Bits_flag.Bit.ChgOv || Bits_flag.Bit.ChgTemp || Bits_flag.Bit.ChgCurOv || Bits_flag.Bit.AfeErr)
    668              {
    669                Afe_FET_ChgOff_DisOff(); 
    670              }
    671              else
    672              { 
    673                Afe_FET_ChgOn_DisOn(); 
    674              }
    675            }
    676            else if(WorkMode == DISCHARGE_MODE)
    677            { 
    678              if(Bits_flag.Bit.DisOv || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisCurShort)
    679              {
    680                Afe_FET_ChgOff_DisOff(); 
    681              }
    682              else
    683              { 
    684                Afe_FET_ChgOn_DisOn(); 
    685              }
    686            }
    687          }
    688          
    689          #endif

   Section sizes:

     Function/Label          Bytes
     --------------          -----
     Afe_CellBalance_Enable    38
     Afe_CellBalance_Disable   71
     Afe_Get_Adc               54
     ?Subroutine4               2
     ??Subroutine5_0            4
     Afe_AbnormalCheck         40
     Afe_EnterShipMode         34
     ?Subroutine2               8
     Afe_ADC_Disable           10
     Afe_ADC_Enable            10
     Afe_Temp_Disable          10
     Afe_Temp_Enable           10
     Afe_Get_GainOffset        72
     Afe_Device_Init           95
     Afe_SCD_Set               13
     Afe_OCD_Set               13
     Afe_OV_UV_Delay_Set       73
     Afe_OV_UV_Threshold_Set   85
     ?Subroutine3              29
     Afe_CC_Disable            11
     ?Subroutine1              18
     ?Subroutine0               3
     ??Subroutine6_0            8
     Afe_CC_1Shot_Set          13
     Afe_CC_AlwaysOn_Set       13
     Afe_Get_SysStatus         42
     Afe_FET_ChgOn_DisOn       11
     Afe_FET_ChgOn_DisOff      13
     Afe_FET_ChgOff_DisOn      13
     Afe_FET_ChgOff_DisOff     11
     Afe_FET_ChgDis_Cntrl      34

 
 861 bytes in section .near_func.text
 
 861 bytes of CODE memory

Errors: none
Warnings: 1
