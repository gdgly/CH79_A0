###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM808/Apr/2016  16:55:05 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \user.c                                                  #
#    Command line =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \user.c -e --enable_multibytes -Ohz --debug              #
#                    --code_model small --data_model medium -o                #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\ --dlib_config "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /user/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79 #
#                    _A0/user/src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/user/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_ #
#                    C-version\CH79_A0/addon/\ -I                             #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/addon/s #
#                    rc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /addon/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version #
#                    \CH79_A0/sys/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/sys/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C #
#                    -version\CH79_A0/sys/src/\ -I                            #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/\   #
#                    -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/ #
#                    src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A #
#                    0/lib/inc/\ --vregs 16                                   #
#    List file    =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\user.lst                                             #
#    Object file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\user.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src\user.c
      1          
      2          #include "stm8s.h" 
      3          #include "user.h"
      4          #include "macro_def.h"
      5          #include "iostm8s003f3.h"
      6          #include "bq769x0.h"
      7          #include "string.h"
      8          //==================================================================
      9          //==================================================================
     10          //==================================================================
     11          #if 1
     12          void PWM2_Init(void)
     13          { 
     14              CLK_PCKENR1 |= 0xA0; 
     15              TIM2_CR1 =0;              //关闭TIM2
     16              TIM2_IER = 0; 
     17              TIM2_PSCR = 0;  
     18              TIM2_ARRH = 0x07;
     19              TIM2_ARRL = 0xCF;         //16M/(1999+1)=8KHz   //2MHz/(1999+1) = 1KHz 
     20              TIM2_CR1 |= 0x80;         //使能ARP,边沿对齐，向上计数
     21              TIM2_EGR |= 0x01;         //更新TIM1，使PSC有效
     22              TIM2_EGR |= 0x20;         //重新初始化TIM1 
     23              TIM2_CCR1H =0;           
     24              TIM2_CCR1L =0; 
     25              TIM2_CCMR1 =0X68;         //配置TIM2_CH1为PWM1模式输出 
     26              TIM2_CCER1 =0x01;         //Enable TIM2_CH1 channel 
     27              TIM2_CR1 |= 0x01;         //使能TIM2 
     28          }
     29          //==================================================================
     30          //==================================================================
     31          void PWM1_Init(void)
     32          {
     33              CLK_PCKENR1 |= 0x80;
     34              TIM1_CR1 &= ~0x01;      //关闭TIM1 
     35              TIM1_PSCRH = 0;
     36              TIM1_PSCRL = 0;         //不分频2MHz 
     37              TIM1_ARRH = 0x07;
     38              TIM1_ARRL = 0xCF;      //2MHz/(1999+1) = 1KHz 
     39              TIM1_CR1 |= 0x80;      //使能ARP,边沿对齐，向上计数
     40              TIM1_EGR |= 0x01;      //更新TIM1，使PSC有效
     41              TIM1_EGR |= 0x20;      //重新初始化TIM1 
     42              
     43              TIM1_CCR1H = 0;
     44              TIM1_CCR1L = 0; 
     45              TIM1_CCMR1 = 0x68;       //配置TIM1_CH1为PWM1模式输出
     46              TIM1_CCER1 |= 0x01;      //Enable TIM1_CH1 channel
     47              
     48              TIM1_CCR2H = 0;
     49              TIM1_CCR2L = 0;
     50              TIM1_CCMR2 = 0x68;       //配置TIM1_CH2为PWM1模式输出
     51              TIM1_CCER1 |= 0x10;      //Enable TIM1_CH2 channel
     52              
     53              //TIM1_CCR3H = 0x07;
     54              //TIM1_CCR3L = 0xE6;       //占空比50% 
     55              //TIM1_CCMR3 = 0x68;       //配置TIM1_CH3为PWM1模式输出
     56              //TIM1_CCER2 |= 0x01;      //使能TIM1_CH3通道
     57              
     58              //TIM1_CCR4H = 0x03;
     59              //TIM1_CCR4L = 0xE6;       //占空比50%
     60              //TIM1_CCMR4 = 0x68;       //配置TIM1_CH4为PWM1模式输出 
     61              //TIM1_CCER2 |= 0x10;      //Enable TIM1_CH4 channel 
     62              
     63              TIM1_BKR |= 0x80;          //
     64              TIM1_CR1 |= 0x01;          //使能TIM1 
     65          }
     66          //==================================================================
     67          //==================================================================
     68          uint16_t ADC(int channel)
     69          {
     70              unsigned int value =0;
     71              unsigned char tempH,tempL; 
     72              //CLK_PCKENR2 |=0x08; 
     73              ADC_CSR = channel;                // 清除EOC转换结束标志, select channel
     74              nop();  nop(); nop(); nop(); 
     75              ADC_CR1 |= 0x01;                  // 开始单次转换 
     76              nop(); nop(); nop(); nop(); nop();
     77              nop(); nop(); nop(); nop(); nop();
     78              ADC_CR1 |= 0x01;                  // 开始单次转换
     79              nop(); nop(); nop(); nop();
     80              nop(); nop(); nop(); nop();
     81              while(!(ADC_CSR & 0x80))nop();    // 等待单次转换完成 
     82              tempL = ADC_DRL;                  //先 读低8位
     83              tempH = ADC_DRH;                  // 再读高8位，设置数据左对齐
     84              value=(tempH<<8)|tempL;
     85              ADC_CSR &= ~(0x80);               // 清除EOC转换结束标志  
     86              ADC_CR1 &= ~(0x01); 
     87              return(value);  
     88          }
     89          //==================================================================
     90          //==================================================================
     91          uint16_t ADConverse(unsigned char channel)
     92          { 
     93              unsigned int value=0;
     94              unsigned int max_value =0;
     95              unsigned int min_value =0xEFFF;
     96              unsigned char i;  
     97              CLK_PCKENR2 |=0x08;  
     98              for(i =0;i <100;i++)
     99              {
    100                nop();nop();
    101              }
    102              for(i=0;i<18;i++)
    103              {
    104                Adc_value[i] = ADC(channel); 
    105              }
    106              for(i =0;i<18;i++)
    107              {
    108                value +=Adc_value[i];
    109                if(max_value <Adc_value[i])
    110                  max_value =Adc_value[i];
    111                 
    112                if(min_value >Adc_value[i])
    113                  min_value =Adc_value[i];
    114              }
    115              value =value -max_value -min_value;
    116              value >>= 4; 
    117              CLK_PCKENR2 &=~(0x08); 
    118              return value; 
    119          }
    120          //================================================================================
    121          //==================================================================
    122          void SysInit(void)
    123          { 
    124              //-------system clock                                           
    125              CLK_ECKR &= ~0x01;  // external RC Disable                                              
    126              CLK_ICKR = 0x01;    // internal RC enable
    127              while(!(CLK_ICKR & 0x02)); 
    128              CLK_SWCR = 0;       // 禁止时钟切换及相关中断
    129              CLK_CKDIVR = 0x02;  // 主频为Fmaster为Fhsi：16MHz, Fcpu为4MHz  0.25us
    130              //CLK_PCKENR1 = 0;    // 禁止Fmaster 与外设连接
    131              //CLK_PCKENR2 = 0;
    132              /* */
    133              //------------------A/D conversion 
    134              CLK_PCKENR2 |= 0x08;           //使能Fmaster与外设ADC模块连接 
    135              ADC_CR1 = 0x00;               // ADC时钟=主时钟/2=8MHZ,单次转换模式Tad =1/8,未使能ADC
    136              ADC_CR2 = 0x08;               // A/D 结果数据右对齐
    137              ADC_CSR = 0x00;               // 清转换结束标志位EOC，
    138              ADC_CR3 = 0x00;
    139              ADC_TDRH = 0xFF;              //禁止施密特触发功能
    140              ADC_TDRL = 0x00; 
    141              nop(); nop();
    142              ADC_TDRL = 0x08;              // AIN3  0b0000 1000 
    143              CLK_PCKENR2 &=~(0x08);
    144             
    145          }
    146          //==================================================================
    147          //==================================================================
    148          //---------------WatchDog  LSI 128KHz/2 = 64KHz
    149          /*
    150              预分频系数    PR[2:0]   最短超时(RL[7:0]=0x00)    最长超时(RL[7:0]=0xFF)
    151              /4            0         62.5 μs                  15.90 ms     
    152              /8            1         125 μs                   31.90 ms     
    153              /16           2         250 μs                   63.70 ms     
    154              /32           3         500 μs                   127 ms     
    155              /64           4         1.00 ms                   255 ms     
    156              /128          5         2.00 ms                   510 ms     
    157              /256          6         4.00 ms                   1.02 s     
    158          */
    159          /*  */
    160          void ClrWdt(void)
    161          {
    162              IWDG_KR = 0x55;   //解除保护
    163              IWDG_RLR = 0xFF;  //刷新内容
    164              IWDG_PR = 6; 
    165              IWDG_KR = 0xAA;   //刷新及恢复保护
    166              IWDG_KR = 0xCC;   //独立看门狗启动
    167          } 
    168          
    169          //==================================================================
    170          //==================================================================
    171          void PortInit(void)
    172          { 
    173            GPIO_Init(GPIOA, GPIO_PIN_3, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    174            GPIO_Init(GPIOA, GPIO_PIN_2, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    175            GPIO_Init(GPIOA, GPIO_PIN_1, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    176            
    177            GPIO_Init(GPIOB, GPIO_PIN_5, GPIO_MODE_OUT_PP_LOW_FAST);           
    178            GPIO_Init(GPIOB, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);       
    179           
    180            GPIO_Init(GPIOC, GPIO_PIN_7, GPIO_MODE_OUT_PP_LOW_FAST);    // ALERT 
    181            GPIO_Init(GPIOC, GPIO_PIN_6, GPIO_MODE_OUT_PP_LOW_FAST);    // chger fault control 
    182            GPIO_Init(GPIOC, GPIO_PIN_5, GPIO_MODE_OUT_PP_LOW_FAST);    // LED1
    183            GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);    // LED2
    184            GPIO_Init(GPIOC, GPIO_PIN_3, GPIO_MODE_OUT_PP_LOW_FAST);    // LED3 
    185             
    186            GPIO_Init(GPIOD, GPIO_PIN_6, GPIO_MODE_IN_PU_IT);          
    187            GPIO_Init(GPIOD, GPIO_PIN_5, GPIO_MODE_OUT_PP_HIGH_FAST);          
    188            GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);    // undefined
    189            GPIO_Init(GPIOD, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);        // chger fault input
    190            GPIO_Init(GPIOD, GPIO_PIN_2, GPIO_MODE_IN_FL_NO_IT);        // Triger Voltage measurement
    191          #if 0
    192            CPU_CFG_GCR |=0x01;                                         //SWIN模式被禁用，SWIM引脚可被用作普通I/O口
    193            GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_OUT_PP_HIGH_FAST);   //MUC_DO3
    194          #else
    195            GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_IN_PU_NO_IT);        //SWIN 
    196          #endif
    197            //EXTI_CR1 |=0x40;//上升沿触发//0x80;//下降沿触发
    198            EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
    199            /*------------------------------------------------------------------------------------
    200              GPIO_MODE_IN_FL_NO_IT 无中断功能的浮动输入。  // ADC input
    201              
    202              GPIO_MODE_IN_PU_NO_IT 无中断功能的上拉输入。  // normal digit input
    203              
    204              GPIO_MODE_IN_FL_IT 带中断功能的浮动输入。  
    205              
    206              GPIO_MODE_IN_PU_IT 带中断功能的上拉输入。	
    207              
    208              GPIO_MODE_OUT_OD_LOW_FAST 高速开漏低电平输出，可工作到10MHz。  
    209              
    210              GPIO_MODE_OUT_PP_LOW_FAST 高速推挽低电平输出，可工作到10MHz。  
    211              
    212              GPIO_MODE_OUT_OD_LOW_SLOW 低速开漏低电平输出，可工作到2MHz。	// undefined port
    213              
    214              GPIO_MODE_OUT_PP_LOW_SLOW 低速推挽低电平输出，可工作到2MHz。	
    215              
    216              GPIO_MODE_OUT_OD_HIZ_FAST 高速开漏高阻态输出，可工作到10MHz。  
    217              
    218              GPIO_MODE_OUT_PP_HIGH_FAST 高速推挽高电平输出，可工作到10MHz。  
    219              
    220              GPIO_MODE_OUT_OD_HIZ_SLOW 低速开漏高阻态输出，可工作到2MHz。	
    221              
    222              GPIO_MODE_OUT_PP_HIGH_SLOW 低速推挽高电平输出，可工作到2MHz。
    223             ------------------------------------------------------------------------------------*/
    224          } 
    225          //============================================UART串口模块 begin
    226          /*--------------------------------
    227            配置 UART1
    228              - BaudRate = 9600 baud
    229              - Word Length = 8 Bits
    230              - One Stop Bit
    231              - No parity
    232              - Receive and transmit enabled
    233              - UART1 Clock disabled
    234          --------------------------------*/
    235          void Uart_Model_Init(void)
    236          {
    237              //UART1_DeInit(); 
    238              //UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO,UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TX_ENABLE);//UART1_MODE_TXRX_ENABLE
    239              //================================================================== 
    240              /*  */
    241              CLK_PCKENR1 |= 0x0C;         // 使能fmaster与UART连接 
    242              UART1_BRR2  =  0x02;         // 设置波特率9600
    243              UART1_BRR1  =  0x68;         // 16M/9600 = 0x0682
    244              UART1_CR1   =  0x00;          //UART使能，一个起始位，8个数据位，禁止奇偶校验，禁止中断
    245              UART1_CR3   =  0x00;          //一个停止位    
    246              UART1_CR2   =  0x08;//  send only //0x0C;           //发送及接收使能 
    247              //UART1_CR2   |= 0x20;          //接收中断使能  
    248          } 
    249          //==========================================
    250          void Uart_SendByte(uint8_t DataByte)      
    251          {   
    252              //===单线通讯时，发送数据时避免影响接收管脚，故发送数据时先禁止接收及其中断
    253              //UART1_CR2 &= ~0x04;
    254              //UART1_CR2 &= ~0x20; 
    255              while(!UART1_SR_TXE);
    256              UART1_DR = DataByte;    
    257              nop(); nop(); nop();
    258              while(!(UART1_SR &0x40)); 
    259              //========数据发送完毕，使能接收及其中断
    260              UART1_SR &= ~0x48;
    261              //UART1_CR2 |= 0x24; 
    262          }  
    263          //==========================================
    264          void itoa(char *buf, int i, int base)
    265          {
    266              #define LEN	20
    267              char *s;
    268              int rem;
    269              static char rev[LEN+1];
    270            
    271              rev[LEN] = 0;
    272              if (i == 0)
    273              {
    274                (buf)[0] = '0';
    275                ++(buf);
    276                return;
    277              }
    278              s = &rev[LEN];
    279              while (i)
    280              {
    281                rem = i % base;
    282                if (rem < 10)
    283                {
    284                  *--s = rem + '0';
    285                }
    286                else if (base == 16)
    287                {
    288                  *--s = "abcdef"[rem - 10];
    289                }
    290                i /= base;
    291              }
    292              while (*s)
    293              {
    294                (buf)[0] = *s++;
    295                ++(buf);
    296              }
    297          }
    298          
    299          //==========================================
    300          void Uart_SendStr(unsigned char *tx_pData) 
    301          {
    302              unsigned int i, nLen; 
    303              nLen = strlen(tx_pData);
    304              ClrWdt();
    305              for(i=0; i<nLen; i++)
    306              {
    307                Uart_SendByte(tx_pData[i]);
    308              }
    309          }
    310          
    311          //==========================================
    312          void Uart_SendData(unsigned int tx_data, int base) 
    313          {
    314            unsigned char buf[20] = {0};
    315          
    316            itoa((char *)buf, tx_data, base);
    317            
    318            if (base == 16)
    319            {
    320              Uart_SendStr((unsigned char *)"0x");
    321            }
    322            
    323            Uart_SendStr(buf);
    324          }
    325          //============================================UART串口模块 end
    326          
    327          //==================================================================
    328          void I2C_Model_Init(void)
    329          { 
    330            CLK_PCKENR1 |= 0x01;    // Fmaster 与外设I2C连接 
    331            I2C_CR1 = 0;
    332             
    333            //I2C_ITR   = 0x01;    //使能错误中断
    334            I2C_FREQR = 8;//输入时钟为8MHz
    335            
    336            I2C_TRISER = 9;
    337             
    338            //CRR的计算，确定I2C的通信频率f_SCL =1/(T_high + T_low), 100KHz -->T_hgih = T_low =5000ns
    339            //I2C的输入频率f_CK = 1/T_CK, CRR = T_hgih /T_CK;
    340            I2C_CCRL = 80;//40; // 上升沿及下降沿时间5000s, 
    341            I2C_CCRH = 0;  // 标准模式100KHz,  
    342               
    343            I2C_CR1 |= 0x01;//I2C_CR1_PE;
    344            
    345            I2C_CR2 |= 0x04;
    346          }
    347          //================================================================== 
    348          //=======================================================================
    349          //======================================================================= 
    350          //======================================================================= 
    351          void Timer2Init(void)
    352          { 
    353              CLK_PCKENR1 |= 0x20;    // Fmaster 与外设TIM2连接
    354              TIM2_CR1 = 0x84;        // TIM2_ARR寄存器通过缓冲预装载，使能计数器
    355              TIM2_IER = 0x00;        // 禁止中断
    356              //TIM2_EGR = 0x01;        // 允许产生更新事件 
    357              TIM2_PSCR = 0x07;       // 计数器时钟=主时钟/8=16MHZ/128    8us// 相当于计数器周期为 
    358              TIM2_CNTRH = 0;         //     
    359              TIM2_CNTRL = 0;         //     
    360              TIM2_ARRH = 0x04;       //     10ms
    361              TIM2_ARRL = 0xE2;       //   
    362              TIM2_IER |= 0x01;       // 使能更新中断，禁止触发中断  
    363              TIM2_CR1 |= 0x01;        // TIM2_ARR寄存器通过缓冲预装载，使能计数器
    364          } 
    365          //=======================================================================
    366          //==================================================================
    367          //==================================================================
    368          //--Fmaster = CK_PSC =16MHz, CK_PSC prescaler(128) to CK_CNT(8us)   TIM4_SR1.UIF更新中断标志符
    369          void Timer4_Init_us(void)
    370          {
    371              CLK_PCKENR1 |= 0x10;    //Fmaster 与外设TIM4连接
    372              TIM4_IER = 0x00;        // 禁止中断
    373              TIM4_EGR = 0x01;        // 允许产生更新事件 
    374              //TIM4_PSCR = 0x07;       // 计数器时钟=主时钟/128=16MHZ/128  // 相当于计数器周期为8uS
    375              TIM4_PSCR = 0x00;       // 计数器时钟=主时钟/128=16MHZ/1  // 相当于计数器周期为0.0625uS
    376              TIM4_CR1 = 0x15;        // TIM4_ARR寄存器通过缓冲预装载，使能计数器
    377              TIM4_CNTR = 0;          //     
    378              TIM4_ARR = 16;           // 0.0625*16 = 1us  // 6*8us = 200us  
    379              TIM4_IER |= 0x01;       //更新中断使能，禁止触发中断 
    380              TIM4_CR1 |= 0x01; 
    381          } 
    382          void Timer4_Init_ms(void)
    383          {
    384              CLK_PCKENR1 |= 0x10;    //Fmaster 与外设TIM4连接
    385              TIM4_IER = 0x00;        // 禁止中断
    386              TIM4_EGR = 0x01;        // 允许产生更新事件 
    387              TIM4_PSCR = 0x07;       // 计数器时钟=主时钟/128=16MHZ/128  // 相当于计数器周期为8uS 
    388              TIM4_CR1 = 0x15;        // TIM4_ARR寄存器通过缓冲预装载，使能计数器
    389              TIM4_CNTR = 0;          //     
    390              TIM4_ARR = 125;         // 125*8us = 1ms  
    391              TIM4_IER |= 0x01;       //更新中断使能，禁止触发中断 
    392              TIM4_CR1 |= 0x01; 
    393          } 
    394          void Timer4_Disable(void)
    395          {
    396              TIM4_CR1 &= ~0x01;
    397              TIM4_IER &= ~0x01;
    398              CLK_PCKENR1 &= ~0x10;    //Fmaster 与外设TIM4断开连接 
    399          } 
    400          void Delay_us(uint16_t Delay_time)
    401          {
    402            Delay_time_t = Delay_time;
    403            Timer4_Init_us();
    404            while(Delay_time_t > 0);  
    405            Timer4_Disable();
    406          }
    407          void Delay_ms(uint16_t Delay_time)
    408          {
    409            Delay_time_t = Delay_time;
    410            Timer4_Init_ms();
    411            while(Delay_time_t > 0)
    412            {
    413              if(Delay_time_t >= 300)
    414              {  
    415                ;//ClrWdt(); 
    416              } 
    417            }
    418            Timer4_Disable();
    419          }
    420            
    421          //==================================================================
    422          /*
    423            The following equations show how to use the 14-bit ADC readings in TS1, TS2, and TS3 to determine the
    424            resistance of the external 103AT thermistor:
    425              VTSX = (ADC in Decimal) x 382 μV/LSB                     (4)
    426              RTS = (10,000 × VTSX) ÷ (3.3 C VTSX)                   (5)
    427          */
    428          void TempCheck(void)
    429          {  
    430              static uint8_t DisTemp_Lock = 0;
    431               
    432              Temp_Val = V_TS2_Val;//R_TS2_Val;
    433              if(WorkMode == CHARGE_MODE)//if(Bits_flag.Bit.Chg)
    434              {
    435                 DisTemp_Lock = 0;
    436                 if((Temp_Val >ChgTempL_ON) || (Temp_Val < ChgTempH_ON) || (ChgTemp_cnt >= 10))
    437                 {
    438                   if((ChgTemp_cnt++) >= 10)
    439                   {
    440                     ChgTemp_cnt = 10;
    441                     Bits_flag.Bit.ChgTemp = 1;
    442                   }
    443                 }
    444                 else
    445                 {
    446                   ChgTemp_cnt = 0;
    447                 }
    448              //Bits_flag.Bit.ChgTemp = 1; 
    449                //==========================充电温度保护恢复
    450                if(Bits_flag.Bit.ChgTemp && (Temp_Val < ChgTempL_OFF) && (Temp_Val >ChgTempH_OFF))
    451                {
    452                    ChgTemp_cnt = 0;
    453                    Bits_flag.Bit.ChgTemp = 0;
    454                    
    455                    //Bits_flag.Bit.ChgTemp = 1; 
    456                } 
    457              }
    458              else if(WorkMode == DISCHARGE_MODE) 
    459              {
    460                ChgTemp_cnt = 0;
    461                if((Temp_Val > DisTempL_ON) || (Temp_Val < DisTempH_ON) || (DisTemp_cnt >= 300)) 
    462                {
    463                  if(DisTemp_cnt >= 300)
    464                  {
    465                    DisTemp_cnt = 300;
    466                    Bits_flag.Bit.DisTemp = 1;
    467                    DisTemp_Lock = 1;
    468                  }
    469                }
    470                else
    471                {
    472                  DisTemp_cnt = 0;
    473                  Temp_Protect_Delay_t = 0;
    474                }
    475                /*  
    476                //==========================放电温度保护恢复
    477                if(DisTemp_Lock == 0 && Bits_flag.Bit.DisTemp && (Temp_Val < DisTempL_OFF) && (Temp_Val > DisTempH_OFF))
    478                {
    479                  //if(DisTemp_Lock_Cnt > 30)
    480                  { 
    481                    DisTemp_cnt = 0;
    482                    DisTemp_Lock_Cnt = 30;
    483                    Bits_flag.Bit.DisTemp = 0;
    484                    Temp_Protect_Delay_t = 0;
    485                    DisTemp_Lock = 1;
    486                  } 
    487                }
    488                */
    489              }  
    490              else
    491              { 
    492                DisTemp_Lock = 0;
    493              }
    494          }
    495          //================================================================== 
    496          //==================================================================
    497          /*      SYS_STAT (0x00)/RESET:0x00
    498                  BIT        7      6           5             4       3   2    1     0
    499                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    500          */
    501          void CurrentCheck(void)
    502          {  
    503            if(WorkMode == CHARGE_MODE)
    504            {
    505              if(Current_Val > ChgCurOv_Val_SET)
    506              {
    507                if(ChgCurOv_t >= ChgCurOv_t_SET)
    508                {
    509                  ChgCurOv_t = ChgCurOv_t_SET;
    510                  Bits_flag.Bit.ChgCurOv = 1;
    511                }
    512              }
    513              else
    514              {
    515                ChgCurOv_t = 0;
    516              } 
    517              /*
    518              if(0)//(Bits_flag.Bit.ChgCurOv && ChgCurOv_Re_t >= ChgCurOv_Re_t_SET)
    519              {
    520                ChgCurOv_t = 0; 
    521                ChgCurOv_Re_t = 0;
    522                Bits_flag.Bit.ChgCurOv = 0;
    523              } */
    524            }
    525            else if(WorkMode == DISCHARGE_MODE)//9A,  15A
    526            {
    527              if(SYS_STAT.Bit.OCD || Current_Val > DisCurOv_2_Val_SET || (DisCurOv_t1 >= DisCurOv_t1_SET) || (DisCurOv_t1 >= DisCurOv_t1_SET))
    528              {
    529                if(SYS_STAT.Bit.OCD || (DisCurOv_t2 >= DisCurOv_t2_SET) || (DisCurOv_t1 >= DisCurOv_t1_SET))
    530                {
    531                  DisCurOv_t1 = DisCurOv_t1_SET;
    532                  DisCurOv_t2 = DisCurOv_t2_SET;
    533                  Bits_flag.Bit.DisCurOv = 1;
    534                } 
    535              }
    536              else if(Current_Val > DisCurOv_1_Val_SET)//9A
    537              { 
    538                DisCurOv_t2 = 0;
    539                if(DisCurOv_t1 >= DisCurOv_t1_SET)
    540                {
    541                  DisCurOv_t1 = DisCurOv_t1_SET; 
    542                  Bits_flag.Bit.DisCurOv = 1;
    543                }  
    544              }
    545              else
    546              {
    547                DisCurOv_t1 = 0;
    548                DisCurOv_t2 = 0;
    549              }
    550              /*
    551              if(Current_Val > DisCurOv_Val_SET || SYS_STAT.Bit.OCD || (DisCurOv_t >= DisCurOv_t_SET))
    552              {
    553                if(SYS_STAT.Bit.OCD || (DisCurOv_t >= DisCurOv_t_SET))
    554                {
    555                  DisCurOv_t = DisCurOv_t_SET; 
    556                  Bits_flag.Bit.DisCurOv = 1;
    557                } 
    558              }
    559              else
    560              {
    561                DisCurOv_t = 0;
    562              }
    563              */
    564              /*
    565              if(0)//(Bits_flag.Bit.DisCurOv)// && DisCurOv_Re_t >= DisCurOv_Re_t_SET)
    566              {
    567                //clear the OV bit by writing "1"
    568                if(SYS_STAT.Bit.OCD)
    569                {
    570                  SYS_STAT_Last |= 0x01;
    571                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    572                  SYS_STAT_Last &= ~0x01;
    573                }
    574                DisCurOv_t = 0;
    575                DisCurOv_Re_t = 0;
    576                Bits_flag.Bit.DisCurOv = 0;
    577              }*/
    578              
    579              //==========================短路检测
    580              //if(WorkMode != CHARGE_MODE)
    581              {
    582                if( SYS_STAT.Bit.SCD )
    583                {  
    584                   Bits_flag.Bit.DisCurShort = 1; 
    585                }
    586                /*
    587                if(Bits_flag.Bit.DisCurShort && DisCurShort_Re_t >= DisCurShort_Re_t_SET)
    588                { 
    589                  SYS_STAT_Last |= 0x02;   //clear the SCD bit by writing "1" 
    590                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    591                  SYS_STAT_Last &= ~0x02;
    592                  DisCurOv_Re_t = 0;
    593                  SYS_STAT.Bit.SCD = 0;
    594                  Bits_flag.Bit.DisCurShort =0;
    595                }
    596                */
    597              }
    598            }
    599            
    600            
    601          }
    602          //==================================================================
    603          //==================================================================
    604          /*      SYS_STAT (0x00)/RESET:0x00
    605                  BIT        7      6           5             4       3   2    1     0
    606                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    607          */
    608          void VoltCheck(void)
    609          {  
    610            if(WorkMode == CHARGE_MODE)
    611            {
    612              if(Cell_Volt_Max >= CHG_OV_VAL_SET ||SYS_STAT.Bit.OV)
    613              { 
    614                if((ChgOv_t >= ChgOv_t_SET) ||SYS_STAT.Bit.OV)
    615                {
    616                  ChgOv_t = ChgOv_t_SET;
    617                  Bits_flag.Bit.ChgOv = 1;
    618                }
    619              }
    620              else
    621              {
    622                ChgOv_t =0;
    623              }
    624              
    625              if(Bits_flag.Bit.ChgOv && Cell_Volt_Max < CHG_OV_RE_VAL_SET)// Cell_Volt_Avg < CHG_OV_RE_VAL_SET &&
    626              {
    627                //clear the OV bit by writing "1"
    628                if(SYS_STAT.Bit.OV)
    629                {
    630                  SYS_STAT_Last |= 0x04;
    631                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    632                  SYS_STAT_Last &= ~0x04;
    633                }
    634                ChgOv_t = 0;
    635                SYS_STAT.Bit.OV = 0;
    636                Bits_flag.Bit.ChgOv = 0;
    637              }
    638                
    639            }
    640            else if(WorkMode == DISCHARGE_MODE)
    641            {
    642              //=========开机整体电芯电压
    643              if(Dis_First_Run_Flag ==0 && WorkMode == DISCHARGE_MODE)
    644              { 
    645                if((Cell_Volt_Avg < 3300) || (Cell_Volt_Min < 3300) || SYS_STAT.Bit.UV)
    646                {
    647                  if(Dis_First_Run_t >= 50)
    648                  {
    649                    Dis_First_Run_t = 50;
    650                    Bits_flag.Bit.DisOv = 1;
    651                    Dis_First_Run_Flag  = 1;
    652                  }
    653                }
    654                else 
    655                {
    656                  if(Dis_First_Run_t >= 30)
    657                  {
    658                    Dis_First_Run_t = 30; 
    659                    Bits_flag.Bit.DisOv = 0;
    660                    Dis_First_Run_Flag  = 1;
    661                    DisOv_t = 0;
    662                    //clear the UV bit by writing "1"
    663                    if(SYS_STAT.Bit.UV)
    664                    {
    665                      SYS_STAT_Last |= 0x08;
    666                      I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    667                      SYS_STAT_Last &= ~0x08;
    668                    }
    669                  }
    670                } 
    671              } 
    672          
    673              //==== 放电欠压检测
    674              if((Cell_Volt_Avg < DIS_UV_VAL_SET) ||(Cell_Volt_Min < DIS_UV_MIN_VAL_SET) || SYS_STAT.Bit.UV)// 
    675              {
    676                if((DisOv_t >= DisOv_t_SET) || SYS_STAT.Bit.UV)
    677                {
    678                  DisOv_t = DisOv_t_SET;
    679                  Bits_flag.Bit.DisOv = 1;
    680                }
    681              }
    682              else
    683              {
    684                DisOv_t = 0;
    685              }
    686              /*
    687              if(Bits_flag.Bit.DisOv && Cell_Volt_Min >= DIS_UV_RE_VAL_SET)//Cell_Volt_Avg >= DIS_UV_RE_VAL_SET && 
    688              {
    689                //clear the UV bit by writing "1"
    690                if(SYS_STAT.Bit.UV)
    691                {
    692                  SYS_STAT_Last |= 0x08;
    693                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    694                  SYS_STAT_Last &= ~0x08;
    695                }
    696                DisOv_t = 0;
    697                SYS_STAT.Bit.UV = 0;
    698                Bits_flag.Bit.DisOv = 0;
    699              }
    700              */
    701            }
    702          }  
    703          /*
    704          //==========================================================================
    705          void ModeCheck_Backup(void)
    706          {       
    707            //工作模式的检测是依据外部Triger端的电压大小来判定
    708            Check_Val = ADConverse(3); 
    709            if((Check_Val >= 130 && Check_Val < 160) || CC_Val >= 10)
    710            {  
    711              if(ChgExchangeMode_Cnt >= 30)
    712              { 
    713                ChgExchangeMode_Cnt  = 100;
    714                DisExchangeMode_Cnt  = 0;
    715                IdleExchangeMode_Cnt = 0;
    716                WorkMode = CHARGE_MODE;
    717              }
    718            }   
    719            else if((Check_Val >= 220 && Check_Val < 630) || SYS_CTRL1.Bit.LOAD_PRESENT || CC_Val < (-10) )
    720            {  
    721              if(DisExchangeMode_Cnt >= 30)
    722              { 
    723                IdleExchangeMode_Cnt = 0;
    724                ChgExchangeMode_Cnt = 0;
    725                DisExchangeMode_Cnt = 100; 
    726                WorkMode = DISCHARGE_MODE;
    727              }
    728            } 
    729            else if(Check_Val < 10)
    730            { 
    731              if(IdleExchangeMode_Cnt >= 100)
    732              { 
    733                IdleExchangeMode_Cnt = 100;
    734                ChgExchangeMode_Cnt = 0;
    735                DisExchangeMode_Cnt = 0;
    736                WorkMode = IDLE_MODE;
    737              }
    738            } 
    739          }
    740          */
    741          //==========================================================================
    742          void ModeCheck(void)
    743          {       
    744            static uint8_t ModeChange_Lock = 0;
    745            uint32_t OV_tmp = 1;
    746            uint32_t UV_tmp = 1;
    747            uint8_t Trip_tmp = 1;
    748            uint16_t Check_Val_tmp = 0;
    749            //工作模式的检测是依据外部Triger端的电压大小来判定 
    750            // 问题3：（充放电及空载识别问题）欠压状态下，插上充电器时，识别不了充电器;  
    751                    //解决方案：检测无Triger信号时，为空载模式;
    752                                //Triger信号范围在[220,630]时【[350,580]】，或检测到有负载信号、或放电电流 >= 10mA 时，为放电模式，否则为充电模式.
    753            
    754          //========================================================================== 
    755            
    756            //OV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (OV_val - ADCOffset_Val)/ADCGain_Val) >> 4);  
    757            //UV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (UV_val - ADCOffset_Val)/ADCGain_Val) >> 4); 
    758            Check_Val = ADConverse(3); // 充电时Check_Val_MAX == 150
    759             
    760            if(Check_Val < 10)// 无信号
    761            { 
    762              if(IdleExchangeMode_Cnt >= 30)
    763              { 
    764                IdleExchangeMode_Cnt = 30;
    765                ChgExchangeMode_Cnt = 0;
    766                DisExchangeMode_Cnt = 0;
    767                WorkMode = IDLE_MODE;
    768                if(0 != ModeChange_Lock)
    769                { 
    770                  I2C_Read(OV_TRIP_ADDR,&Trip_tmp); 
    771                  OV_tmp = ADCOffset_Val + (((uint32_t)OV_TRIP_Last << 4) * ADCGain_Val)/1000;
    772                    
    773                  I2C_Read(UV_TRIP_ADDR,&Trip_tmp); 
    774                  UV_tmp = ADCOffset_Val + (((uint32_t)UV_TRIP_Last << 4) * ADCGain_Val)/1000;
    775                    
    776                  if((OV_THREHOLD_VAL_SET != OV_tmp) || (UV_THREHOLD_VAL_SET != UV_tmp ))
    777                  {
    778                    Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, UV_THREHOLD_VAL_SET); 
    779                  }
    780                  else
    781                  {
    782                    ModeChange_Lock = 0;
    783                  } 
    784                }
    785              }
    786            } 
    787            else
    788            {
    789              // dsg: Cell_Volt_Total == 31070   Check_Val == [385,394]   Check_Val_tmp == [31018,31743]  Max_Delta == 673
    790              // chg: Cell_Volt_Total == 31050   Check_Val == [204,208]   Check_Val_tmp == [16435,16757]  Max_Delta == [14615,14293]
    791              Check_Val_tmp = (uint16_t)((uint32_t)Check_Val *3300 * 25 /1024);//+-1000mV
    792              if( ((Check_Val_tmp < Cell_Volt_Tol) && (Cell_Volt_Tol - Check_Val_tmp <= 2000)) || ((Check_Val_tmp > Cell_Volt_Tol) && (Check_Val_tmp - Cell_Volt_Tol <= 2000)) || SYS_CTRL1.Bit.LOAD_PRESENT) 
    793              //else if((Check_Val >= 186 && Check_Val < 630) || SYS_CTRL1.Bit.LOAD_PRESENT)// || CC_Val < (-10) )
    794              {  
    795                if(DisExchangeMode_Cnt >= 30)
    796                { 
    797                  IdleExchangeMode_Cnt = 0;
    798                  ChgExchangeMode_Cnt = 0;
    799                  DisExchangeMode_Cnt = 100; 
    800                  WorkMode = DISCHARGE_MODE;
    801                  if(2 != ModeChange_Lock)
    802                  {
    803                    //ModeChange_Lock = 2; 
    804                    //Afe_OV_UV_Threshold_Set(4300, UV_THREHOLD_VAL_SET); // 问题1：放电状态下，电芯电压处于过充时，BQ会自动关闭充电MOS管;   解决方案：放电状态下，重新设置硬件过充电压为4.3V
    805                    I2C_Read(OV_TRIP_ADDR,&Trip_tmp); 
    806                    OV_tmp = ADCOffset_Val + (((uint32_t)OV_TRIP_Last << 4) * ADCGain_Val)/1000;
    807                      
    808                    I2C_Read(UV_TRIP_ADDR,&Trip_tmp); 
    809                    UV_tmp = ADCOffset_Val + (((uint32_t)UV_TRIP_Last << 4) * ADCGain_Val)/1000;
    810                      
    811                     //if((4250 >= OV_tmp) || (2950 >= UV_tmp ))//3000
    812                    if((4300 != OV_tmp) || (UV_THREHOLD_VAL_SET != UV_tmp ))
    813                    {
    814                      Afe_OV_UV_Threshold_Set(4300, UV_THREHOLD_VAL_SET); 
    815                    }
    816                    else
    817                    {
    818                      ModeChange_Lock = 2;
    819                    }
    820                  }
    821                }
    822              }  
    823              else// if((Check_Val >= 130 && Check_Val < 160) || CC_Val >= 10)
    824              {  
    825                if(ChgExchangeMode_Cnt >= 30)
    826                { 
    827                  ChgExchangeMode_Cnt  = 100;
    828                  DisExchangeMode_Cnt  = 0;
    829                  IdleExchangeMode_Cnt = 0;
    830                  WorkMode = CHARGE_MODE;
    831                  if(1 != ModeChange_Lock)
    832                  {
    833                    //ModeChange_Lock = 1; 
    834                    //Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, 0);// 问题2：充电状态下，电芯电压处于过放时，BQ会自动关闭放电MOS管;   解决方案：充电状态下，重新设置硬件过充电压为1.5V
    835                    I2C_Read(OV_TRIP_ADDR,&Trip_tmp); 
    836                    OV_tmp = ADCOffset_Val + (((uint32_t)OV_TRIP_Last << 4) * ADCGain_Val)/1000;
    837                      
    838                    I2C_Read(UV_TRIP_ADDR,&Trip_tmp); 
    839                    UV_tmp = ADCOffset_Val + (((uint32_t)UV_TRIP_Last << 4) * ADCGain_Val)/1000;
    840                      
    841                    //if((4200 < OV_tmp) || (50 >= UV_tmp ))
    842                    if((OV_THREHOLD_VAL_SET != OV_tmp) || (0 != UV_tmp ))
    843                    {
    844                      Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, 0); 
    845                    }
    846                    else
    847                    {
    848                      ModeChange_Lock = 1;
    849                    }
    850                  }
    851                }
    852              }  
    853            }
    854          } 
    855          //===========================================
    856          void ClearStatus(void)
    857          {
    858            if(WorkMode == CHARGE_MODE)
    859            {  
    860                DisTemp_Lock_Cnt = 0;
    861                LowPower_MCU_Entry_Flag = 0;
    862                Dis_First_Run_Flag = 0;
    863                Dis_First_Run_t = 0;
    864                DisOv_t = 0;  
    865                //DisCurOv_t = 0;  
    866                //DisCurOv_Re_t = 0; 
    867                PowerOff_Delay_t = 0;
    868                 
    869                //Temp_Protect_Delay_t = 0;
    870                Bits_flag.Bit.DisTemp = 0;
    871                //Bits_flag.Bit.DisCurShort = 0; 
    872                
    873                if(Bits_flag.Bit.DisOv || SYS_STAT.Bit.UV)
    874                { 
    875                  if(SYS_STAT.Bit.UV)  //clear the UV bit by writing "1"
    876                  {
    877                    SYS_STAT_Last |= 0x08;
    878                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    879                    SYS_STAT_Last &= ~0x08;
    880                  }  
    881                  Bits_flag.Bit.DisOv = 0;
    882                }
    883               /* if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD) 
    884                { 
    885                  if(SYS_STAT.Bit.OCD)  //clear the OV bit by writing "1"
    886                  {
    887                    SYS_STAT_Last |= 0x01;
    888                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    889                    SYS_STAT_Last &= ~0x01;
    890                  }
    891                  Bits_flag.Bit.DisCurOv = 0;
    892                } */
    893            }/*
    894            else if(WorkMode == DISCHARGE_MODE)
    895            {
    896                ChgOv_t = 0; 
    897                ChgCurOv_t = 0; 
    898                ChgCurOv_Re_t = 0; 
    899                 
    900                Bits_flag.Bit.ChgCurOv = 0;
    901                Bits_flag.Bit.ChgTemp = 0;
    902                if(Bits_flag.Bit.ChgOv || SYS_STAT.Bit.OV)
    903                { 
    904                  if(SYS_STAT.Bit.OV)  //clear the UV bit by writing "1"
    905                  {
    906                    SYS_STAT_Last |= 0x04;
    907                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    908                    SYS_STAT_Last &= ~0x04;
    909                  }  
    910                  Bits_flag.Bit.ChgOv = 0;
    911                }
    912            }*/
    913            else if(WorkMode == IDLE_MODE)
    914            {   
    915              DisTemp_Lock_Cnt = 0;
    916              //Bits_flag.Bit.AfeErr = 0;
    917              Dis_First_Run_Flag = 0;
    918              Dis_First_Run_t = 0;
    919              //if(Bits_flag.Bit.ChgCurOv)// && ChgCurOv_Re_t >= ChgCurOv_Re_t_SET)
    920              {
    921                ChgCurOv_t = 0; 
    922                DisCurOv_t1 = 0;
    923                DisCurOv_t2 = 0;
    924                ChgCurOv_Re_t = 0;
    925                Bits_flag.Bit.ChgCurOv = 0;
    926              } 
    927              //=========================================================
    928              DisCurShort_Re_t = 0;
    929              if(Bits_flag.Bit.DisCurShort  || SYS_STAT.Bit.SCD) 
    930              { 
    931                SYS_STAT_Last |= 0x02;
    932                I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); //clear the SCD bit by writing "1" 
    933                SYS_STAT_Last &= ~0x02;
    934                Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);
    935                DisCurOv_Re_t = 0;
    936                SYS_STAT.Bit.SCD = 0;
    937                Bits_flag.Bit.DisCurShort = 0;
    938              }
    939              //=========================================================
    940              if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD) 
    941              { 
    942                if(SYS_STAT.Bit.OCD)  //clear the OV bit by writing "1"
    943                {
    944                  SYS_STAT_Last |= 0x01;
    945                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    946                  SYS_STAT_Last &= ~0x01;
    947                  Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);
    948                }
    949                Bits_flag.Bit.DisCurOv = 0;
    950              } 
    951              //=========================================================
    952              DisCurOv_t = 0;
    953              DisCurOv_Re_t = 0;
    954              Bits_flag.Bit.ChgOv = 0;
    955              Bits_flag.Bit.ChgCurOv = 0;
    956              Bits_flag.Bit.ChgTemp = 0;
    957              
    958              
    959                Bits_flag.Bit.DisTemp = 0;
    960                DisTemp_cnt = 0;
    961               
    962            }
    963            else
    964            { 
    965              LowPower_MCU_Entry_Flag = 0; 
    966            }
    967          }  
    968          //==========================================================================
    969            /*The ADC transfer function is a linear equation defined as follows:
    970              V(cell) = GAIN x ADC(cell) + OFFSET
    971              If the DEVICE_XREADY is set, the voltage register values from the device should not be used. If
    972            */ 
    973          void Afe_Volt_Val_Get(void)
    974          { 
    975            uint8_t i = 0;
    976            uint16_t volt_sum = 0;
    977            uint16_t volt_max = 0;
    978            uint16_t volt_min = 0xFFFF;
    979            //====================================250mS
    980            if(Cell_Volt_Sample_Cnt >= 26)
    981            {
    982              Cell_Volt_Sample_Cnt = 0;
    983              for(i =0;i< 20;i += 2)
    984              {  
    985                Adc_value[i/2] = Afe_Get_Adc((VC1_HI_ADDR + i)) & 0x3FFF; //VC1_HI_ADDR =0x0C
    986                Cell_Volt[i/2] = (uint16_t)((uint32_t)ADCGain_Val *Adc_value[i/2]/1000) + ADCOffset_Val;
    987                volt_sum += Cell_Volt[i/2];
    988                if(Cell_Volt[i/2] < volt_min)
    989                {
    990                   volt_min = Cell_Volt[i/2];
    991                }
    992                if(Cell_Volt[i/2] > volt_max)
    993                {
    994                   volt_max = Cell_Volt[i/2];
    995                }
    996              } 
    997              Cell_Volt_Tol = volt_sum; 
    998              Cell_Volt_Avg = Cell_Volt_Tol/10; 
    999              Cell_Volt_Max = volt_max; 
   1000              Cell_Volt_Min = volt_min; 
   1001                
   1002            }
   1003            //====================================250mS
   1004            /*  Once converted to digital form, each cell voltage is added up and the summation result stored in the BAT
   1005                registers. This 16-bit value has a nominal LSB of 1.532 mV. */
   1006            //Pack_Volt = (uint16_t)((uint32_t)4 *ADCGain_Val *Afe_Get_Adc(BAT_HI_ADDR)/1000+(10 *ADCOffset_Val));
   1007            //Pack_Volt = (uint16_t)((uint32_t)1532 *Afe_Get_Adc(BAT_HI_ADDR)/1000);
   1008            
   1009            //====================================250mS
   1010            //Positive values are charge current; negative values are discharge current.
   1011            //an average over the 250-ms integration period.
   1012            /*Why does the CC value read not change when I set the CC_ONESHOT bit?
   1013                  The CC_READY bit must be cleared before the CC_ONESHOT bit is set. Note also that the CC_EN bit
   1014                  should be cleared or a CC conversion may already be in progress.
   1015              The full scale range of the CC is ± 270 mV, with a max recommended input range of ± 200 mV, thus yielding an LSB of approximately 8.44 μV.
   1016              The following equation shows how to convert the 16-bit CC reading into an analog voltage if no boardlevel calibration is performed:
   1017              CC Reading (in μV) = [16-bit 2’s Complement Value] × (8.44 μV/LSB) 
   1018            */
   1019            if((CC_Volt_Sample_Cnt >= 26) && SYS_STAT.Bit.CC_READY) //(0)//
   1020            {
   1021              CC_Volt_Sample_Cnt = 0;
   1022              SYS_STAT.Bit.CC_READY = 0;
   1023              CC_AD = Afe_Get_Adc(CC_HI_ADDR);  
   1024              //CC_Val = (int32_t)820 * CC_AD /100; //mA (int32_t)
   1025              CC_Val = (int32_t)820 * CC_AD /500; //mA (int32_t)
   1026               
   1027              Afe_CC_1Shot_Set();
   1028              if(CC_Val < -320000)
   1029              {
   1030                CC_Val = -320000;
   1031              }
   1032              else if(CC_Val > 320000)
   1033              {
   1034                CC_Val = 320000;
   1035              }
   1036              Current_Val = CC_Val;
   1037              if(CC_Val < 0)
   1038              {
   1039                Current_Val = -CC_Val;
   1040              }
   1041            }
   1042            //====================================2S 
   1043            if(Temp_Volt_Sample_Cnt >= 210)
   1044            {
   1045              //V_TS2_Val = (uint16_t)((uint32_t)(382 * ((uint16_t)adcval <<8 | tmpval))/1000);//mV
   1046              V_TS2_Val = Afe_Get_Adc(TS2_HI_ADDR) &0x3FFF ;
   1047              V_TS2_Val = (uint16_t)(((uint32_t)382 * V_TS2_Val /1000));  //mV
   1048              V_TS2_Val = (uint16_t)(((uint32_t)4096 * V_TS2_Val /3300));  //mV
   1049              //R_TS2_Val = (uint16_t)((uint32_t)10000 * V_TS2_Val)/(3300 - V_TS2_Val); 
   1050            }
   1051            //=====================================================================================
   1052            
   1053          }
   1054           
   1055          void OpenDetect_Cntrl(void)
   1056          {
   1057            static uint8_t Opendetect_cnt = 0;
   1058            if(Cell_Volt_Max >= 4250)
   1059            {
   1060              if((Opendetect_cnt++) >= 10)
   1061              {
   1062                Opendetect_cnt = 10;
   1063                //Bits_flag.Bit.OpenDetect = 1;
   1064              }
   1065            }
   1066            else
   1067            {
   1068              Opendetect_cnt = 0;
   1069            } 
   1070          }
   1071          //==========================================================================
   1072          /*
   1073            turn on condition  :    >4.0V && deltaVolt >200mV
   1074            turn off condition :   over charge assert the charging protection
   1075          */ 
   1076          void CellBal_Cntrl(void)
   1077          {
   1078            uint8_t i = 0;
   1079            if(WorkMode == CHARGE_MODE)
   1080            {
   1081              if(Cell_Balance_Delay_t >= 100)
   1082              {
   1083                Cell_Balance_Delay_t = 0;
   1084                if((Cell_Volt_Max >= CELLBALANCE_BEGIN_VAL) && ((Cell_Volt_Max - Cell_Volt_Min) >= CELLBALANCE_DELTA_VAL) && !Bits_flag.Bit.ChgOv && !Bits_flag.Bit.ChgTemp && !Bits_flag.Bit.ChgCurOv && !Bits_flag.Bit.AfeErr)
   1085                {
   1086                  CellBal_Cntrl_Lock = 1;
   1087                  for(i =0; i <10; i++)
   1088                  {
   1089                    if(Cell_Volt[i] > CELLBALANCE_BEGIN_VAL && ((Cell_Volt[i] - Cell_Volt_Min) >= CELLBALANCE_DELTA_VAL))
   1090                    {   
   1091                      CellBalance_Cur_Selct |= (0x0001 << i); 
   1092                    }
   1093                    else
   1094                    {
   1095                      CellBalance_Cur_Selct &= ~(0x0001 << i);
   1096                    }
   1097                  }  
   1098                  CellBalance_Selct = 0x0000;
   1099                  //===================================
   1100                  for(i =0; i <10; i++ )
   1101                  {
   1102                    if((CellBalance_Cur_Selct &(0x0001 <<i)))
   1103                    {
   1104                      CellBalance_Selct |=(0x0001 <<i);
   1105                      if(4 != i)
   1106                      {
   1107                        i +=1; 
   1108                      }
   1109                    }  
   1110                  } 
   1111                  Afe_CellBalance_Enable(CellBalance_Selct);
   1112                } 
   1113                else if(CellBal_Cntrl_Lock ==1)
   1114                { 
   1115                  Afe_CellBalance_Disable();
   1116                } 
   1117              }
   1118            }
   1119            else if(CellBal_Cntrl_Lock ==1)
   1120            {
   1121                Afe_CellBalance_Disable();
   1122            }
   1123          }
   1124           
   1125          //==========================================================================
   1126          /*
   1127          1、充电模式：有异常时，电流异常（LED1及LED2闪烁，周期为1秒），温度异常（LED1、LED2及LED3闪烁，周期为1秒）
   1128                       无异常时，低节电量LED常亮，高节电量的LED闪烁，T = 1s
   1129                          0%----50%     LED1闪烁
   1130                          50%---70%     LED1常亮、LED2闪烁
   1131                          70%---99%     LED1、LED2常亮、LED3闪烁
   1132                          过充          LED全亮
   1133                       
   1134          2、放电模式：有异常时，电流异常（LED1及LED2闪烁，周期为1秒），温度异常（LED1、LED2及LED3闪烁，周期为1秒）
   1135                       无异常时，显示当前电量
   1136                          10%           LED1闪烁 0.5Hz
   1137                          10%---30%     LED1常亮
   1138                          30%---50%     LED1、LED2常亮
   1139                          50%           LED全亮
   1140          */  
   1141          void LedShow_Cntrl(void)
   1142          {
   1143            static uint8_t FlowLedCnt = 0;
   1144            static uint8_t FlowLedCnt_Lock = 0;
   1145            static uint8_t FlowLed_Finish_Flag = 0;
   1146            // soc 显示
   1147            // 异常后，报警5s后，熄灭
   1148            if(WorkMode == IDLE_MODE)// ==流水显示方式
   1149            {  
   1150              FlowLedCnt = 0;
   1151              FlowLed_Finish_Flag = 0;
   1152              FlowLedCnt_Lock = 0;
   1153              /*
   1154              if(LedFlash_Off_t < 50)
   1155              {
   1156                LED1_OFF();
   1157                LED2_OFF();
   1158                LED3_ON();  
   1159              }  
   1160              else if(LedFlash_Off_t < 100)
   1161              {
   1162                LED1_OFF();
   1163                LED2_ON();
   1164                LED3_OFF();  
   1165              }  
   1166              else if(LedFlash_Off_t < 150)
   1167              {
   1168                LED1_ON();
   1169                LED2_OFF();
   1170                LED3_OFF();  
   1171              }  
   1172              else  
   1173              {
   1174                LED1_OFF();
   1175                LED2_OFF();
   1176                LED3_OFF();  
   1177              }   
   1178              */
   1179                LED1_OFF();
   1180                LED2_OFF();
   1181                LED3_OFF();  
   1182            }
   1183            else
   1184            { 
   1185              LedFlash_Off_t = 0;
   1186              if(Bits_flag.Bit.AfeErr)
   1187              { 
   1188                if(LedFlash_t < 50)
   1189                {
   1190                  LED1_ON();
   1191                  LED2_OFF();
   1192                  LED3_OFF();    
   1193                } 
   1194                else if(LedFlash_t < 100)
   1195                {
   1196                  LED1_OFF();
   1197                  LED2_ON();
   1198                  LED3_OFF();   
   1199                } 
   1200                else if(LedFlash_t < 150)
   1201                {
   1202                  LED1_OFF();
   1203                  LED2_OFF();
   1204                  LED3_ON();   
   1205                } 
   1206                else if(LedFlash_t < 200)
   1207                {
   1208                  LED1_OFF();
   1209                  LED2_OFF();
   1210                  LED3_OFF();  
   1211                } 
   1212                else
   1213                {
   1214                  LedFlash_t = 0; 
   1215                }
   1216              }
   1217              else if(WorkMode == CHARGE_MODE)
   1218              { 
   1219                if(FlowLed_Finish_Flag ==0 )
   1220                {
   1221                  if(FlowLedCnt ==0)
   1222                  { 
   1223                    if(FlowLedCnt_Lock ==0)
   1224                    {
   1225                      LedFlash_t = 0;
   1226                      FlowLedCnt_Lock = 1;
   1227                    }
   1228                    LED1_ON();
   1229                    LED2_OFF();
   1230                    LED3_OFF(); 
   1231                    if(LedFlash_t >= 50)
   1232                    {
   1233                      LedFlash_t = 0;
   1234                      FlowLedCnt = 1;
   1235                      FlowLedCnt_Lock = 0;
   1236                    }  
   1237                  }
   1238                  else if(FlowLedCnt ==1)
   1239                  {
   1240                    LED1_OFF();
   1241                    LED2_ON();
   1242                    LED3_OFF(); 
   1243                    if(LedFlash_t >= 50)
   1244                    {
   1245                      LedFlash_t = 0;
   1246                      FlowLedCnt = 2;
   1247                    }  
   1248                  }
   1249                  else if(FlowLedCnt ==2)
   1250                  {
   1251                    LED1_OFF();
   1252                    LED2_OFF();
   1253                    LED3_ON(); 
   1254                    if(LedFlash_t >= 50)
   1255                    {
   1256                      LedFlash_t = 0;
   1257                      FlowLedCnt = 0;
   1258                      FlowLed_Finish_Flag = 1;
   1259                    }  
   1260                  }
   1261                }
   1262                else if(Bits_flag.Bit.ChgOv || (Cell_Volt_Max >= 4100 && Cell_Volt_Avg >= 4100)) 
   1263                {
   1264                  LED1_OFF();
   1265                  LED2_OFF(); 
   1266                  LED3_ON(); 
   1267                } 
   1268                else if(SocCalc.soc_rt >= 70)  // 65%---90%     LED1、LED2常亮、LED3闪烁  
   1269                {
   1270                  LED1_OFF();
   1271                  if(LedFlash_t < 50)
   1272                  {
   1273                    LED2_ON();
   1274                    LED3_OFF(); 
   1275                  } 
   1276                  else if(LedFlash_t < 100)
   1277                  {
   1278                    LED2_OFF();
   1279                    LED3_ON();
   1280                  }
   1281                  else
   1282                  {
   1283                    LedFlash_t = 0;
   1284                  } 
   1285                }
   1286                else if(SocCalc.soc_rt >= 50 )//30%---65%     LED1常亮、LED2闪烁
   1287                {
   1288                  if(LedFlash_t < 50)
   1289                  {
   1290                    LED1_ON();
   1291                    LED2_OFF(); 
   1292                  } 
   1293                  else if(LedFlash_t < 100)
   1294                  {
   1295                    LED1_OFF();
   1296                    LED2_ON();
   1297                  }
   1298                  else
   1299                  {
   1300                    LedFlash_t = 0;
   1301                  } 
   1302                  LED3_OFF();
   1303                }
   1304                else //0%----30%     LED1闪烁
   1305                { 
   1306                  if(LedFlash_t >= 50)
   1307                  {
   1308                    LedFlash_t = 0;
   1309                    LED1_XOR();
   1310                  } 
   1311                  LED2_OFF();
   1312                  LED3_OFF();
   1313                } 
   1314              } 
   1315              else if(WorkMode == DISCHARGE_MODE)
   1316              {  
   1317                FlowLedCnt_Lock = 0;
   1318                FlowLed_Finish_Flag = 0;
   1319                if(Bits_flag.Bit.DisOv)
   1320                {
   1321                  LED1_OFF();
   1322                  LED2_OFF(); 
   1323                  LED3_OFF(); 
   1324                }
   1325                else if(SocCalc.soc_rt >= 50)  //50%           LED全亮
   1326                {
   1327                  LED1_OFF();  LED2_OFF(); LED3_ON();
   1328                  //LED3_OFF();  LED2_OFF(); LED1_ON();
   1329                }
   1330                else if(SocCalc.soc_rt >= 30) //30%---50%     LED1、LED2常亮
   1331                {
   1332                  LED1_OFF();
   1333                  LED2_ON();
   1334                  LED3_OFF();
   1335                }
   1336                else if(SocCalc.soc_rt >= 10) //10%---30%     LED1常亮
   1337                {
   1338                  LED1_ON();
   1339                  LED2_OFF();
   1340                  LED3_OFF();
   1341                }
   1342                else                             //10%           LED1闪烁 1Hz
   1343                {
   1344                  if(LedFlash_t >= 100)
   1345                  {
   1346                    LedFlash_t = 0;
   1347                    LED1_XOR();
   1348                  }
   1349                  LED2_OFF();
   1350                  LED3_OFF();
   1351                } 
   1352              }
   1353            }
   1354          }
   1355          /*
   1356          void LedShow_WorkMode(void)
   1357          {
   1358            if(WorkMode == IDLE_MODE)
   1359            {
   1360              //LED1_XOR();
   1361              LED1_ON();
   1362              LED2_OFF(); 
   1363              LED3_OFF(); 
   1364            }
   1365            else if(WorkMode == CHARGE_MODE)
   1366            {
   1367              LED1_OFF();
   1368              //LED2_XOR(); 
   1369              LED2_ON(); 
   1370              LED3_OFF(); 
   1371            }
   1372            else if(WorkMode == DISCHARGE_MODE)
   1373            {
   1374              LED1_OFF();
   1375              LED2_OFF(); 
   1376              LED3_ON(); 
   1377              //LED3_XOR(); 
   1378            }
   1379          }
   1380          */
   1381          //==========================================================================
   1382          void LowPower_Entry_MCU_Set(void)
   1383          {   
   1384            static uint8_t LowPower_Entry_Exit_Cnt = 0;
   1385            if(WorkMode == IDLE_MODE && (LowPower_Entry_Delay_t >= 500 || LowPower_MCU_Entry_Flag == 1))
   1386            { 
   1387              //if(LowPower_MCU_Entry_Flag == 0)
   1388              {
   1389                 Afe_ADC_Disable(); Afe_Temp_Disable();  
   1390              }
   1391              CLK_PCKENR2 = CLK_PCKENR2_AWU;
   1392              AWU_Init(AWU_TIMEBASE_1S); 
   1393              CLK->ICKR |= CLK_ICKR_SWUAH;
   1394              FLASH->CR1 |= 0x04;	  
   1395              EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
   1396              ClrWdt();  
   1397              LowPower_MCU_Entry_Flag = 1; 
   1398              halt(); 
   1399              ClrWdt();  
   1400              Delay_ms(5); 
   1401              //======================================
   1402              if(LowPower_MCU_Entry_Flag == 1)
   1403              {
   1404                if((LowPower_Entry_Exit_Cnt ++) >= 100) 
   1405                {
   1406                  LowPower_MCU_Entry_Flag = 0; 
   1407                  LowPower_Entry_Exit_Cnt = 0; 
   1408                }
   1409              }
   1410              else
   1411              {
   1412                LowPower_Entry_Exit_Cnt = 0; 
   1413                CLK_PCKENR2 &= ~CLK_PCKENR2_AWU; 
   1414                CLK->ICKR &= ~CLK_ICKR_SWUAH; 
   1415                Afe_ADC_Enable(); Afe_Temp_Enable();Delay_ms(10); 
   1416              } 
   1417              //=============================================
   1418              LowPower_Entry_Delay_t = 0; 
   1419            }
   1420          } 
   1421          //========================================================================== 
   1422          void LowPower_Powerdown_Enter(void)
   1423          {
   1424            uint8_t i = 0;
   1425            //if(AfeErr_t >= 2000 || (LedFlash_Off_t >= 250) || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Temp_Protect_Delay_t >= 1000)))//PowerOff_Delay_t >= PowerOff_Delay_t_SET && 
   1426            if(AfeErr_t >= 500 || (LedFlash_Off_t >= 10) || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.DisCurShort)) || (Bits_flag.Bit.ChgTemp && Temp_Protect_Delay_t >= 180000))
   1427            {
   1428              Afe_Temp_Disable();
   1429              SOC_SavedtoEEPROM();
   1430              Delay_ms(10);
   1431              while(1)
   1432              {   
   1433                Afe_EnterShipMode(); 
   1434                if((i ++) < 100)
   1435                { 
   1436                  ClrWdt();
   1437                  Delay_ms(50);
   1438                }
   1439                else
   1440                {
   1441                  Delay_ms(1000);
   1442                }
   1443              } 
   1444            }  
   1445          }
   1446          //==============================================================================
   1447          void LowPower_Cntrl(void)
   1448          {  
   1449            //if(WorkMode == IDLE_MODE || AfeErr_t >= 2000 || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Temp_Protect_Delay_t >= 1000)))
   1450            if(WorkMode == IDLE_MODE || AfeErr_t >= 500 || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurShort)) || (Bits_flag.Bit.ChgTemp && Temp_Protect_Delay_t >= 180000))
   1451            {
   1452              Afe_Temp_Disable();
   1453              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1454              {
   1455                LowPower_Powerdown_Enter();  
   1456              } 
   1457            }
   1458            else
   1459            {
   1460              PowerOff_Delay_t = 0;
   1461            }
   1462          }
   1463          //==============================================================================
   1464          void LowPower_Cntrl_1(void)
   1465          { 
   1466            if(LowPower_MCU_Entry_Flag ==0)//(0)//
   1467            {
   1468              if(!SYS_CTRL1.Bit.ADC_EN) 
   1469              { 
   1470                Afe_ADC_Enable(); 
   1471              }
   1472              if(!SYS_CTRL1.Bit.TEMP_SEL )
   1473              {
   1474                Afe_Temp_Enable();
   1475              }
   1476            }
   1477            if(WorkMode == CHARGE_MODE)
   1478            {
   1479              return;
   1480            }
   1481            if(Bits_flag.Bit.DisOv)  
   1482            {
   1483              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1484              {
   1485                LowPower_Powerdown_Enter();  
   1486              }
   1487            }
   1488            else
   1489            {
   1490              LowPower_Entry_MCU_Set();  
   1491            }
   1492          }
   1493          //==============================================================================
   1494          void LowPower_Cntrl_Backup(void)
   1495          { 
   1496            if(LowPower_MCU_Entry_Flag ==0)//(0)//
   1497            {
   1498              if(!SYS_CTRL1.Bit.ADC_EN) 
   1499              { 
   1500                Afe_ADC_Enable(); 
   1501              }
   1502              if(!SYS_CTRL1.Bit.TEMP_SEL )
   1503              {
   1504                Afe_Temp_Enable();
   1505              }
   1506            }
   1507            if(WorkMode == CHARGE_MODE)
   1508            {
   1509              return;
   1510            }
   1511            if(Bits_flag.Bit.DisOv)  
   1512            {
   1513              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1514              {
   1515                LowPower_Powerdown_Enter();  
   1516              }
   1517            }
   1518            else
   1519            {
   1520              LowPower_Entry_MCU_Set();  
   1521            }
   1522          }
   1523          
   1524          uint8_t CRC8_Caculate(uint8_t *ptr,uint8_t len)
   1525          {
   1526            uint8_t i;
   1527          	
   1528            uint8_t crc = 0;
   1529          
   1530            uint8_t key = 0x07; //_Poly_07
   1531            while((len--) != 0)
   1532          	
   1533            {
   1534          		
   1535              for(i = 0x80; i != 0; i /= 2)
   1536          		
   1537              {
   1538          			
   1539                if((crc & 0x80) != 0)
   1540          			
   1541                {
   1542          				
   1543                  crc *= 2;
   1544          				
   1545                  crc ^= key;
   1546          			
   1547                }
   1548          			
   1549                else
   1550          				
   1551                {
   1552                  crc *= 2;
   1553          
   1554                }
   1555          			
   1556                if((*ptr & i) != 0)
   1557          				
   1558                {
   1559                  crc ^= key;
   1560                }
   1561          		
   1562              }
   1563          		
   1564              ptr++;
   1565          	
   1566            }
   1567            return (crc);
   1568          
   1569          } 
   1570          
   1571          
   1572          //==========================================================================
   1573          /*
   1574          In a single-byte read transaction, the CRC is calculated after the second start and uses the slave address and data byte.
   1575          */
   1576          void I2C_Read(uint8_t addr,uint8_t *data)//slave device address 0x18
   1577          {      
   1578            uint16_t OverTimeDelay = OverTimeDelay_SET;
   1579            uint8_t CRC_ReData,Retry_Cnt = 5; 
   1580            Buf[0] = SLAVE_ADDR; 
   1581            while(Retry_Cnt > 0)
   1582            {
   1583              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图）  
   1584              disableInterrupts(); 
   1585              I2C->CR2 |= 0x04; //ack使能 
   1586              //=============================发送起始位 I2C_Start() 
   1587              while(I2C->SR3 & 0x02){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;I2C_COM_ERROR_Flag = 1;break;}}    // 等待总线空闲   检测i2c-SR3 busy位        
   1588              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位  
   1589              
   1590              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1591              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1592              while(!(I2C->SR1 & 0x01));  //等待START发送完 E5  
   1593              I2C->DR = (SLAVE_ADDR << 1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1594              
   1595              while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;break;}}// I2C_COM_ERROR_Flag = 1; //等特7位器件地址发送完并且收到ack,ADDR置1    
   1596              //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1597              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1598              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1599              I2C->SR3; //然后读SR3 清  ADDR 
   1600              
   1601              if(I2C_COM_ERROR_Flag == 0)
   1602              {
   1603                //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1604                I2C->DR = (u8)(addr);      
   1605                //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1606                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1607                //在发送地址和清除ADDR 之后，I2C接口进入主设备接收模式。以下见stm8s中文数据手册P252（图97主设备接收模式接收序列图）  
   1608                
   1609                //=============================I2C_Start()        
   1610                I2C->CR2 |= 0x01;  //产生重复起始位   
   1611                //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1612                while(!(I2C->SR1 & 0x01));  //等待START发送完     
   1613                //ADDRESS (接收)   
   1614                I2C->DR = (SLAVE_ADDR <<1) + 0x01;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)      
   1615                //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除改位   
   1616                
   1617                while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;break;}} // I2C_COM_ERROR_Flag = 1;//等特7位器件地址发送完并且收到ack,ADDR置1    
   1618                //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1  
   1619                I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1620                I2C->SR3; //然后读SR3 清  ADDR   
   1621                   Buf[0] = 0x31;  Buf[1] = 0;     Buf[2] = 0;           
   1622                //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1623                while(!(I2C->SR1 & 0x40));                                        
   1624                Buf[1] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)                                               
   1625                 
   1626               
   1627                
   1628                //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1629                while(!(I2C->SR1 & 0x40));                                        
   1630                Buf[2] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)  
   1631                  //EV7_1 ：RxNE=1 ，读DR寄存器清除该标志。设置ACK=0和STOP 请求。(在接收最后一个字节前)     
   1632                I2C->SR3;
   1633                I2C->DR; 
   1634                I2C->CR2 &= ~0x04; //ack使能  
   1635                I2C->CR2 |= 0x02;  //停止位产生stop      
   1636                 
   1637                enableInterrupts(); 
   1638                //while((I2C->CR2 & I2C_CR2_STOP));
   1639                CRC_ReData = CRC8_Caculate(Buf,2);
   1640                /*Uart_SendByte(0x11);
   1641                Uart_SendByte(Buf[0]);
   1642                Uart_SendByte(Buf[1]);
   1643                Uart_SendByte(Buf[2]);*/
   1644                if(CRC_ReData == Buf[2])
   1645                {
   1646                  *data = Buf[1];
   1647                  OverTimeDelay = 200; while((OverTimeDelay --) >0);
   1648                  return;
   1649                }
   1650              }
   1651              I2C_COM_ERROR_Flag = 0;
   1652              Retry_Cnt -= 1;
   1653            }
   1654            enableInterrupts(); 
   1655            //Uart_SendByte(0xDD);
   1656            //Uart_SendByte(0xDD);
   1657          }
   1658          
   1659          //==========================================================================
   1660          /*
   1661          In a single-byte write transaction, the CRC is calculated over the slave address, register address, and data.
   1662          */
   1663          void I2C_Write(uint8_t addr,uint8_t data )
   1664          {     
   1665            uint8_t Write_Retry_Cnt = 5,CRC_data = 0;
   1666            uint16_t OverTimeDelay = OverTimeDelay_SET;
   1667            Buf[0] = SLAVE_ADDR <<1 ;
   1668            Buf[1] = addr;
   1669            Buf[2] = data;
   1670            CRC_data = CRC8_Caculate(Buf,3);//slave_addr + reg_addr + data + CRC
   1671            I2C_COM_ERROR_Flag =0;
   1672            
   1673            while(Write_Retry_Cnt > 0)
   1674            { 
   1675              disableInterrupts();
   1676              I2C_CR2 |= 0x04;
   1677              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1678              //=============================发送起始位 I2C_Start() 
   1679              while(I2C->SR3 & 0x02) {if((OverTimeDelay --) == 0){OverTimeDelay = 500;I2C_COM_ERROR_Flag = 1;break;}}//   // 等待总线空闲   检测i2c-SR3 busy位
   1680              //I2C_CR2 &= ~0x04;        
   1681              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位    
   1682              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1683              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1684              while(!(I2C->SR1 & 0x01));// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}} //等待START发送完 E5  
   1685              
   1686              I2C->DR = (SLAVE_ADDR <<1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1687              
   1688              OverTimeDelay = 100; while((OverTimeDelay --) >0);OverTimeDelay = OverTimeDelay_SET;
   1689              //while(!(I2C->SR1 & 0x02 == 0x02)) {if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;I2C_COM_ERROR_Flag = 0;break;}} // //等特7位器件地址发送完并且收到ack,ADDR置1    
   1690              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1691              I2C->SR1;   
   1692              I2C->SR3; //然后读SR3 清  ADDR 
   1693              if(I2C_COM_ERROR_Flag == 0)
   1694              {
   1695                //I2C_CR2 |= 0x04;
   1696                //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1697                I2C->DR = (u8)(addr);      
   1698                //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1699                while(!(I2C->SR1 & 0x84));//84//0x80  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1700                 
   1701                //============================= 发送数据  
   1702                I2C->DR = data;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)    
   1703                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1704                //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1705                
   1706                //============================= 发送数据  
   1707                I2C->DR = CRC_data;    
   1708                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1709                //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1710                
   1711                I2C->DR;  //清除I2C_SR2的BTF位
   1712                I2C->CR2 |= 0x02;  //停止位产生stop  //*注意： 发送停止位时，必须先清除I2C_SR2的BTF位  
   1713                
   1714                enableInterrupts();
   1715                OverTimeDelay = 200; while((OverTimeDelay --) >0);
   1716                if(I2C_COM_ERROR_Flag == 0)
   1717                {  
   1718                  return;
   1719                }
   1720              }
   1721              I2C_COM_ERROR_Flag = 0;
   1722              Write_Retry_Cnt -= 1; 
   1723            } 
   1724            enableInterrupts();
   1725            //Uart_SendByte(0xCC);
   1726            //Uart_SendByte(0xCC);
   1727          }
   1728           
   1729          void I2C_Read_Backup(uint8_t addr,uint8_t *data)//slave device address 0x18
   1730          {      
   1731            uint16_t OverTimeDelay = 50;
   1732            uint8_t CRC_ReData,Retry_Cnt = 5; 
   1733            Buf[0] = SLAVE_ADDR; 
   1734            while(Retry_Cnt > 0)
   1735            {
   1736              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1737              
   1738              I2C->CR2 |= 0x04; //ack使能 
   1739              //=============================发送起始位 I2C_Start() 
   1740              while(I2C->SR3 & 0x02);//{if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}    // 等待总线空闲   检测i2c-SR3 busy位        
   1741              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位  
   1742              
   1743              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1744              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1745              while(!(I2C->SR1 & 0x01));  //等待START发送完 E5  
   1746              I2C->DR = (SLAVE_ADDR << 1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1747              
   1748              while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1749              //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1750              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1751              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1752              I2C->SR3; //然后读SR3 清  ADDR 
   1753              
   1754              //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1755              I2C->DR = (u8)(addr);      
   1756              //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1757              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1758              //在发送地址和清除ADDR 之后，I2C接口进入主设备接收模式。以下见stm8s中文数据手册P252（图97主设备接收模式接收序列图）  
   1759              
   1760              //=============================I2C_Start()        
   1761              I2C->CR2 |= 0x01;  //产生重复起始位   
   1762              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1763              while(!(I2C->SR1 & 0x01));  //等待START发送完     
   1764              //ADDRESS (接收)   
   1765              I2C->DR = (SLAVE_ADDR <<1) + 0x01;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)      
   1766              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除改位   
   1767              
   1768            while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1769            //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1  
   1770              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1771              I2C->SR3; //然后读SR3 清  ADDR   
   1772                 Buf[0] = 0x31;  Buf[1] = 0;     Buf[2] = 0;           
   1773              //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1774              while(!(I2C->SR1 & 0x40));                                        
   1775              Buf[1] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)                                               
   1776               
   1777             
   1778              
   1779              //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1780              while(!(I2C->SR1 & 0x40));                                        
   1781              Buf[2] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)  
   1782                //EV7_1 ：RxNE=1 ，读DR寄存器清除该标志。设置ACK=0和STOP 请求。(在接收最后一个字节前)     
   1783              I2C->SR3;
   1784              I2C->DR; 
   1785              I2C->CR2 &= ~0x04; //ack使能  
   1786              I2C->CR2 |= 0x02;  //停止位产生stop      
   1787               
   1788              //while((I2C->CR2 & I2C_CR2_STOP));
   1789              CRC_ReData = CRC8_Caculate(Buf,2);
   1790              /*Uart_SendByte(0x11);
   1791              Uart_SendByte(Buf[0]);
   1792              Uart_SendByte(Buf[1]);
   1793              Uart_SendByte(Buf[2]);*/
   1794              if(CRC_ReData == Buf[2])
   1795              {
   1796                *data = Buf[1];
   1797                OverTimeDelay =100; while((OverTimeDelay --) >0);
   1798                return;
   1799              }
   1800              Retry_Cnt -= 1;
   1801            } 
   1802            //Uart_SendByte(0xAA);
   1803          }
   1804          
   1805          void I2C_Write_Backup(uint8_t addr,uint8_t data )
   1806          {     
   1807            uint8_t Write_Retry_Cnt = 5,CRC_data = 0;
   1808            uint16_t OverTimeDelay = 50;
   1809            Buf[0] = SLAVE_ADDR <<1 ;
   1810            Buf[1] = addr;
   1811            Buf[2] = data;
   1812            CRC_data = CRC8_Caculate(Buf,3);//slave_addr + reg_addr + data + CRC
   1813            
   1814            while(Write_Retry_Cnt > 0)
   1815            {
   1816              I2C_CR2 |= 0x04;
   1817              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1818              //=============================发送起始位 I2C_Start() 
   1819              while(I2C->SR3 & 0x02);// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}}   // 等待总线空闲   检测i2c-SR3 busy位
   1820              //I2C_CR2 &= ~0x04;        
   1821              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位    
   1822              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1823              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1824              while(!(I2C->SR1 & 0x01));// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}} //等待START发送完 E5  
   1825              
   1826              I2C->DR = (SLAVE_ADDR <<1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1827              while(!(I2C->SR1 & 0x02 == 0x02)) {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1828              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1829              I2C->SR1;   
   1830              I2C->SR3; //然后读SR3 清  ADDR 
   1831              
   1832              //I2C_CR2 |= 0x04;
   1833              //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1834              I2C->DR = (u8)(addr);      
   1835              //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1836              while(!(I2C->SR1 & 0x84));//84//0x80  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1837               
   1838              //============================= 发送数据  
   1839              I2C->DR = data;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)    
   1840              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1841              //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1842              
   1843              //============================= 发送数据  
   1844              I2C->DR = CRC_data;    
   1845              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1846              //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1847              
   1848              I2C->DR;  //清除I2C_SR2的BTF位
   1849              I2C->CR2 |= 0x02;  //停止位产生stop  //*注意： 发送停止位时，必须先清除I2C_SR2的BTF位  
   1850              
   1851              OverTimeDelay =100; while((OverTimeDelay --) >0);
   1852              if(I2C_COM_ERROR_Flag == 1)
   1853              {
   1854                return;
   1855              }
   1856              I2C_COM_ERROR_Flag = 0;
   1857              Write_Retry_Cnt -= 1;
   1858            }  
   1859          }
   1860          //===========================================================
   1861          void SOC_Init(void)
   1862          {
   1863            uint8_t result = 0;
   1864            uint8_t Soc_Tmp = 0;
   1865            result = FLASH_ReadByte(ADJUST_ADDR);
   1866            
   1867            if(result == 0xAA)//判断校验地址中数据是否为0xAA, Y: EEPROM 中保存有SOC数据;  N: EEPROM 中保存有SOC数据
   1868            {
   1869              FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1870              FLASH_ProgramByte(ADJUST_ADDR,0x00);    // 清除校验地址中数据 
   1871              FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1872              Soc_Tmp = FLASH_ReadByte(SOC_ADDR);     // 读取SOC数据
   1873               
   1874              SocReg.soc = Soc_Tmp; //SocReg.ah = SocCalc.curAh; // 计算SOC。 
   1875              SocCalc.curAh = ((uint32_t)SocReg.rated_cap * Soc_Tmp) / 100;
   1876              SocReg.ah = SocCalc.curAh;
   1877              SocCalc.soc_rt = SocReg.soc;
   1878              Soc_OCV_CorrectEn_Flag = 0;  // 上电禁止SOC的OCV校准  
   1879            }
   1880            else
   1881            {
   1882              Soc_OCV_CorrectEn_Flag = 1;  // 上电允许SOC的OCV校准
   1883            } 
   1884          }
   1885          void SOC_SavedtoEEPROM(void)
   1886          {   
   1887            FLASH_Unlock(FLASH_MEMTYPE_DATA);               // 解锁EEPROM
   1888            FLASH_ProgramByte(SOC_ADDR,SocCalc.soc_rt);     // 保存SOC到EEPROM 
   1889            FLASH_Lock(FLASH_MEMTYPE_DATA);                 // 加锁EEPROM
   1890            if(SocCalc.soc_rt == FLASH_ReadByte(SOC_ADDR))  // 读取数据 ?= 写入数据
   1891            {
   1892              FLASH_Unlock(FLASH_MEMTYPE_DATA);             // 解锁EEPROM
   1893              FLASH_ProgramByte(ADJUST_ADDR,0xAA);          // 写入保存SOC成功标志符
   1894              FLASH_Lock(FLASH_MEMTYPE_DATA);               // 加锁EEPROM
   1895            } 
   1896          }
   1897          //======================================
   1898          void Var_Init(void)
   1899          { 
   1900            uint8_t i = 0;
   1901            ChgTemp_cnt = 0;
   1902            DisTemp_cnt = 0;
   1903            Temp_Protect_Delay_t = 0;
   1904            LowPower_MCU_Entry_Flag = 0; // MCU运行于低功耗状态标识符
   1905            LedFlash_Off_t = 0;
   1906            ChgExchangeMode_Cnt  = 0;
   1907            DisExchangeMode_Cnt  = 0;
   1908            IdleExchangeMode_Cnt = 0;
   1909            for(i =0; i <10; i++)
   1910            {
   1911              Adc_value[i] = 0;
   1912              Cell_Volt[i] = 0;
   1913            }
   1914            Temp_Volt_Sample_Cnt = 0;
   1915            Cell_Volt_Sample_Cnt = 0;
   1916            I2C_COM_ERROR_Flag   = 0;
   1917            Current_Val   = 0;
   1918            ADCOffset_Val = 0;
   1919            CC_Val = 0;
   1920            Cell_Volt_Tol = 0;
   1921            Cell_Volt_Avg = 0;
   1922            Cell_Volt_Max = 0;
   1923            Cell_Volt_Min = 0; 
   1924            ADCGain_Val = 0; 
   1925            Pack_Volt = 0;
   1926            Temp_Val = 0;
   1927            V_TS2_Val = 0; 
   1928            R_TS2_Val = 0; 
   1929            
   1930            SYS_STAT_Last = 0;
   1931            CELLBAL1_Last = 0;
   1932            CELLBAL2_Last = 0;
   1933            SYS_CTRL1_Last = 0;
   1934            SYS_CTRL2_Last = 0; 
   1935            PROTECT1_Last = 0;
   1936            PROTECT2_Last = 0;
   1937            PROTECT3_Last = 0;
   1938            OV_TRIP_Last = 0;
   1939            UV_TRIP_Last = 0;
   1940            CC_CFG_Last = 0;
   1941            
   1942            
   1943            ChgOv_t = 0;
   1944            ChgCurOv_t = 0;
   1945            ChgCurOv_Re_t = 0;  
   1946            DisOv_t = 0;
   1947            DisCurOv_t = 0;
   1948            DisCurOv_t1 = 0;
   1949            DisCurOv_t2 = 0;
   1950            DisCurOv_Re_t = 0;
   1951            DisCurShort_Re_t = 0;
   1952            
   1953            //DEVICE_XREADY_Re_t = 0;
   1954            
   1955            CellBalance_Cur_Selct = 0;  
   1956            LedFlash_t = 0;
   1957            PowerOff_Delay_t = 0;
   1958            Delay_time_t = 0;
   1959             
   1960            
   1961            SYS_STAT.Byte = 0;
   1962            
   1963            RevcComData.uintdata = 0;
   1964            Bits_flag.Byte = 0;
   1965            
   1966            SocCalc.inAh = 0;
   1967            SocCalc.inAh_bak = 0;
   1968            SocCalc.totalInAh = 0;
   1969            SocCalc.totalInAh_bak = 0;
   1970            SocCalc.outAh = 0;
   1971            SocCalc.outAh_bak = 0;
   1972            SocCalc.totalOutAh = 0;
   1973            SocCalc.totalOutAh_bak = 0;
   1974            SocCalc.curAh = 0;
   1975            SocCalc.ov_cnt = 0;
   1976            SocCalc.uv_cnt = 0;
   1977            SocCalc.stb_cnt = 0;
   1978            SocCalc.soc_rt = 0; 
   1979            
   1980          }
   1981          
   1982          #endif

   Section sizes:

     Function/Label           Bytes
     --------------           -----
     _A_PC_ODR                   1
     _A_CLK_ICKR                 1
     _A_CLK_ECKR                 1
     _A_CLK_SWCR                 1
     _A_CLK_CKDIVR               1
     CLK_PCKENR1                 1
     CLK_PCKENR2                 1
     IWDG_KR                     1
     _A_IWDG_PR                  1
     IWDG_RLR                    1
     _A_I2C_CR1                  1
     _A_I2C_CR2                  1
     _A_I2C_FREQR                1
     I2C_CCRL                    1
     _A_I2C_CCRH                 1
     _A_I2C_TRISER               1
     _A_UART1_SR                 1
     UART1_DR                    1
     UART1_BRR1                  1
     UART1_BRR2                  1
     _A_UART1_CR1                1
     _A_UART1_CR2                1
     _A_UART1_CR3                1
     _A_TIM1_CR1                 1
     _A_TIM1_EGR                 1
     _A_TIM1_CCMR1               1
     _A_TIM1_CCMR2               1
     _A_TIM1_CCER1               1
     TIM1_PSCRH                  1
     TIM1_PSCRL                  1
     TIM1_ARRH                   1
     TIM1_ARRL                   1
     TIM1_CCR1H                  1
     TIM1_CCR1L                  1
     TIM1_CCR2H                  1
     TIM1_CCR2L                  1
     _A_TIM1_BKR                 1
     _A_TIM2_CR1                 1
     _A_TIM2_IER                 1
     _A_TIM2_EGR                 1
     _A_TIM2_CCMR1               1
     _A_TIM2_CCER1               1
     TIM2_CNTRH                  1
     TIM2_CNTRL                  1
     _A_TIM2_PSCR                1
     TIM2_ARRH                   1
     TIM2_ARRL                   1
     TIM2_CCR1H                  1
     TIM2_CCR1L                  1
     _A_TIM4_CR1                 1
     _A_TIM4_IER                 1
     _A_TIM4_EGR                 1
     TIM4_CNTR                   1
     _A_TIM4_PSCR                1
     TIM4_ARR                    1
     _A_ADC_CSR                  1
     _A_ADC_CR1                  1
     _A_ADC_CR2                  1
     _A_ADC_CR3                  1
     ADC_DRH                     1
     ADC_DRL                     1
     ADC_TDRH                    1
     ADC_TDRL                    1
     PWM2_Init                  61
     PWM1_Init                  77
     ADC                        47
     ?Subroutine36              15
     ?Subroutine4                7
     ADConverse                122
     SysInit                    60
     ClrWdt                     21
     PortInit                  118
     ?Subroutine40               6
     ?Subroutine39               3
     ??Subroutine53_0            4
     ?Subroutine38               6
     ?Subroutine37               7
     ?Subroutine47               8
     Uart_Model_Init            29
     Uart_SendByte              25
     itoa                      110
     rev                        21
     Uart_SendStr               38
     Uart_SendData              57
     I2C_Model_Init             33
     Timer2Init                 41
     Timer4_Init_us             18
     ?Subroutine27               9
     ?Subroutine26               9
     ?Subroutine25              13
     Timer4_Init_ms             18
     Timer4_Disable             13
     Delay_us                   14
     Delay_ms                   14
     ?Subroutine24               6
     TempCheck                 150
     DisTemp_Lock                1
     CurrentCheck              138
     ?Subroutine32              12
     VoltCheck                 213
     ?Subroutine9                9
     ?Subroutine49               8
     ModeCheck                 307
     ?Subroutine16               9
     ??Subroutine52_0            4
     ?Subroutine44               6
     ?Subroutine7                9
     ?Subroutine1                9
     ?Subroutine0               15
     ?Subroutine41              32
     ?Subroutine48               8
     ModeChange_Lock             1
     ClearStatus               201
     ?Subroutine35               9
     ?Subroutine43               5
     Afe_Volt_Val_Get          382
     ?Subroutine34               4
     ?Subroutine33               6
     OpenDetect_Cntrl           33
     Opendetect_cnt              1
     CellBal_Cntrl             197
     ?Subroutine29              10
     ?Subroutine10               8
     ?Subroutine6                7
     LedShow_Cntrl             352
     ?Subroutine31               9
     ?Subroutine30               5
     ?Subroutine28               4
     ??Subroutine51_0            7
     ?Subroutine5                5
     FlowLedCnt                  1
     FlowLedCnt_Lock             1
     FlowLed_Finish_Flag         1
     LowPower_Entry_MCU_Set    130
     LowPower_Entry_Exit_Cnt     1
     LowPower_Powerdown_Enter  103
     ?Subroutine3               18
     LowPower_Cntrl             67
     LowPower_Cntrl_1           45
     LowPower_Cntrl_Backup      45
     CRC8_Caculate              66
     ?Subroutine22               5
     ?Subroutine21               5
     ?Subroutine18               6
     ?Subroutine14               2
     ??Subroutine50_0            6
     ?Subroutine46               9
     ?Subroutine8               10
     I2C_Read                  155
     ?Subroutine23              11
     ?Subroutine20               7
     ?Subroutine45               7
     ?Subroutine19              11
     ?Subroutine17              16
     ?Subroutine15              21
     I2C_Write                 116
     ?Subroutine13              32
     I2C_Read_Backup           137
     I2C_Write_Backup          101
     ?Subroutine11               3
     SOC_Init                   68
     ?Subroutine12               5
     ?Subroutine2               15
     ?Subroutine42               8
     SOC_SavedtoEEPROM          29
     Var_Init                  263
     ?<Constant "abcdef">        7
     ?<Constant {0}>            20
     ?<Constant "0x">            3

 
    28 bytes in section .near.bss
    63 bytes in section .near.noinit
    30 bytes in section .near.rodata
 4 704 bytes in section .near_func.text
 
 4 704 bytes of CODE  memory
    30 bytes of CONST memory
    28 bytes of DATA  memory (+ 63 bytes shared)

Errors: none
Warnings: 4
