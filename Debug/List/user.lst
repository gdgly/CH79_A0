###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM830/Mar/2016  19:47:27 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\GitPath\CH79_A0\sys\src\user.c            #
#    Command line =  D:\ProjectPath\GitPath\CH79_A0\sys\src\user.c -e -Ohz    #
#                    --debug --code_model small --data_model medium -o        #
#                    D:\ProjectPath\GitPath\CH79_A0\Debug\Obj\ --dlib_config  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    D:\ProjectPath\GitPath\CH79_A0\Debug\List\ -I            #
#                    D:\ProjectPath\GitPath\CH79_A0/user/\ -I                 #
#                    D:\ProjectPath\GitPath\CH79_A0/user/src/\ -I             #
#                    D:\ProjectPath\GitPath\CH79_A0/user/inc/\ -I             #
#                    D:\ProjectPath\GitPath\CH79_A0/addon/\ -I                #
#                    D:\ProjectPath\GitPath\CH79_A0/addon/src/\ -I            #
#                    D:\ProjectPath\GitPath\CH79_A0/addon/inc/\ -I            #
#                    D:\ProjectPath\GitPath\CH79_A0/sys/\ -I                  #
#                    D:\ProjectPath\GitPath\CH79_A0/sys/inc/\ -I              #
#                    D:\ProjectPath\GitPath\CH79_A0/sys/src/\ -I              #
#                    D:\ProjectPath\GitPath\CH79_A0/lib/\ -I                  #
#                    D:\ProjectPath\GitPath\CH79_A0/lib/src/\ -I              #
#                    D:\ProjectPath\GitPath\CH79_A0/lib/inc/\ --vregs 16      #
#    List file    =  D:\ProjectPath\GitPath\CH79_A0\Debug\List\user.lst       #
#    Object file  =  D:\ProjectPath\GitPath\CH79_A0\Debug\Obj\user.o          #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\GitPath\CH79_A0\sys\src\user.c
      1          
      2          #include "stm8s.h" 
      3          #include "user.h"
      4          #include "macro_def.h"
      5          #include "iostm8s003f3.h"
      6          #include "bq769x0.h"
      7          #include "string.h"
      8          //==================================================================
      9          //==================================================================
     10          //==================================================================
     11          #if 1
     12          void PWM2_Init(void)
     13          { 
     14              CLK_PCKENR1 |= 0xA0; 
     15              TIM2_CR1 =0;              //关闭TIM2
     16              TIM2_IER = 0; 
     17              TIM2_PSCR = 0;  
     18              TIM2_ARRH = 0x07;
     19              TIM2_ARRL = 0xCF;         //16M/(1999+1)=8KHz   //2MHz/(1999+1) = 1KHz 
     20              TIM2_CR1 |= 0x80;         //使能ARP,边沿对齐，向上计数
     21              TIM2_EGR |= 0x01;         //更新TIM1，使PSC有效
     22              TIM2_EGR |= 0x20;         //重新初始化TIM1 
     23              TIM2_CCR1H =0;           
     24              TIM2_CCR1L =0; 
     25              TIM2_CCMR1 =0X68;         //配置TIM2_CH1为PWM1模式输出 
     26              TIM2_CCER1 =0x01;         //Enable TIM2_CH1 channel 
     27              TIM2_CR1 |= 0x01;         //使能TIM2 
     28          }
     29          //==================================================================
     30          //==================================================================
     31          void PWM1_Init(void)
     32          {
     33              CLK_PCKENR1 |= 0x80;
     34              TIM1_CR1 &= ~0x01;      //关闭TIM1 
     35              TIM1_PSCRH = 0;
     36              TIM1_PSCRL = 0;         //不分频2MHz 
     37              TIM1_ARRH = 0x07;
     38              TIM1_ARRL = 0xCF;      //2MHz/(1999+1) = 1KHz 
     39              TIM1_CR1 |= 0x80;      //使能ARP,边沿对齐，向上计数
     40              TIM1_EGR |= 0x01;      //更新TIM1，使PSC有效
     41              TIM1_EGR |= 0x20;      //重新初始化TIM1 
     42              
     43              TIM1_CCR1H = 0;
     44              TIM1_CCR1L = 0; 
     45              TIM1_CCMR1 = 0x68;       //配置TIM1_CH1为PWM1模式输出
     46              TIM1_CCER1 |= 0x01;      //Enable TIM1_CH1 channel
     47              
     48              TIM1_CCR2H = 0;
     49              TIM1_CCR2L = 0;
     50              TIM1_CCMR2 = 0x68;       //配置TIM1_CH2为PWM1模式输出
     51              TIM1_CCER1 |= 0x10;      //Enable TIM1_CH2 channel
     52              
     53              //TIM1_CCR3H = 0x07;
     54              //TIM1_CCR3L = 0xE6;       //占空比50% 
     55              //TIM1_CCMR3 = 0x68;       //配置TIM1_CH3为PWM1模式输出
     56              //TIM1_CCER2 |= 0x01;      //使能TIM1_CH3通道
     57              
     58              //TIM1_CCR4H = 0x03;
     59              //TIM1_CCR4L = 0xE6;       //占空比50%
     60              //TIM1_CCMR4 = 0x68;       //配置TIM1_CH4为PWM1模式输出 
     61              //TIM1_CCER2 |= 0x10;      //Enable TIM1_CH4 channel 
     62              
     63              TIM1_BKR |= 0x80;          //
     64              TIM1_CR1 |= 0x01;          //使能TIM1 
     65          }
     66          //==================================================================
     67          //==================================================================
     68          uint16_t ADC(int channel)
     69          {
     70              unsigned int value =0;
     71              unsigned char tempH,tempL; 
     72              //CLK_PCKENR2 |=0x08; 
     73              ADC_CSR = channel;                // 清除EOC转换结束标志, select channel
     74              nop();  nop(); nop(); nop(); 
     75              ADC_CR1 |= 0x01;                  // 开始单次转换 
     76              nop(); nop(); nop(); nop(); nop();
     77              nop(); nop(); nop(); nop(); nop();
     78              ADC_CR1 |= 0x01;                  // 开始单次转换
     79              nop(); nop(); nop(); nop();
     80              nop(); nop(); nop(); nop();
     81              while(!(ADC_CSR & 0x80))nop();    // 等待单次转换完成 
     82              tempL = ADC_DRL;                  //先 读低8位
     83              tempH = ADC_DRH;                  // 再读高8位，设置数据左对齐
     84              value=(tempH<<8)|tempL;
     85              ADC_CSR &= ~(0x80);               // 清除EOC转换结束标志  
     86              ADC_CR1 &= ~(0x01); 
     87              return(value);  
     88          }
     89          //==================================================================
     90          //==================================================================
     91          uint16_t ADConverse(unsigned char channel)
     92          { 
     93              unsigned int value=0;
     94              unsigned int max_value =0;
     95              unsigned int min_value =0xEFFF;
     96              unsigned char i;  
     97              CLK_PCKENR2 |=0x08;  
     98              for(i =0;i <100;i++)
     99              {
    100                nop();nop();
    101              }
    102              for(i=0;i<18;i++)
    103              {
    104                Adc_value[i] = ADC(channel); 
    105              }
    106              for(i =0;i<18;i++)
    107              {
    108                value +=Adc_value[i];
    109                if(max_value <Adc_value[i])
    110                  max_value =Adc_value[i];
    111                 
    112                if(min_value >Adc_value[i])
    113                  min_value =Adc_value[i];
    114              }
    115              value =value -max_value -min_value;
    116              value >>= 4; 
    117              CLK_PCKENR2 &=~(0x08); 
    118              return value; 
    119          }
    120          //================================================================================
    121          //==================================================================
    122          void SysInit(void)
    123          { 
    124              //-------system clock                                           
    125              CLK_ECKR &= ~0x01;  // external RC Disable                                              
    126              CLK_ICKR = 0x01;    // internal RC enable
    127              while(!(CLK_ICKR & 0x02)); 
    128              CLK_SWCR = 0;       // 禁止时钟切换及相关中断
    129              CLK_CKDIVR = 0x02;  // 主频为Fmaster为Fhsi：16MHz, Fcpu为4MHz  0.25us
    130              //CLK_PCKENR1 = 0;    // 禁止Fmaster 与外设连接
    131              //CLK_PCKENR2 = 0;
    132              /* */
    133              //------------------A/D conversion 
    134              CLK_PCKENR2 |= 0x08;           //使能Fmaster与外设ADC模块连接 
    135              ADC_CR1 = 0x00;               // ADC时钟=主时钟/2=8MHZ,单次转换模式Tad =1/8,未使能ADC
    136              ADC_CR2 = 0x08;               // A/D 结果数据右对齐
    137              ADC_CSR = 0x00;               // 清转换结束标志位EOC，
    138              ADC_CR3 = 0x00;
    139              ADC_TDRH = 0xFF;              //禁止施密特触发功能
    140              ADC_TDRL = 0x00; 
    141              nop(); nop();
    142              ADC_TDRL = 0x08;              // AIN3  0b0000 1000 
    143              CLK_PCKENR2 &=~(0x08);
    144             
    145          }
    146          //==================================================================
    147          //==================================================================
    148          //---------------WatchDog  LSI 128KHz/2 = 64KHz
    149          /*
    150              预分频系数    PR[2:0]   最短超时(RL[7:0]=0x00)    最长超时(RL[7:0]=0xFF)
    151              /4            0         62.5 μs                  15.90 ms     
    152              /8            1         125 μs                   31.90 ms     
    153              /16           2         250 μs                   63.70 ms     
    154              /32           3         500 μs                   127 ms     
    155              /64           4         1.00 ms                   255 ms     
    156              /128          5         2.00 ms                   510 ms     
    157              /256          6         4.00 ms                   1.02 s     
    158          */
    159          /*  */
    160          void ClrWdt(void)
    161          {
    162              IWDG_KR = 0x55;   //解除保护
    163              IWDG_RLR = 0xFF;  //刷新内容
    164              IWDG_PR = 6; 
    165              IWDG_KR = 0xAA;   //刷新及恢复保护
    166              IWDG_KR = 0xCC;   //独立看门狗启动
    167          } 
    168          
    169          //==================================================================
    170          //==================================================================
    171          void PortInit(void)
    172          { 
    173            GPIO_Init(GPIOA, GPIO_PIN_3, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    174            GPIO_Init(GPIOA, GPIO_PIN_2, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    175            GPIO_Init(GPIOA, GPIO_PIN_1, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    176            
    177            GPIO_Init(GPIOB, GPIO_PIN_5, GPIO_MODE_OUT_PP_LOW_FAST);           
    178            GPIO_Init(GPIOB, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);       
    179           
    180            GPIO_Init(GPIOC, GPIO_PIN_7, GPIO_MODE_OUT_PP_LOW_FAST);    // ALERT 
    181            GPIO_Init(GPIOC, GPIO_PIN_6, GPIO_MODE_OUT_PP_LOW_FAST);    // chger fault control 
    182            GPIO_Init(GPIOC, GPIO_PIN_5, GPIO_MODE_OUT_PP_LOW_FAST);    // LED1
    183            GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);    // LED2
    184            GPIO_Init(GPIOC, GPIO_PIN_3, GPIO_MODE_OUT_PP_LOW_FAST);    // LED3 
    185             
    186            GPIO_Init(GPIOD, GPIO_PIN_6, GPIO_MODE_IN_PU_IT);          
    187            GPIO_Init(GPIOD, GPIO_PIN_5, GPIO_MODE_OUT_PP_HIGH_FAST);          
    188            GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);    // undefined
    189            GPIO_Init(GPIOD, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);        // chger fault input
    190            GPIO_Init(GPIOD, GPIO_PIN_2, GPIO_MODE_IN_FL_NO_IT);        // Triger Voltage measurement
    191          #if 0
    192            CPU_CFG_GCR |=0x01;                                         //SWIN模式被禁用，SWIM引脚可被用作普通I/O口
    193            GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_OUT_PP_HIGH_FAST);   //MUC_DO3
    194          #else
    195            GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_IN_PU_NO_IT);        //SWIN 
    196          #endif
    197            //EXTI_CR1 |=0x40;//上升沿触发//0x80;//下降沿触发
    198            EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
    199            /*------------------------------------------------------------------------------------
    200              GPIO_MODE_IN_FL_NO_IT 无中断功能的浮动输入。  // ADC input
    201              
    202              GPIO_MODE_IN_PU_NO_IT 无中断功能的上拉输入。  // normal digit input
    203              
    204              GPIO_MODE_IN_FL_IT 带中断功能的浮动输入。  
    205              
    206              GPIO_MODE_IN_PU_IT 带中断功能的上拉输入。	
    207              
    208              GPIO_MODE_OUT_OD_LOW_FAST 高速开漏低电平输出，可工作到10MHz。  
    209              
    210              GPIO_MODE_OUT_PP_LOW_FAST 高速推挽低电平输出，可工作到10MHz。  
    211              
    212              GPIO_MODE_OUT_OD_LOW_SLOW 低速开漏低电平输出，可工作到2MHz。	// undefined port
    213              
    214              GPIO_MODE_OUT_PP_LOW_SLOW 低速推挽低电平输出，可工作到2MHz。	
    215              
    216              GPIO_MODE_OUT_OD_HIZ_FAST 高速开漏高阻态输出，可工作到10MHz。  
    217              
    218              GPIO_MODE_OUT_PP_HIGH_FAST 高速推挽高电平输出，可工作到10MHz。  
    219              
    220              GPIO_MODE_OUT_OD_HIZ_SLOW 低速开漏高阻态输出，可工作到2MHz。	
    221              
    222              GPIO_MODE_OUT_PP_HIGH_SLOW 低速推挽高电平输出，可工作到2MHz。
    223             ------------------------------------------------------------------------------------*/
    224          } 
    225          //================================================================== 
    226          /*--------------------------------
    227            配置 UART1
    228              - BaudRate = 9600 baud
    229              - Word Length = 8 Bits
    230              - One Stop Bit
    231              - No parity
    232              - Receive and transmit enabled
    233              - UART1 Clock disabled
    234          --------------------------------*/
    235          void Uart_Model_Init(void)
    236          {
    237              //UART1_DeInit(); 
    238              //UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO,UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TX_ENABLE);//UART1_MODE_TXRX_ENABLE
    239              //================================================================== 
    240              /*  */
    241              CLK_PCKENR1 |= 0x0C;         // 使能fmaster与UART连接 
    242              UART1_BRR2  =  0x02;         // 设置波特率9600
    243              UART1_BRR1  =  0x68;         // 16M/9600 = 0x0682
    244              UART1_CR1   =  0x00;          //UART使能，一个起始位，8个数据位，禁止奇偶校验，禁止中断
    245              UART1_CR3   =  0x00;          //一个停止位    
    246              UART1_CR2   =  0x08;//  send only //0x0C;           //发送及接收使能 
    247              //UART1_CR2   |= 0x20;          //接收中断使能  
    248          } 
    249          void Uart_SendByte(uint8_t DataByte)      
    250          {   
    251              //===单线通讯时，发送数据时避免影响接收管脚，故发送数据时先禁止接收及其中断
    252              //UART1_CR2 &= ~0x04;
    253              //UART1_CR2 &= ~0x20; 
    254              while(!UART1_SR_TXE);
    255              UART1_DR = DataByte;    
    256              nop(); nop(); nop();
    257              while(!(UART1_SR &0x40)); 
    258              //========数据发送完毕，使能接收及其中断
    259              UART1_SR &= ~0x48;
    260              //UART1_CR2 |= 0x24; 
    261          }  
    262          	
    263          void itoa(char *buf, int i, int base)
    264          {
    265              #define LEN	20
    266              char *s;
    267              int rem;
    268              static char rev[LEN+1];
    269            
    270              rev[LEN] = 0;
    271              if (i == 0)
    272              {
    273                (buf)[0] = '0';
    274                ++(buf);
    275                return;
    276              }
    277              s = &rev[LEN];
    278              while (i)
    279              {
    280                rem = i % base;
    281                if (rem < 10)
    282                {
    283                  *--s = rem + '0';
    284                }
    285                else if (base == 16)
    286                {
    287                  *--s = "abcdef"[rem - 10];
    288                }
    289                i /= base;
    290              }
    291              while (*s)
    292              {
    293                (buf)[0] = *s++;
    294                ++(buf);
    295              }
    296          }
    297          
    298          void Uart_SendStr(unsigned char *tx_pData) 
    299          {
    300              unsigned int i, nLen; 
    301              nLen = strlen(tx_pData);
    302              ClrWdt();
    303              for(i=0; i<nLen; i++)
    304              {
    305                Uart_SendByte(tx_pData[i]);
    306              }
    307          }
    308          
    309           
    310          void Uart_SendData(unsigned int tx_data, int base) 
    311          {
    312            unsigned char buf[20] = {0};
    313          
    314            itoa((char *)buf, tx_data, base);
    315            
    316            if (base == 16)
    317            {
    318              Uart_SendStr((unsigned char *)"0x");
    319            }
    320            
    321            Uart_SendStr(buf);
    322          }
    323          
    324          
    325          //==================================================================
    326          void I2C_Model_Init(void)
    327          { 
    328            CLK_PCKENR1 |= 0x01;    // Fmaster 与外设I2C连接 
    329            I2C_CR1 = 0;
    330             
    331            //I2C_ITR   = 0x01;    //使能错误中断
    332            I2C_FREQR = 8;//输入时钟为8MHz
    333            
    334            I2C_TRISER = 9;
    335             
    336            //CRR的计算，确定I2C的通信频率f_SCL =1/(T_high + T_low), 100KHz -->T_hgih = T_low =5000ns
    337            //I2C的输入频率f_CK = 1/T_CK, CRR = T_hgih /T_CK;
    338            I2C_CCRL = 80;//40; // 上升沿及下降沿时间5000s, 
    339            I2C_CCRH = 0;  // 标准模式100KHz,  
    340               
    341            I2C_CR1 |= 0x01;//I2C_CR1_PE;
    342            
    343            I2C_CR2 |= 0x04;
    344          }
    345          //================================================================== 
    346          //=======================================================================
    347          //======================================================================= 
    348          //======================================================================= 
    349          void Timer2Init(void)
    350          { 
    351              CLK_PCKENR1 |= 0x20;    // Fmaster 与外设TIM2连接
    352              TIM2_CR1 = 0x84;        // TIM2_ARR寄存器通过缓冲预装载，使能计数器
    353              TIM2_IER = 0x00;        // 禁止中断
    354              //TIM2_EGR = 0x01;        // 允许产生更新事件 
    355              TIM2_PSCR = 0x07;       // 计数器时钟=主时钟/8=16MHZ/128    8us// 相当于计数器周期为 
    356              TIM2_CNTRH = 0;         //     
    357              TIM2_CNTRL = 0;         //     
    358              TIM2_ARRH = 0x04;       //     10ms
    359              TIM2_ARRL = 0xE2;       //   
    360              TIM2_IER |= 0x01;       // 使能更新中断，禁止触发中断  
    361              TIM2_CR1 |= 0x01;        // TIM2_ARR寄存器通过缓冲预装载，使能计数器
    362          } 
    363          //=======================================================================
    364          //==================================================================
    365          //==================================================================
    366          //--Fmaster = CK_PSC =16MHz, CK_PSC prescaler(128) to CK_CNT(8us)   TIM4_SR1.UIF更新中断标志符
    367          void Timer4_Init_us(void)
    368          {
    369              CLK_PCKENR1 |= 0x10;    //Fmaster 与外设TIM4连接
    370              TIM4_IER = 0x00;        // 禁止中断
    371              TIM4_EGR = 0x01;        // 允许产生更新事件 
    372              //TIM4_PSCR = 0x07;       // 计数器时钟=主时钟/128=16MHZ/128  // 相当于计数器周期为8uS
    373              TIM4_PSCR = 0x00;       // 计数器时钟=主时钟/128=16MHZ/1  // 相当于计数器周期为0.0625uS
    374              TIM4_CR1 = 0x15;        // TIM4_ARR寄存器通过缓冲预装载，使能计数器
    375              TIM4_CNTR = 0;          //     
    376              TIM4_ARR = 16;           // 0.0625*16 = 1us  // 6*8us = 200us  
    377              TIM4_IER |= 0x01;       //更新中断使能，禁止触发中断 
    378              TIM4_CR1 |= 0x01; 
    379          } 
    380          void Timer4_Init_ms(void)
    381          {
    382              CLK_PCKENR1 |= 0x10;    //Fmaster 与外设TIM4连接
    383              TIM4_IER = 0x00;        // 禁止中断
    384              TIM4_EGR = 0x01;        // 允许产生更新事件 
    385              TIM4_PSCR = 0x07;       // 计数器时钟=主时钟/128=16MHZ/128  // 相当于计数器周期为8uS 
    386              TIM4_CR1 = 0x15;        // TIM4_ARR寄存器通过缓冲预装载，使能计数器
    387              TIM4_CNTR = 0;          //     
    388              TIM4_ARR = 125;         // 125*8us = 1ms  
    389              TIM4_IER |= 0x01;       //更新中断使能，禁止触发中断 
    390              TIM4_CR1 |= 0x01; 
    391          } 
    392          void Timer4_Disable(void)
    393          {
    394              TIM4_CR1 &= ~0x01;
    395              TIM4_IER &= ~0x01;
    396              CLK_PCKENR1 &= ~0x10;    //Fmaster 与外设TIM4断开连接 
    397          } 
    398          void Delay_us(uint16_t Delay_time)
    399          {
    400            Delay_time_t = Delay_time;
    401            Timer4_Init_us();
    402            while(Delay_time_t > 0);  
    403            Timer4_Disable();
    404          }
    405          void Delay_ms(uint16_t Delay_time)
    406          {
    407            Delay_time_t = Delay_time;
    408            Timer4_Init_ms();
    409            while(Delay_time_t > 0)
    410            {
    411              if(Delay_time_t >= 300)
    412              {  
    413                ;//ClrWdt(); 
    414              } 
    415            }
    416            Timer4_Disable();
    417          }
    418            
    419          //==================================================================
    420          /*
    421            The following equations show how to use the 14-bit ADC readings in TS1, TS2, and TS3 to determine the
    422            resistance of the external 103AT thermistor:
    423              VTSX = (ADC in Decimal) x 382 μV/LSB                     (4)
    424              RTS = (10,000 × VTSX) ÷ (3.3 C VTSX)                   (5)
    425          */
    426          void TempCheck(void)
    427          { 
    428              static uint8_t ChgTemp_cnt =0;
    429              static uint8_t DisTemp_cnt =0;  
    430               
    431              Temp_Val = V_TS2_Val;//R_TS2_Val;
    432              if(WorkMode == CHARGE_MODE)//if(Bits_flag.Bit.Chg)
    433              {
    434                 if((Temp_Val >ChgTempL_ON) || (Temp_Val < ChgTempH_ON) || (ChgTemp_cnt >= 10))
    435                 {
    436                   if((ChgTemp_cnt ++) >= 10)
    437                   {
    438                     ChgTemp_cnt = 10;
    439                     Bits_flag.Bit.ChgTemp = 1;
    440                   }
    441                 }
    442                 else
    443                 {
    444                   ChgTemp_cnt = 0;
    445                 }
    446                //==========================充电温度保护恢复
    447                if(Bits_flag.Bit.ChgTemp && (Temp_Val < ChgTempL_OFF) && (Temp_Val >ChgTempH_OFF))
    448                {
    449                    ChgTemp_cnt = 0;
    450                    Bits_flag.Bit.ChgTemp = 0;
    451                } 
    452              }
    453              else if(WorkMode == DISCHARGE_MODE)//(Bits_flag.Bit.Dis)
    454              {
    455                ChgTemp_cnt = 0;
    456                if((Temp_Val > DisTempL_ON) || (Temp_Val < DisTempH_ON) || (DisTemp_cnt >= 10)) 
    457                {
    458                  if((DisTemp_cnt ++) >= 10)
    459                  {
    460                    DisTemp_cnt = 10;
    461                    Bits_flag.Bit.DisTemp = 1;
    462                  }
    463                }
    464                else
    465                {
    466                  DisTemp_cnt = 0;
    467                }  
    468                //==========================放电温度保护恢复
    469                if(Bits_flag.Bit.DisTemp && (Temp_Val < DisTempL_OFF) && (Temp_Val > DisTempH_OFF))
    470                {
    471                  DisTemp_cnt = 0;
    472                  Bits_flag.Bit.DisTemp = 0;
    473                } 
    474              }   
    475              //====================================================
    476              
    477            if(SYS_STAT.Bit.DEVICE_XREADY)// || SYS_STAT.Bit.OVRD_ALERT)
    478            {
    479              Bits_flag.Bit.AfeErr = 1;
    480            } 
    481          }
    482          //================================================================== 
    483          //==================================================================
    484          /*      SYS_STAT (0x00)/RESET:0x00
    485                  BIT        7      6           5             4       3   2    1     0
    486                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    487          */
    488          void CurrentCheck(void)
    489          {  
    490            if(WorkMode == CHARGE_MODE)
    491            {
    492              if(Current_Val > ChgCurOv_Val_SET)
    493              {
    494                if(ChgCurOv_t >= ChgCurOv_t_SET)
    495                {
    496                  ChgCurOv_t = ChgCurOv_t_SET;
    497                  Bits_flag.Bit.ChgCurOv = 1;
    498                }
    499              }
    500              else
    501              {
    502                ChgCurOv_t = 0;
    503              } 
    504              /*
    505              if(0)//(Bits_flag.Bit.ChgCurOv && ChgCurOv_Re_t >= ChgCurOv_Re_t_SET)
    506              {
    507                ChgCurOv_t = 0; 
    508                ChgCurOv_Re_t = 0;
    509                Bits_flag.Bit.ChgCurOv = 0;
    510              } */
    511            }
    512            else if(WorkMode == DISCHARGE_MODE)//9A,  15A
    513            {
    514              if(SYS_STAT.Bit.OCD || Current_Val > DisCurOv_2_Val_SET || (DisCurOv_t1 >= DisCurOv_t1_SET) || (DisCurOv_t1 >= DisCurOv_t1_SET))
    515              {
    516                if(SYS_STAT.Bit.OCD || (DisCurOv_t2 >= DisCurOv_t2_SET) || (DisCurOv_t1 >= DisCurOv_t1_SET))
    517                {
    518                  DisCurOv_t1 = DisCurOv_t1_SET;
    519                  DisCurOv_t2 = DisCurOv_t2_SET;
    520                  Bits_flag.Bit.DisCurOv = 1;
    521                } 
    522              }
    523              else if(Current_Val > DisCurOv_1_Val_SET)//9A
    524              { 
    525                DisCurOv_t2 = 0;
    526                if(DisCurOv_t1 >= DisCurOv_t1_SET)
    527                {
    528                  DisCurOv_t1 = DisCurOv_t1_SET; 
    529                  Bits_flag.Bit.DisCurOv = 1;
    530                }  
    531              }
    532              else
    533              {
    534                DisCurOv_t1 = 0;
    535                DisCurOv_t2 = 0;
    536              }
    537              /*
    538              if(Current_Val > DisCurOv_Val_SET || SYS_STAT.Bit.OCD || (DisCurOv_t >= DisCurOv_t_SET))
    539              {
    540                if(SYS_STAT.Bit.OCD || (DisCurOv_t >= DisCurOv_t_SET))
    541                {
    542                  DisCurOv_t = DisCurOv_t_SET; 
    543                  Bits_flag.Bit.DisCurOv = 1;
    544                } 
    545              }
    546              else
    547              {
    548                DisCurOv_t = 0;
    549              }
    550              */
    551              /*
    552              if(0)//(Bits_flag.Bit.DisCurOv)// && DisCurOv_Re_t >= DisCurOv_Re_t_SET)
    553              {
    554                //clear the OV bit by writing "1"
    555                if(SYS_STAT.Bit.OCD)
    556                {
    557                  SYS_STAT_Last |= 0x01;
    558                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    559                  SYS_STAT_Last &= ~0x01;
    560                }
    561                DisCurOv_t = 0;
    562                DisCurOv_Re_t = 0;
    563                Bits_flag.Bit.DisCurOv = 0;
    564              }*/
    565              
    566              //==========================短路检测
    567              //if(WorkMode != CHARGE_MODE)
    568              {
    569                if( SYS_STAT.Bit.SCD )
    570                {  
    571                   Bits_flag.Bit.DisCurShort = 1; 
    572                }
    573                /*
    574                if(Bits_flag.Bit.DisCurShort && DisCurShort_Re_t >= DisCurShort_Re_t_SET)
    575                { 
    576                  SYS_STAT_Last |= 0x02;   //clear the SCD bit by writing "1" 
    577                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    578                  SYS_STAT_Last &= ~0x02;
    579                  DisCurOv_Re_t = 0;
    580                  SYS_STAT.Bit.SCD = 0;
    581                  Bits_flag.Bit.DisCurShort =0;
    582                }
    583                */
    584              }
    585            }
    586            
    587            
    588          }
    589          //==================================================================
    590          //==================================================================
    591          /*      SYS_STAT (0x00)/RESET:0x00
    592                  BIT        7      6           5             4       3   2    1     0
    593                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    594          */
    595          void VoltCheck(void)
    596          {  
    597            if(WorkMode == CHARGE_MODE)
    598            {
    599              if(Cell_Volt_Max >= CHG_OV_VAL_SET ||SYS_STAT.Bit.OV)
    600              { 
    601                if((ChgOv_t >= ChgOv_t_SET) ||SYS_STAT.Bit.OV)
    602                {
    603                  ChgOv_t = ChgOv_t_SET;
    604                  Bits_flag.Bit.ChgOv = 1;
    605                }
    606              }
    607              else
    608              {
    609                ChgOv_t =0;
    610              }
    611              
    612              if(Bits_flag.Bit.ChgOv && Cell_Volt_Max < CHG_OV_RE_VAL_SET)// Cell_Volt_Avg < CHG_OV_RE_VAL_SET &&
    613              {
    614                //clear the OV bit by writing "1"
    615                if(SYS_STAT.Bit.OV)
    616                {
    617                  SYS_STAT_Last |= 0x04;
    618                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    619                  SYS_STAT_Last &= ~0x04;
    620                }
    621                ChgOv_t = 0;
    622                SYS_STAT.Bit.OV = 0;
    623                Bits_flag.Bit.ChgOv = 0;
    624              }
    625                
    626            }
    627            else// if(WorkMode == DISCHARGE_MODE)
    628            {
    629              if(Dis_First_Run_Flag ==0 && WorkMode == DISCHARGE_MODE)
    630              { 
    631                if((Cell_Volt_Avg < 3300) || (Cell_Volt_Min < 3300) || SYS_STAT.Bit.UV)
    632                {
    633                  if(Dis_First_Run_t >= 100)
    634                  {
    635                    Dis_First_Run_t = 100;
    636                    Bits_flag.Bit.DisOv = 1;
    637                    Dis_First_Run_Flag  = 1;
    638                  }
    639                }
    640                else 
    641                {
    642                  if(Dis_First_Run_t >= 50)
    643                  {
    644                    Dis_First_Run_t = 100; 
    645                    Bits_flag.Bit.DisOv = 0;
    646                    Dis_First_Run_Flag  = 1;
    647                    DisOv_t = 0;
    648                    //clear the UV bit by writing "1"
    649                    if(SYS_STAT.Bit.UV)
    650                    {
    651                      SYS_STAT_Last |= 0x08;
    652                      I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    653                      SYS_STAT_Last &= ~0x08;
    654                    }
    655                  }
    656                } 
    657              } 
    658          
    659              if((Cell_Volt_Avg < DIS_UV_VAL_SET) ||(Cell_Volt_Min < DIS_UV_MIN_VAL_SET) || SYS_STAT.Bit.UV)// 
    660              {
    661                if((DisOv_t >= DisOv_t_SET) || SYS_STAT.Bit.UV)
    662                {
    663                  DisOv_t = DisOv_t_SET;
    664                  Bits_flag.Bit.DisOv = 1;
    665                }
    666              }
    667              else
    668              {
    669                DisOv_t = 0;
    670              }
    671              /*
    672              if(Bits_flag.Bit.DisOv && Cell_Volt_Min >= DIS_UV_RE_VAL_SET)//Cell_Volt_Avg >= DIS_UV_RE_VAL_SET && 
    673              {
    674                //clear the UV bit by writing "1"
    675                if(SYS_STAT.Bit.UV)
    676                {
    677                  SYS_STAT_Last |= 0x08;
    678                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    679                  SYS_STAT_Last &= ~0x08;
    680                }
    681                DisOv_t = 0;
    682                SYS_STAT.Bit.UV = 0;
    683                Bits_flag.Bit.DisOv = 0;
    684              }
    685              */
    686            }
    687          }  
    688          //==========================================================================
    689          void ModeCheck_Backup(void)
    690          {     
    691            static uint8_t Afe_CC_Disable_Lock = 0; 
    692            if(IS_CHG_DETECT() || CC_Val >= 10)
    693            {  
    694              if(ChgExchangeMode_Cnt >= 50)
    695              { 
    696                ChgExchangeMode_Cnt = 100;
    697                DisExchangeMode_Cnt = 0;
    698                IdleExchangeMode_Cnt = 0;
    699                WorkMode = CHARGE_MODE;
    700              }
    701            }  
    702            else if(IS_SIGNAL_IN())  
    703            {  
    704              if(DisExchangeMode_Cnt >= 100)
    705              { 
    706                IdleExchangeMode_Cnt = 0;
    707                ChgExchangeMode_Cnt = 0;
    708                DisExchangeMode_Cnt = 100; 
    709                WorkMode = DISCHARGE_MODE;
    710              }
    711            }/* 
    712            else if(WorkMode == DISCHARGE_MODE && SYS_CTRL2.Bit.CHG_ON && SYS_CTRL2.Bit.DSG_ON)// 负载接上，小电流或无电流时，关闭CHG_ON，来检测LOAD_PRESENT
    713            { 
    714              SYS_CTRL2_Last &= ~0x03; 
    715              I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    716              Delay_ms(20);
    717              I2C_Read(SYS_CTRL1_ADDR,&SYS_CTRL1_Last); 
    718              SYS_CTRL1.Byte = SYS_CTRL1_Last;
    719              if(SYS_CTRL1.Bit.LOAD_PRESENT) 
    720              { 
    721                SYS_CTRL2_Last |= 0x03; 
    722                I2C_Write(SYS_CTRL2_ADDR,SYS_CTRL2_Last);
    723              } 
    724              else
    725              {
    726                ExchangeMode_Cnt = 0;
    727                WorkMode = IDLE_MODE;  
    728              } 
    729            } */
    730            else 
    731            { 
    732              if(IdleExchangeMode_Cnt >= 100)
    733              { 
    734                IdleExchangeMode_Cnt = 100;
    735                ChgExchangeMode_Cnt = 0;
    736                DisExchangeMode_Cnt = 0;
    737                WorkMode = IDLE_MODE;
    738              }
    739            }
    740            
    741            //=================================
    742            if(WorkMode == IDLE_MODE)
    743            {
    744                Afe_CC_Disable();
    745                Afe_CC_Disable_Lock = 0;
    746            }
    747            else
    748            {
    749              if(Afe_CC_Disable_Lock == 0)
    750              {
    751                Afe_CC_1Shot_Set(); 
    752                Afe_CC_Disable_Lock = 1;
    753              }
    754            }
    755          }
    756          
    757          //==========================================================================
    758          void ModeCheck(void)
    759          {       
    760            Check_Val = ADConverse(3); 
    761            if((Check_Val >= 130 && Check_Val < 160) || CC_Val >= 10)
    762            {  
    763              if(ChgExchangeMode_Cnt >= 50)
    764              { 
    765                ChgExchangeMode_Cnt  = 100;
    766                DisExchangeMode_Cnt  = 0;
    767                IdleExchangeMode_Cnt = 0;
    768                WorkMode = CHARGE_MODE;
    769              }
    770            }  
    771            //else if(IS_SIGNAL_IN()) // (FET_Status == 1 && (IS_LOAD_DETECT() || SYS_CTRL1.Bit.LOAD_PRESENT)) || Current_Val >= 20 || 
    772            else if((Check_Val >= 220 && Check_Val < 630)) 
    773            {  
    774              if(DisExchangeMode_Cnt >= 100)
    775              { 
    776                IdleExchangeMode_Cnt = 0;
    777                ChgExchangeMode_Cnt = 0;
    778                DisExchangeMode_Cnt = 100; 
    779                WorkMode = DISCHARGE_MODE;
    780              }
    781            } 
    782            else if(Check_Val < 10)
    783            { 
    784              if(IdleExchangeMode_Cnt >= 100)
    785              { 
    786                IdleExchangeMode_Cnt = 100;
    787                ChgExchangeMode_Cnt = 0;
    788                DisExchangeMode_Cnt = 0;
    789                WorkMode = IDLE_MODE;
    790              }
    791            } 
    792          }
    793          
    794            //===========================================
    795          void ClearStatus(void)
    796          {
    797            if(WorkMode == CHARGE_MODE)
    798            {  
    799                LowPower_MCU_Entry_Flag = 0;
    800                Dis_First_Run_Flag = 0;
    801                Dis_First_Run_t = 0;
    802                DisOv_t = 0;  
    803                //DisCurOv_t = 0;  
    804                //DisCurOv_Re_t = 0; 
    805                PowerOff_Delay_t = 0;
    806                 
    807                Bits_flag.Bit.DisTemp = 0;
    808                //Bits_flag.Bit.DisCurShort = 0; 
    809                
    810                if(Bits_flag.Bit.DisOv || SYS_STAT.Bit.UV)
    811                { 
    812                  if(SYS_STAT.Bit.UV)  //clear the UV bit by writing "1"
    813                  {
    814                    SYS_STAT_Last |= 0x08;
    815                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    816                    SYS_STAT_Last &= ~0x08;
    817                  }  
    818                  Bits_flag.Bit.DisOv = 0;
    819                }
    820               /* if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD) 
    821                { 
    822                  if(SYS_STAT.Bit.OCD)  //clear the OV bit by writing "1"
    823                  {
    824                    SYS_STAT_Last |= 0x01;
    825                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    826                    SYS_STAT_Last &= ~0x01;
    827                  }
    828                  Bits_flag.Bit.DisCurOv = 0;
    829                } */
    830            }/*
    831            else if(WorkMode == DISCHARGE_MODE)
    832            {
    833                ChgOv_t = 0; 
    834                ChgCurOv_t = 0; 
    835                ChgCurOv_Re_t = 0; 
    836                 
    837                Bits_flag.Bit.ChgCurOv = 0;
    838                Bits_flag.Bit.ChgTemp = 0;
    839                if(Bits_flag.Bit.ChgOv || SYS_STAT.Bit.OV)
    840                { 
    841                  if(SYS_STAT.Bit.OV)  //clear the UV bit by writing "1"
    842                  {
    843                    SYS_STAT_Last |= 0x04;
    844                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    845                    SYS_STAT_Last &= ~0x04;
    846                  }  
    847                  Bits_flag.Bit.ChgOv = 0;
    848                }
    849            }*/
    850            else if(WorkMode == IDLE_MODE)
    851            {   
    852              Dis_First_Run_Flag = 0;
    853              Dis_First_Run_t = 0;
    854              //if(Bits_flag.Bit.ChgCurOv)// && ChgCurOv_Re_t >= ChgCurOv_Re_t_SET)
    855              {
    856                ChgCurOv_t = 0; 
    857                DisCurOv_t1 = 0;
    858                DisCurOv_t2 = 0;
    859                ChgCurOv_Re_t = 0;
    860                Bits_flag.Bit.ChgCurOv = 0;
    861              } 
    862              //=========================================================
    863              DisCurShort_Re_t = 0;
    864              if(Bits_flag.Bit.DisCurShort  || SYS_STAT.Bit.SCD) 
    865              { 
    866                SYS_STAT_Last |= 0x02;
    867                I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); //clear the SCD bit by writing "1" 
    868                SYS_STAT_Last &= ~0x02;
    869                Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);
    870                DisCurOv_Re_t = 0;
    871                SYS_STAT.Bit.SCD = 0;
    872                Bits_flag.Bit.DisCurShort = 0;
    873              }
    874              //=========================================================
    875              if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD) 
    876              { 
    877                if(SYS_STAT.Bit.OCD)  //clear the OV bit by writing "1"
    878                {
    879                  SYS_STAT_Last |= 0x01;
    880                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last);
    881                  SYS_STAT_Last &= ~0x01;
    882                  Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);
    883                }
    884                Bits_flag.Bit.DisCurOv = 0;
    885              } 
    886              //=========================================================
    887              DisCurOv_t = 0;
    888              DisCurOv_Re_t = 0;
    889              Bits_flag.Bit.ChgOv = 0;
    890              Bits_flag.Bit.ChgCurOv = 0;
    891              Bits_flag.Bit.ChgTemp = 0;
    892               
    893            }
    894            else
    895            { 
    896              LowPower_MCU_Entry_Flag = 0; 
    897            }
    898          }  
    899          //==========================================================================
    900            /*The ADC transfer function is a linear equation defined as follows:
    901              V(cell) = GAIN x ADC(cell) + OFFSET
    902              If the DEVICE_XREADY is set, the voltage register values from the device should not be used. If
    903            */ 
    904          void Afe_Volt_Val_Get(void)
    905          { 
    906            uint8_t i = 0;
    907            uint16_t volt_sum = 0;
    908            uint16_t volt_max = 0;
    909            uint16_t volt_min = 0xFFFF;
    910            //====================================250mS
    911            if(Cell_Volt_Sample_Cnt >= 26)
    912            {
    913              Cell_Volt_Sample_Cnt = 0;
    914              for(i =0;i< 20;i += 2)
    915              {  
    916                Adc_value[i/2] = Afe_Get_Adc((VC1_HI_ADDR + i)) & 0x3FFF; //VC1_HI_ADDR =0x0C
    917                Cell_Volt[i/2] = (uint16_t)((uint32_t)ADCGain_Val *Adc_value[i/2]/1000) + ADCOffset_Val;
    918                volt_sum += Cell_Volt[i/2];
    919                if(Cell_Volt[i/2] < volt_min)
    920                {
    921                   volt_min = Cell_Volt[i/2];
    922                }
    923                if(Cell_Volt[i/2] > volt_max)
    924                {
    925                   volt_max = Cell_Volt[i/2];
    926                }
    927              } 
    928              Cell_Volt_Tol = volt_sum; 
    929              Cell_Volt_Avg = Cell_Volt_Tol/10; 
    930              Cell_Volt_Max = volt_max; 
    931              Cell_Volt_Min = volt_min; 
    932                
    933            }
    934            //====================================250mS
    935            /*  Once converted to digital form, each cell voltage is added up and the summation result stored in the BAT
    936                registers. This 16-bit value has a nominal LSB of 1.532 mV. */
    937            //Pack_Volt = (uint16_t)((uint32_t)4 *ADCGain_Val *Afe_Get_Adc(BAT_HI_ADDR)/1000+(10 *ADCOffset_Val));
    938            //Pack_Volt = (uint16_t)((uint32_t)1532 *Afe_Get_Adc(BAT_HI_ADDR)/1000);
    939            
    940            //====================================250mS
    941            //Positive values are charge current; negative values are discharge current.
    942            //an average over the 250-ms integration period.
    943            /*Why does the CC value read not change when I set the CC_ONESHOT bit?
    944                  The CC_READY bit must be cleared before the CC_ONESHOT bit is set. Note also that the CC_EN bit
    945                  should be cleared or a CC conversion may already be in progress.
    946              The full scale range of the CC is ± 270 mV, with a max recommended input range of ± 200 mV, thus yielding an LSB of approximately 8.44 μV.
    947              The following equation shows how to convert the 16-bit CC reading into an analog voltage if no boardlevel calibration is performed:
    948              CC Reading (in μV) = [16-bit 2’s Complement Value] × (8.44 μV/LSB) 
    949            */
    950            if( SYS_STAT.Bit.CC_READY) //CC_Volt_Sample_Cnt >= 23 &&
    951            {
    952              CC_Volt_Sample_Cnt = 0;
    953              SYS_STAT.Bit.CC_READY = 0;
    954              CC_AD = Afe_Get_Adc(CC_HI_ADDR); 
    955              //CC_Val = (int32_t)CC_AD * 820/100; //mA (int32_t)
    956              CC_Val = (int32_t)820 * CC_AD /100; //mA (int32_t)
    957              //SYS_STAT_Last |= 0x80;
    958              //I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last); 
    959              //SYS_STAT_Last &= ~0x80;
    960              Afe_CC_1Shot_Set();
    961              if(CC_Val < -32000)
    962              {
    963                CC_Val = -32000;
    964              }
    965              else if(CC_Val > 32000)
    966              {
    967                CC_Val = 32000;
    968              }
    969              Current_Val = CC_Val;
    970              if(CC_Val < 0)
    971              {
    972                Current_Val = -CC_Val;
    973              }
    974            }
    975            //====================================2S 
    976            if(Temp_Volt_Sample_Cnt >= 210)
    977            {
    978              //V_TS2_Val = (uint16_t)((uint32_t)(382 * ((uint16_t)adcval <<8 | tmpval))/1000);//mV
    979              V_TS2_Val = Afe_Get_Adc(TS2_HI_ADDR) &0x3FFF ;
    980              V_TS2_Val = (uint16_t)(((uint32_t)382 * V_TS2_Val /1000));  //mV
    981              V_TS2_Val = (uint16_t)(((uint32_t)1024 * V_TS2_Val /3300));  //mV
    982              //R_TS2_Val = (uint16_t)((uint32_t)10000 * V_TS2_Val)/(3300 - V_TS2_Val); 
    983            }
    984            //=====================================================================================
    985            
    986          }
    987           
    988          //==========================================================================
    989          /*
    990            turn on condition  :    >4.0V && deltaVolt >200mV
    991            turn off condition :   over charge assert the charging protection
    992          */ 
    993          void CellBal_Cntrl(void)
    994          {
    995            uint8_t i = 0;
    996            if(WorkMode == CHARGE_MODE)
    997            {
    998              if(Cell_Balance_Delay_t >= 100)
    999              {
   1000                Cell_Balance_Delay_t = 0;
   1001                if((Cell_Volt_Max >= CELLBALANCE_BEGIN_VAL) && ((Cell_Volt_Max - Cell_Volt_Min) >= CELLBALANCE_DELTA_VAL) && !Bits_flag.Bit.ChgOv && !Bits_flag.Bit.ChgTemp && !Bits_flag.Bit.ChgCurOv)
   1002                {
   1003                  CellBal_Cntrl_Lock = 1;
   1004                  for(i =0; i <10; i++)
   1005                  {
   1006                    if(Cell_Volt[i] > CELLBALANCE_BEGIN_VAL && ((Cell_Volt[i] - Cell_Volt_Min) >= CELLBALANCE_DELTA_VAL))
   1007                    {   
   1008                      CellBalance_Cur_Selct |= (0x0001 << i); 
   1009                    }
   1010                    else
   1011                    {
   1012                      CellBalance_Cur_Selct &= ~(0x0001 << i);
   1013                    }
   1014                  }  
   1015                  CellBalance_Selct = 0x0000;
   1016                  //===================================
   1017                  for(i =0; i <10; i++ )
   1018                  {
   1019                    if((CellBalance_Cur_Selct &(0x0001 <<i)))
   1020                    {
   1021                      CellBalance_Selct |=(0x0001 <<i);
   1022                      if(4 != i)
   1023                      {
   1024                        i +=1; 
   1025                      }
   1026                    }  
   1027                  } 
   1028                  Afe_CellBalance_Enable(CellBalance_Selct);
   1029                } 
   1030                else if(CellBal_Cntrl_Lock ==1)
   1031                { 
   1032                  Afe_CellBalance_Disable();
   1033                } 
   1034              }
   1035            }
   1036            else if(CellBal_Cntrl_Lock ==1)
   1037            {
   1038                Afe_CellBalance_Disable();
   1039            }
   1040          }
   1041           
   1042          //==========================================================================
   1043          /*
   1044          1、充电模式：有异常时，电流异常（LED1及LED2闪烁，周期为1秒），温度异常（LED1、LED2及LED3闪烁，周期为1秒）
   1045                       无异常时，低节电量LED常亮，高节电量的LED闪烁，T = 1s
   1046                          0%----30%     LED1闪烁
   1047                          30%---65%     LED1常亮、LED2闪烁
   1048                          65%---90%     LED1、LED2常亮、LED3闪烁
   1049                          90%           LED全亮
   1050                       
   1051          2、放电模式：有异常时，电流异常（LED1及LED2闪烁，周期为1秒），温度异常（LED1、LED2及LED3闪烁，周期为1秒）
   1052                       无异常时，显示当前电量
   1053                          15%           LED1闪烁 1Hz
   1054                          15%---35%     LED1常亮
   1055                          35%---85%     LED1、LED2常亮
   1056                          85%           LED全亮
   1057          */  
   1058          void LedShow_Cntrl(void)
   1059          {
   1060            // soc 显示
   1061            // 异常后，报警5s后，熄灭
   1062            if(WorkMode == IDLE_MODE)
   1063            {
   1064              LED1_OFF();
   1065              LED2_OFF(); 
   1066              LED3_OFF(); 
   1067            }
   1068            else
   1069            { 
   1070              if(WorkMode == CHARGE_MODE)
   1071              {
   1072                /*
   1073                if(Bits_flag.Bit.ChgCurOv)
   1074                {
   1075                  LED1_OFF();
   1076                  if(LedFlash_t >= 50)
   1077                  {
   1078                    LED2_XOR();
   1079                    LedFlash_t = 0;
   1080                  } 
   1081                  LED3_OFF();  
   1082                }
   1083                else if(Bits_flag.Bit.ChgTemp)
   1084                {
   1085                  LED1_OFF();
   1086                  LED2_OFF();  
   1087                  if(LedFlash_t >= 50)
   1088                  {
   1089                    LED3_XOR();
   1090                    LedFlash_t = 0;
   1091                  } 
   1092                }
   1093                else */
   1094                if(Bits_flag.Bit.ChgOv )//|| SocCalc.soc_rt >= 90)
   1095                {
   1096                  LED1_OFF();
   1097                  LED2_OFF(); 
   1098                  LED3_ON(); 
   1099                } 
   1100                else if(SocCalc.soc_rt >= 80)  // 65%---90%     LED1、LED2常亮、LED3闪烁  
   1101                {
   1102                  LED1_OFF();
   1103                  if(LedFlash_t < 50)
   1104                  {
   1105                    LED2_ON();
   1106                    LED3_OFF(); 
   1107                  } 
   1108                  else if(LedFlash_t < 100)
   1109                  {
   1110                    LED2_OFF();
   1111                    LED3_ON();
   1112                  }
   1113                  else
   1114                  {
   1115                    LedFlash_t = 0;
   1116                  } 
   1117                }
   1118                else if(SocCalc.soc_rt >= 45 )//30%---65%     LED1常亮、LED2闪烁
   1119                {
   1120                  if(LedFlash_t < 50)
   1121                  {
   1122                    LED1_ON();
   1123                    LED2_OFF(); 
   1124                  } 
   1125                  else if(LedFlash_t < 100)
   1126                  {
   1127                    LED1_OFF();
   1128                    LED2_ON();
   1129                  }
   1130                  else
   1131                  {
   1132                    LedFlash_t = 0;
   1133                  } 
   1134                  LED3_OFF();
   1135                }
   1136                else //0%----30%     LED1闪烁
   1137                { 
   1138                  if(LedFlash_t >= 50)
   1139                  {
   1140                    LedFlash_t = 0;
   1141                    LED1_XOR();
   1142                  } 
   1143                  LED2_OFF();
   1144                  LED3_OFF();
   1145                } 
   1146              } 
   1147              else if(WorkMode == DISCHARGE_MODE)
   1148              { 
   1149                /*
   1150                if(Bits_flag.Bit.DisCurOv  || Bits_flag.Bit.DisCurShort)
   1151                {
   1152                  LED1_OFF();
   1153                  if(LedFlash_t >= 50)
   1154                  {
   1155                    LED2_XOR();
   1156                    LedFlash_t = 0;
   1157                  } 
   1158                  LED3_OFF();  
   1159                }
   1160                else if(Bits_flag.Bit.DisTemp)
   1161                {
   1162                  LED1_OFF();
   1163                  LED2_OFF();  
   1164                  if(LedFlash_t >= 50)
   1165                  {
   1166                    LED3_XOR();
   1167                    LedFlash_t = 0;
   1168                  } 
   1169                }
   1170                else */
   1171                if(Bits_flag.Bit.DisOv)
   1172                {
   1173                  LED1_OFF();
   1174                  LED2_OFF(); 
   1175                  LED3_OFF(); 
   1176                }
   1177                else if(SocCalc.soc_rt >= 85)  //85%           LED全亮
   1178                {
   1179                  LED1_OFF();
   1180                  LED2_OFF();
   1181                  LED3_ON();
   1182                }
   1183                else if(SocCalc.soc_rt >= 35) //35%---85%     LED1、LED2常亮
   1184                {
   1185                  LED1_OFF();
   1186                  LED2_ON();
   1187                  LED3_OFF();
   1188                }
   1189                else if(SocCalc.soc_rt >= 15) //15%---35%     LED1常亮
   1190                {
   1191                  LED1_ON();
   1192                  LED2_OFF();
   1193                  LED3_OFF();
   1194                }
   1195                else                             //15%           LED1闪烁 1Hz
   1196                {
   1197                  if(LedFlash_t >= 100)
   1198                  {
   1199                    LedFlash_t = 0;
   1200                    LED1_XOR();
   1201                  }
   1202                  LED2_OFF();
   1203                  LED3_OFF();
   1204                } 
   1205              }
   1206            }
   1207          }
   1208          
   1209          void LedShow_WorkMode(void)
   1210          {
   1211            if(WorkMode == IDLE_MODE)
   1212            {
   1213              //LED1_XOR();
   1214              LED1_ON();
   1215              LED2_OFF(); 
   1216              LED3_OFF(); 
   1217            }
   1218            else if(WorkMode == CHARGE_MODE)
   1219            {
   1220              LED1_OFF();
   1221              //LED2_XOR(); 
   1222              LED2_ON(); 
   1223              LED3_OFF(); 
   1224            }
   1225            else if(WorkMode == DISCHARGE_MODE)
   1226            {
   1227              LED1_OFF();
   1228              LED2_OFF(); 
   1229              LED3_ON(); 
   1230              //LED3_XOR(); 
   1231            }
   1232          }
   1233          //==========================================================================
   1234          void LowPower_Entry_MCU_Set(void)
   1235          {   
   1236            static uint8_t LowPower_Entry_Exit_Cnt = 0;
   1237            if(WorkMode == IDLE_MODE && (LowPower_Entry_Delay_t >= 500 || LowPower_MCU_Entry_Flag == 1))
   1238            { 
   1239              //if(LowPower_MCU_Entry_Flag == 0)
   1240              {
   1241                 Afe_ADC_Disable(); Afe_Temp_Disable();  
   1242              }
   1243              CLK_PCKENR2 = CLK_PCKENR2_AWU;
   1244              AWU_Init(AWU_TIMEBASE_1S); 
   1245              CLK->ICKR |= CLK_ICKR_SWUAH;
   1246              FLASH->CR1 |= 0x04;	  
   1247              EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
   1248              ClrWdt();  
   1249              LowPower_MCU_Entry_Flag = 1; 
   1250              halt(); 
   1251              ClrWdt();  
   1252              Delay_ms(5); 
   1253              //======================================
   1254              if(LowPower_MCU_Entry_Flag == 1)
   1255              {
   1256                if((LowPower_Entry_Exit_Cnt ++) >= 100) 
   1257                {
   1258                  LowPower_MCU_Entry_Flag = 0; 
   1259                  LowPower_Entry_Exit_Cnt = 0; 
   1260                }
   1261              }
   1262              else
   1263              {
   1264                LowPower_Entry_Exit_Cnt = 0; 
   1265                CLK_PCKENR2 &= ~CLK_PCKENR2_AWU; 
   1266                CLK->ICKR &= ~CLK_ICKR_SWUAH; 
   1267                Afe_ADC_Enable(); Afe_Temp_Enable();Delay_ms(10); 
   1268              } 
   1269              //=============================================
   1270              LowPower_Entry_Delay_t = 0; 
   1271            }
   1272          } 
   1273          //==========================================================================
   1274          void LowPower_Entry_MCU_Set_Backup(void)
   1275          {   
   1276            if(WorkMode == IDLE_MODE && LowPower_Entry_Delay_t >= 600 && !Bits_flag.Bit.DisOv)
   1277            { 
   1278              Afe_ADC_Disable();
   1279              Afe_Temp_Disable();  
   1280              CLK_PCKENR2 = CLK_PCKENR2_AWU;
   1281              AWU_Init(AWU_TIMEBASE_12S);//AWU_TIMEBASE_30S); 
   1282              CLK->ICKR |= CLK_ICKR_SWUAH;
   1283              FLASH->CR1 |= 0x04;	  
   1284              EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
   1285              LowPower_MCU_Entry_Flag = 1; 
   1286              halt(); 
   1287               
   1288              LowPower_Entry_Delay_t = 0;
   1289              
   1290              Delay_ms(100); 
   1291              CLK_PCKENR2 &= ~CLK_PCKENR2_AWU; 
   1292              CLK->ICKR &= ~CLK_ICKR_SWUAH; 
   1293              //LowPower_Exit_MCU_Set(); 
   1294              Afe_ADC_Enable(); 
   1295              Afe_Temp_Enable(); 
   1296            }
   1297          }  
   1298          void LowPower_Powerdown_Enter(void)
   1299          {
   1300            uint8_t i = 0;
   1301            if(PowerOff_Delay_t >= PowerOff_Delay_t_SET)
   1302            {
   1303              while(1)
   1304              {   
   1305                Afe_EnterShipMode(); 
   1306                if((i ++) < 100)
   1307                { 
   1308                  ClrWdt();
   1309                  Delay_ms(50);
   1310                }
   1311                else
   1312                {
   1313                  Delay_ms(1000);
   1314                }
   1315              } 
   1316            }  
   1317          }
   1318          //==============================================================================
   1319          void LowPower_Cntrl(void)
   1320          {  
   1321            if(WorkMode == IDLE_MODE)
   1322            {
   1323              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1324              {
   1325                LowPower_Powerdown_Enter();  
   1326              } 
   1327            }
   1328            else
   1329            {
   1330              PowerOff_Delay_t = 0;
   1331            }
   1332          }
   1333          //==============================================================================
   1334          void LowPower_Cntrl_1(void)
   1335          { 
   1336            if(LowPower_MCU_Entry_Flag ==0)//(0)//
   1337            {
   1338              if(!SYS_CTRL1.Bit.ADC_EN) 
   1339              { 
   1340                Afe_ADC_Enable(); 
   1341              }
   1342              if(!SYS_CTRL1.Bit.TEMP_SEL )
   1343              {
   1344                Afe_Temp_Enable();
   1345              }
   1346            }
   1347            if(WorkMode == CHARGE_MODE)
   1348            {
   1349              return;
   1350            }
   1351            if(Bits_flag.Bit.DisOv)  
   1352            {
   1353              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1354              {
   1355                LowPower_Powerdown_Enter();  
   1356              }
   1357            }
   1358            else
   1359            {
   1360              LowPower_Entry_MCU_Set();  
   1361            }
   1362          }
   1363          //==============================================================================
   1364          void LowPower_Cntrl_Backup(void)
   1365          { 
   1366            if(LowPower_MCU_Entry_Flag ==0)//(0)//
   1367            {
   1368              if(!SYS_CTRL1.Bit.ADC_EN) 
   1369              { 
   1370                Afe_ADC_Enable(); 
   1371              }
   1372              if(!SYS_CTRL1.Bit.TEMP_SEL )
   1373              {
   1374                Afe_Temp_Enable();
   1375              }
   1376            }
   1377            if(WorkMode == CHARGE_MODE)
   1378            {
   1379              return;
   1380            }
   1381            if(Bits_flag.Bit.DisOv)  
   1382            {
   1383              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1384              {
   1385                LowPower_Powerdown_Enter();  
   1386              }
   1387            }
   1388            else
   1389            {
   1390              LowPower_Entry_MCU_Set();  
   1391            }
   1392          }
   1393          
   1394          uint8_t CRC8_Caculate(uint8_t *ptr,uint8_t len)
   1395          {
   1396            uint8_t i;
   1397          	
   1398            uint8_t crc = 0;
   1399          
   1400            uint8_t key = 0x07; //_Poly_07
   1401            while((len--) != 0)
   1402          	
   1403            {
   1404          		
   1405              for(i = 0x80; i != 0; i /= 2)
   1406          		
   1407              {
   1408          			
   1409                if((crc & 0x80) != 0)
   1410          			
   1411                {
   1412          				
   1413                  crc *= 2;
   1414          				
   1415                  crc ^= key;
   1416          			
   1417                }
   1418          			
   1419                else
   1420          				
   1421                {
   1422                  crc *= 2;
   1423          
   1424                }
   1425          			
   1426                if((*ptr & i) != 0)
   1427          				
   1428                {
   1429                  crc ^= key;
   1430                }
   1431          		
   1432              }
   1433          		
   1434              ptr++;
   1435          	
   1436            }
   1437            return (crc);
   1438          
   1439          } 
   1440          
   1441          
   1442          //==========================================================================
   1443          /*
   1444          In a single-byte read transaction, the CRC is calculated after the second start and uses the slave address and data byte.
   1445          */
   1446          void I2C_Read(uint8_t addr,uint8_t *data)//slave device address 0x18
   1447          {      
   1448            uint16_t OverTimeDelay = OverTimeDelay_SET;
   1449            uint8_t CRC_ReData,Retry_Cnt = 5; 
   1450            Buf[0] = SLAVE_ADDR; 
   1451            while(Retry_Cnt > 0)
   1452            {
   1453              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图）  
   1454              disableInterrupts(); 
   1455              I2C->CR2 |= 0x04; //ack使能 
   1456              //=============================发送起始位 I2C_Start() 
   1457              while(I2C->SR3 & 0x02){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;I2C_COM_ERROR_Flag = 1;break;}}    // 等待总线空闲   检测i2c-SR3 busy位        
   1458              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位  
   1459              
   1460              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1461              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1462              while(!(I2C->SR1 & 0x01));  //等待START发送完 E5  
   1463              I2C->DR = (SLAVE_ADDR << 1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1464              
   1465              while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;break;}}// I2C_COM_ERROR_Flag = 1; //等特7位器件地址发送完并且收到ack,ADDR置1    
   1466              //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1467              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1468              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1469              I2C->SR3; //然后读SR3 清  ADDR 
   1470              
   1471              if(I2C_COM_ERROR_Flag == 0)
   1472              {
   1473                //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1474                I2C->DR = (u8)(addr);      
   1475                //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1476                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1477                //在发送地址和清除ADDR 之后，I2C接口进入主设备接收模式。以下见stm8s中文数据手册P252（图97主设备接收模式接收序列图）  
   1478                
   1479                //=============================I2C_Start()        
   1480                I2C->CR2 |= 0x01;  //产生重复起始位   
   1481                //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1482                while(!(I2C->SR1 & 0x01));  //等待START发送完     
   1483                //ADDRESS (接收)   
   1484                I2C->DR = (SLAVE_ADDR <<1) + 0x01;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)      
   1485                //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除改位   
   1486                
   1487                while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;break;}} // I2C_COM_ERROR_Flag = 1;//等特7位器件地址发送完并且收到ack,ADDR置1    
   1488                //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1  
   1489                I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1490                I2C->SR3; //然后读SR3 清  ADDR   
   1491                   Buf[0] = 0x31;  Buf[1] = 0;     Buf[2] = 0;           
   1492                //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1493                while(!(I2C->SR1 & 0x40));                                        
   1494                Buf[1] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)                                               
   1495                 
   1496               
   1497                
   1498                //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1499                while(!(I2C->SR1 & 0x40));                                        
   1500                Buf[2] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)  
   1501                  //EV7_1 ：RxNE=1 ，读DR寄存器清除该标志。设置ACK=0和STOP 请求。(在接收最后一个字节前)     
   1502                I2C->SR3;
   1503                I2C->DR; 
   1504                I2C->CR2 &= ~0x04; //ack使能  
   1505                I2C->CR2 |= 0x02;  //停止位产生stop      
   1506                 
   1507                enableInterrupts(); 
   1508                //while((I2C->CR2 & I2C_CR2_STOP));
   1509                CRC_ReData = CRC8_Caculate(Buf,2);
   1510                /*Uart_SendByte(0x11);
   1511                Uart_SendByte(Buf[0]);
   1512                Uart_SendByte(Buf[1]);
   1513                Uart_SendByte(Buf[2]);*/
   1514                if(CRC_ReData == Buf[2])
   1515                {
   1516                  *data = Buf[1];
   1517                  OverTimeDelay = 200; while((OverTimeDelay --) >0);
   1518                  return;
   1519                }
   1520              }
   1521              I2C_COM_ERROR_Flag = 0;
   1522              Retry_Cnt -= 1;
   1523            }
   1524            enableInterrupts(); 
   1525            //Uart_SendByte(0xDD);
   1526            //Uart_SendByte(0xDD);
   1527          }
   1528          
   1529          //==========================================================================
   1530          /*
   1531          In a single-byte write transaction, the CRC is calculated over the slave address, register address, and data.
   1532          */
   1533          void I2C_Write(uint8_t addr,uint8_t data )
   1534          {     
   1535            uint8_t Write_Retry_Cnt = 5,CRC_data = 0;
   1536            uint16_t OverTimeDelay = OverTimeDelay_SET;
   1537            Buf[0] = SLAVE_ADDR <<1 ;
   1538            Buf[1] = addr;
   1539            Buf[2] = data;
   1540            CRC_data = CRC8_Caculate(Buf,3);//slave_addr + reg_addr + data + CRC
   1541            I2C_COM_ERROR_Flag =0;
   1542            
   1543            while(Write_Retry_Cnt > 0)
   1544            { 
   1545              disableInterrupts();
   1546              I2C_CR2 |= 0x04;
   1547              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1548              //=============================发送起始位 I2C_Start() 
   1549              while(I2C->SR3 & 0x02) {if((OverTimeDelay --) == 0){OverTimeDelay = 500;I2C_COM_ERROR_Flag = 1;break;}}//   // 等待总线空闲   检测i2c-SR3 busy位
   1550              //I2C_CR2 &= ~0x04;        
   1551              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位    
   1552              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1553              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1554              while(!(I2C->SR1 & 0x01));// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}} //等待START发送完 E5  
   1555              
   1556              I2C->DR = (SLAVE_ADDR <<1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1557              
   1558              OverTimeDelay = 100; while((OverTimeDelay --) >0);OverTimeDelay = OverTimeDelay_SET;
   1559              //while(!(I2C->SR1 & 0x02 == 0x02)) {if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;I2C_COM_ERROR_Flag = 0;break;}} // //等特7位器件地址发送完并且收到ack,ADDR置1    
   1560              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1561              I2C->SR1;   
   1562              I2C->SR3; //然后读SR3 清  ADDR 
   1563              if(I2C_COM_ERROR_Flag == 0)
   1564              {
   1565                //I2C_CR2 |= 0x04;
   1566                //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1567                I2C->DR = (u8)(addr);      
   1568                //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1569                while(!(I2C->SR1 & 0x84));//84//0x80  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1570                 
   1571                //============================= 发送数据  
   1572                I2C->DR = data;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)    
   1573                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1574                //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1575                
   1576                //============================= 发送数据  
   1577                I2C->DR = CRC_data;    
   1578                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1579                //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1580                
   1581                I2C->DR;  //清除I2C_SR2的BTF位
   1582                I2C->CR2 |= 0x02;  //停止位产生stop  //*注意： 发送停止位时，必须先清除I2C_SR2的BTF位  
   1583                
   1584                enableInterrupts();
   1585                OverTimeDelay = 200; while((OverTimeDelay --) >0);
   1586                if(I2C_COM_ERROR_Flag == 0)
   1587                {  
   1588                  return;
   1589                }
   1590              }
   1591              I2C_COM_ERROR_Flag = 0;
   1592              Write_Retry_Cnt -= 1; 
   1593            } 
   1594            enableInterrupts();
   1595            //Uart_SendByte(0xCC);
   1596            //Uart_SendByte(0xCC);
   1597          }
   1598           
   1599          void I2C_Read_Backup(uint8_t addr,uint8_t *data)//slave device address 0x18
   1600          {      
   1601            uint16_t OverTimeDelay = 50;
   1602            uint8_t CRC_ReData,Retry_Cnt = 5; 
   1603            Buf[0] = SLAVE_ADDR; 
   1604            while(Retry_Cnt > 0)
   1605            {
   1606              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1607              
   1608              I2C->CR2 |= 0x04; //ack使能 
   1609              //=============================发送起始位 I2C_Start() 
   1610              while(I2C->SR3 & 0x02);//{if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}    // 等待总线空闲   检测i2c-SR3 busy位        
   1611              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位  
   1612              
   1613              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1614              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1615              while(!(I2C->SR1 & 0x01));  //等待START发送完 E5  
   1616              I2C->DR = (SLAVE_ADDR << 1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1617              
   1618              while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1619              //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1620              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1621              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1622              I2C->SR3; //然后读SR3 清  ADDR 
   1623              
   1624              //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1625              I2C->DR = (u8)(addr);      
   1626              //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1627              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1628              //在发送地址和清除ADDR 之后，I2C接口进入主设备接收模式。以下见stm8s中文数据手册P252（图97主设备接收模式接收序列图）  
   1629              
   1630              //=============================I2C_Start()        
   1631              I2C->CR2 |= 0x01;  //产生重复起始位   
   1632              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1633              while(!(I2C->SR1 & 0x01));  //等待START发送完     
   1634              //ADDRESS (接收)   
   1635              I2C->DR = (SLAVE_ADDR <<1) + 0x01;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)      
   1636              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除改位   
   1637              
   1638            while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1639            //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1  
   1640              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1641              I2C->SR3; //然后读SR3 清  ADDR   
   1642                 Buf[0] = 0x31;  Buf[1] = 0;     Buf[2] = 0;           
   1643              //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1644              while(!(I2C->SR1 & 0x40));                                        
   1645              Buf[1] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)                                               
   1646               
   1647             
   1648              
   1649              //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1650              while(!(I2C->SR1 & 0x40));                                        
   1651              Buf[2] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)  
   1652                //EV7_1 ：RxNE=1 ，读DR寄存器清除该标志。设置ACK=0和STOP 请求。(在接收最后一个字节前)     
   1653              I2C->SR3;
   1654              I2C->DR; 
   1655              I2C->CR2 &= ~0x04; //ack使能  
   1656              I2C->CR2 |= 0x02;  //停止位产生stop      
   1657               
   1658              //while((I2C->CR2 & I2C_CR2_STOP));
   1659              CRC_ReData = CRC8_Caculate(Buf,2);
   1660              /*Uart_SendByte(0x11);
   1661              Uart_SendByte(Buf[0]);
   1662              Uart_SendByte(Buf[1]);
   1663              Uart_SendByte(Buf[2]);*/
   1664              if(CRC_ReData == Buf[2])
   1665              {
   1666                *data = Buf[1];
   1667                OverTimeDelay =100; while((OverTimeDelay --) >0);
   1668                return;
   1669              }
   1670              Retry_Cnt -= 1;
   1671            } 
   1672            //Uart_SendByte(0xAA);
   1673          }
   1674          
   1675          void I2C_Write_Backup(uint8_t addr,uint8_t data )
   1676          {     
   1677            uint8_t Write_Retry_Cnt = 5,CRC_data = 0;
   1678            uint16_t OverTimeDelay = 50;
   1679            Buf[0] = SLAVE_ADDR <<1 ;
   1680            Buf[1] = addr;
   1681            Buf[2] = data;
   1682            CRC_data = CRC8_Caculate(Buf,3);//slave_addr + reg_addr + data + CRC
   1683            
   1684            while(Write_Retry_Cnt > 0)
   1685            {
   1686              I2C_CR2 |= 0x04;
   1687              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1688              //=============================发送起始位 I2C_Start() 
   1689              while(I2C->SR3 & 0x02);// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}}   // 等待总线空闲   检测i2c-SR3 busy位
   1690              //I2C_CR2 &= ~0x04;        
   1691              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位    
   1692              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1693              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1694              while(!(I2C->SR1 & 0x01));// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}} //等待START发送完 E5  
   1695              
   1696              I2C->DR = (SLAVE_ADDR <<1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1697              while(!(I2C->SR1 & 0x02 == 0x02)) {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1698              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1699              I2C->SR1;   
   1700              I2C->SR3; //然后读SR3 清  ADDR 
   1701              
   1702              //I2C_CR2 |= 0x04;
   1703              //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1704              I2C->DR = (u8)(addr);      
   1705              //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1706              while(!(I2C->SR1 & 0x84));//84//0x80  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1707               
   1708              //============================= 发送数据  
   1709              I2C->DR = data;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)    
   1710              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1711              //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1712              
   1713              //============================= 发送数据  
   1714              I2C->DR = CRC_data;    
   1715              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1716              //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1717              
   1718              I2C->DR;  //清除I2C_SR2的BTF位
   1719              I2C->CR2 |= 0x02;  //停止位产生stop  //*注意： 发送停止位时，必须先清除I2C_SR2的BTF位  
   1720              
   1721              OverTimeDelay =100; while((OverTimeDelay --) >0);
   1722              if(I2C_COM_ERROR_Flag == 1)
   1723              {
   1724                return;
   1725              }
   1726              I2C_COM_ERROR_Flag = 0;
   1727              Write_Retry_Cnt -= 1; 
   1728            }  
   1729          }
   1730           
   1731          
   1732          void Var_Init(void)
   1733          { 
   1734            uint8_t i = 0;
   1735            
   1736            
   1737             
   1738            ChgExchangeMode_Cnt = 100;
   1739            DisExchangeMode_Cnt = 0;
   1740            IdleExchangeMode_Cnt = 0;
   1741            for(i =0; i <10; i++)
   1742            {
   1743              Adc_value[i] = 0;
   1744              Cell_Volt[i] = 0;
   1745            }
   1746            Temp_Volt_Sample_Cnt = 0;
   1747            Cell_Volt_Sample_Cnt = 0;
   1748            I2C_COM_ERROR_Flag = 0;
   1749            Current_Val = 0;
   1750            ADCOffset_Val = 0;
   1751            CC_Val = 0;
   1752            Cell_Volt_Tol = 0;
   1753            Cell_Volt_Avg = 0;
   1754            Cell_Volt_Max = 0;
   1755            Cell_Volt_Min = 0; 
   1756            ADCGain_Val = 0; 
   1757            Pack_Volt = 0;
   1758            Temp_Val = 0;
   1759            V_TS2_Val = 0; 
   1760            R_TS2_Val = 0; 
   1761            
   1762            SYS_STAT_Last = 0;
   1763            CELLBAL1_Last = 0;
   1764            CELLBAL2_Last = 0;
   1765            SYS_CTRL1_Last = 0;
   1766            SYS_CTRL2_Last = 0; 
   1767            PROTECT1_Last = 0;
   1768            PROTECT2_Last = 0;
   1769            PROTECT3_Last = 0;
   1770            OV_TRIP_Last = 0;
   1771            UV_TRIP_Last = 0;
   1772            CC_CFG_Last = 0;
   1773            
   1774            
   1775            ChgOv_t = 0;
   1776            ChgCurOv_t = 0;
   1777            ChgCurOv_Re_t = 0;  
   1778            DisOv_t = 0;
   1779            DisCurOv_t = 0;
   1780            DisCurOv_t1 = 0;
   1781            DisCurOv_t2 = 0;
   1782            DisCurOv_Re_t = 0;
   1783            DisCurShort_Re_t = 0;
   1784            
   1785            DEVICE_XREADY_Re_t = 0;
   1786            
   1787            CellBalance_Cur_Selct = 0;  
   1788            LedFlash_t = 0;
   1789            PowerOff_Delay_t = 0;
   1790            Delay_time_t = 0;
   1791            
   1792            WorkMode = IDLE_MODE;
   1793            
   1794            SYS_STAT.Byte = 0;
   1795            
   1796            RevcComData.uintdata = 0;
   1797            Bits_flag.Byte = 0;
   1798            
   1799            SocCalc.inAh = 0;
   1800            SocCalc.inAh_bak = 0;
   1801            SocCalc.totalInAh = 0;
   1802            SocCalc.totalInAh_bak = 0;
   1803            SocCalc.outAh = 0;
   1804            SocCalc.outAh_bak = 0;
   1805            SocCalc.totalOutAh = 0;
   1806            SocCalc.totalOutAh_bak = 0;
   1807            SocCalc.curAh = 0;
   1808            SocCalc.ov_cnt = 0;
   1809            SocCalc.uv_cnt = 0;
   1810            SocCalc.stb_cnt = 0;
   1811            SocCalc.soc_rt = 0; 
   1812            
   1813             
   1814          }
   1815          
   1816          #endif

   Section sizes:

     Function/Label                Bytes
     --------------                -----
     _A_PC_ODR                        1
     _A_PD_IDR                        1
     _A_CLK_ICKR                      1
     _A_CLK_ECKR                      1
     _A_CLK_SWCR                      1
     _A_CLK_CKDIVR                    1
     CLK_PCKENR1                      1
     CLK_PCKENR2                      1
     IWDG_KR                          1
     _A_IWDG_PR                       1
     IWDG_RLR                         1
     _A_I2C_CR1                       1
     _A_I2C_CR2                       1
     _A_I2C_FREQR                     1
     I2C_CCRL                         1
     _A_I2C_CCRH                      1
     _A_I2C_TRISER                    1
     _A_UART1_SR                      1
     UART1_DR                         1
     UART1_BRR1                       1
     UART1_BRR2                       1
     _A_UART1_CR1                     1
     _A_UART1_CR2                     1
     _A_UART1_CR3                     1
     _A_TIM1_CR1                      1
     _A_TIM1_EGR                      1
     _A_TIM1_CCMR1                    1
     _A_TIM1_CCMR2                    1
     _A_TIM1_CCER1                    1
     TIM1_PSCRH                       1
     TIM1_PSCRL                       1
     TIM1_ARRH                        1
     TIM1_ARRL                        1
     TIM1_CCR1H                       1
     TIM1_CCR1L                       1
     TIM1_CCR2H                       1
     TIM1_CCR2L                       1
     _A_TIM1_BKR                      1
     _A_TIM2_CR1                      1
     _A_TIM2_IER                      1
     _A_TIM2_EGR                      1
     _A_TIM2_CCMR1                    1
     _A_TIM2_CCER1                    1
     TIM2_CNTRH                       1
     TIM2_CNTRL                       1
     _A_TIM2_PSCR                     1
     TIM2_ARRH                        1
     TIM2_ARRL                        1
     TIM2_CCR1H                       1
     TIM2_CCR1L                       1
     _A_TIM4_CR1                      1
     _A_TIM4_IER                      1
     _A_TIM4_EGR                      1
     TIM4_CNTR                        1
     _A_TIM4_PSCR                     1
     TIM4_ARR                         1
     _A_ADC_CSR                       1
     _A_ADC_CR1                       1
     _A_ADC_CR2                       1
     _A_ADC_CR3                       1
     ADC_DRH                          1
     ADC_DRL                          1
     ADC_TDRH                         1
     ADC_TDRL                         1
     PWM2_Init                       61
     PWM1_Init                       77
     ADC                             47
     ?Subroutine30                   15
     ?Subroutine4                     7
     ADConverse                     122
     SysInit                         60
     ClrWdt                          21
     PortInit                       112
     ?Subroutine39                    6
     ?Subroutine38                    9
     ?Subroutine37                    7
     ?Subroutine36                    7
     ?Subroutine43                    8
     ?Subroutine35                    7
     Uart_Model_Init                 29
     Uart_SendByte                   25
     itoa                           110
     rev                             21
     Uart_SendStr                    38
     Uart_SendData                   57
     I2C_Model_Init                  33
     Timer2Init                      41
     Timer4_Init_us                  18
     ?Subroutine22                    9
     ?Subroutine21                    9
     ?Subroutine20                   13
     Timer4_Init_ms                  18
     Timer4_Disable                  13
     Delay_us                        14
     Delay_ms                        14
     ?Subroutine19                    6
     TempCheck                      167
     ChgTemp_cnt                      1
     DisTemp_cnt                      1
     CurrentCheck                   138
     ?Subroutine31                   12
     VoltCheck                      216
     ?Subroutine8                     9
     ?Subroutine3                     9
     ??Subroutine45_0                 8
     ModeCheck_Backup                75
     ?Subroutine5                    17
     ?Subroutine1                    17
     ?Subroutine0                     8
     ?Subroutine40                   13
     Afe_CC_Disable_Lock              1
     ModeCheck                       73
     ClearStatus                    187
     ?Subroutine33                   10
     Afe_Volt_Val_Get               367
     ?Subroutine34                    8
     ?Subroutine32                    6
     CellBal_Cntrl                  197
     ?Subroutine29                   10
     ?Subroutine6                     7
     ?Subroutine2                     8
     LedShow_Cntrl                  167
     ?Subroutine28                    5
     ?Subroutine27                    9
     ?Subroutine26                    9
     LedShow_WorkMode                37
     LowPower_Entry_MCU_Set          95
     ?Subroutine25                   11
     ?Subroutine24                   14
     ?Subroutine23                   20
     LowPower_Entry_Exit_Cnt          1
     LowPower_Entry_MCU_Set_Backup   45
     LowPower_Powerdown_Enter        48
     LowPower_Cntrl                  20
     LowPower_Cntrl_1                45
     LowPower_Cntrl_Backup           45
     CRC8_Caculate                   66
     ?Subroutine17                    5
     ?Subroutine16                    5
     ?Subroutine13                    6
     ?Subroutine10                    2
     ??Subroutine44_0                 6
     ?Subroutine42                    9
     ?Subroutine7                    10
     I2C_Read                       155
     ?Subroutine18                   11
     ?Subroutine15                    7
     ?Subroutine41                    7
     ?Subroutine14                   11
     ?Subroutine12                   21
     ?Subroutine11                   16
     I2C_Write                      116
     ?Subroutine9                    32
     I2C_Read_Backup                137
     I2C_Write_Backup               101
     Var_Init                       249
     ?<Constant "abcdef">             7
     ?<Constant {0}>                 20
     ?<Constant "0x">                 3

 
    25 bytes in section .near.bss
    64 bytes in section .near.noinit
    30 bytes in section .near.rodata
 4 117 bytes in section .near_func.text
 
 4 117 bytes of CODE  memory
    30 bytes of CONST memory
    25 bytes of DATA  memory (+ 64 bytes shared)

Errors: none
Warnings: 1
