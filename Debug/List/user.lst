###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM811/Apr/2016  19:24:52 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \user.c                                                  #
#    Command line =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \user.c -e --enable_multibytes -Ohz --debug              #
#                    --code_model small --data_model medium -o                #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\ --dlib_config "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /user/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79 #
#                    _A0/user/src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/user/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_ #
#                    C-version\CH79_A0/addon/\ -I                             #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/addon/s #
#                    rc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /addon/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version #
#                    \CH79_A0/sys/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/sys/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C #
#                    -version\CH79_A0/sys/src/\ -I                            #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/\   #
#                    -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/ #
#                    src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A #
#                    0/lib/inc/\ --vregs 16                                   #
#    List file    =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\user.lst                                             #
#    Object file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\user.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src\user.c
      1          
      2          #include "stm8s.h" 
      3          #include "user.h"
      4          #include "macro_def.h"
      5          #include "iostm8s003f3.h"
      6          #include "bq769x0.h"
      7          #include "string.h"
      8          //==================================================================
      9          //==================================================================
     10          //==================================================================
     11          #if 1
     12          /*
     13          void PWM2_Init(void)
     14          { 
     15              CLK_PCKENR1 |= 0xA0; 
     16              TIM2_CR1 =0;              //关闭TIM2
     17              TIM2_IER = 0; 
     18              TIM2_PSCR = 0;  
     19              TIM2_ARRH = 0x07;
     20              TIM2_ARRL = 0xCF;         //16M/(1999+1)=8KHz   //2MHz/(1999+1) = 1KHz 
     21              TIM2_CR1 |= 0x80;         //使能ARP,边沿对齐，向上计数
     22              TIM2_EGR |= 0x01;         //更新TIM1，使PSC有效
     23              TIM2_EGR |= 0x20;         //重新初始化TIM1 
     24              TIM2_CCR1H =0;           
     25              TIM2_CCR1L =0; 
     26              TIM2_CCMR1 =0X68;         //配置TIM2_CH1为PWM1模式输出 
     27              TIM2_CCER1 =0x01;         //Enable TIM2_CH1 channel 
     28              TIM2_CR1 |= 0x01;         //使能TIM2 
     29          }
     30          //==================================================================
     31          //==================================================================
     32          void PWM1_Init(void)
     33          {
     34              CLK_PCKENR1 |= 0x80;
     35              TIM1_CR1 &= ~0x01;      //关闭TIM1 
     36              TIM1_PSCRH = 0;
     37              TIM1_PSCRL = 0;         //不分频2MHz 
     38              TIM1_ARRH = 0x07;
     39              TIM1_ARRL = 0xCF;      //2MHz/(1999+1) = 1KHz 
     40              TIM1_CR1 |= 0x80;      //使能ARP,边沿对齐，向上计数
     41              TIM1_EGR |= 0x01;      //更新TIM1，使PSC有效
     42              TIM1_EGR |= 0x20;      //重新初始化TIM1 
     43              
     44              TIM1_CCR1H = 0;
     45              TIM1_CCR1L = 0; 
     46              TIM1_CCMR1 = 0x68;       //配置TIM1_CH1为PWM1模式输出
     47              TIM1_CCER1 |= 0x01;      //Enable TIM1_CH1 channel
     48              
     49              TIM1_CCR2H = 0;
     50              TIM1_CCR2L = 0;
     51              TIM1_CCMR2 = 0x68;       //配置TIM1_CH2为PWM1模式输出
     52              TIM1_CCER1 |= 0x10;      //Enable TIM1_CH2 channel
     53              
     54              //TIM1_CCR3H = 0x07;
     55              //TIM1_CCR3L = 0xE6;       //占空比50% 
     56              //TIM1_CCMR3 = 0x68;       //配置TIM1_CH3为PWM1模式输出
     57              //TIM1_CCER2 |= 0x01;      //使能TIM1_CH3通道
     58              
     59              //TIM1_CCR4H = 0x03;
     60              //TIM1_CCR4L = 0xE6;       //占空比50%
     61              //TIM1_CCMR4 = 0x68;       //配置TIM1_CH4为PWM1模式输出 
     62              //TIM1_CCER2 |= 0x10;      //Enable TIM1_CH4 channel 
     63              
     64              TIM1_BKR |= 0x80;          //
     65              TIM1_CR1 |= 0x01;          //使能TIM1 
     66          }
     67          */
     68          //==================================================================
     69          //==================================================================
     70          uint16_t ADC(int channel)
     71          {
     72              unsigned int value =0;
     73              unsigned char tempH,tempL; 
     74              //CLK_PCKENR2 |=0x08; 
     75              ADC_CSR = channel;                // 清除EOC转换结束标志, select channel
     76              nop();  nop(); nop(); nop(); 
     77              ADC_CR1 |= 0x01;                  // 开始单次转换 
     78              nop(); nop(); nop(); nop(); nop();
     79              nop(); nop(); nop(); nop(); nop();
     80              ADC_CR1 |= 0x01;                  // 开始单次转换
     81              nop(); nop(); nop(); nop();
     82              nop(); nop(); nop(); nop();
     83              while(!(ADC_CSR & 0x80))nop();    // 等待单次转换完成 
     84              tempL = ADC_DRL;                  //先 读低8位
     85              tempH = ADC_DRH;                  // 再读高8位，设置数据左对齐
     86              value=(tempH<<8)|tempL;
     87              ADC_CSR &= ~(0x80);               // 清除EOC转换结束标志  
     88              ADC_CR1 &= ~(0x01); 
     89              return(value);  
     90          }
     91          //==================================================================
     92          //==================================================================
     93          uint16_t ADConverse(unsigned char channel)
     94          { 
     95              unsigned int value=0;
     96              unsigned int max_value =0;
     97              unsigned int min_value =0xEFFF;
     98              unsigned char i;  
     99              CLK_PCKENR2 |=0x08;  
    100              for(i =0;i <100;i++)
    101              {
    102                nop();nop();
    103              }
    104              for(i=0;i<18;i++)
    105              {
    106                Adc_value[i] = ADC(channel); 
    107              }
    108              for(i =0;i<18;i++)
    109              {
    110                value +=Adc_value[i];
    111                if(max_value <Adc_value[i])
    112                  max_value =Adc_value[i];
    113                 
    114                if(min_value >Adc_value[i])
    115                  min_value =Adc_value[i];
    116              }
    117              value =value -max_value -min_value;
    118              value >>= 4; 
    119              CLK_PCKENR2 &=~(0x08); 
    120              return value; 
    121          }
    122          //================================================================================
    123          //==================================================================
    124          void SysInit(void)
    125          { 
    126              //-------system clock                                           
    127              CLK_ECKR &= ~0x01;  // external RC Disable                                              
    128              CLK_ICKR = 0x01;    // internal RC enable
    129              while(!(CLK_ICKR & 0x02)); 
    130              CLK_SWCR = 0;       // 禁止时钟切换及相关中断
    131              CLK_CKDIVR = 0x02;  // 主频为Fmaster为Fhsi：16MHz, Fcpu为4MHz  0.25us
    132              //CLK_PCKENR1 = 0;    // 禁止Fmaster 与外设连接
    133              //CLK_PCKENR2 = 0;
    134              /* */
    135              //------------------A/D conversion 
    136              CLK_PCKENR2 |= 0x08;           //使能Fmaster与外设ADC模块连接 
    137              ADC_CR1 = 0x00;               // ADC时钟=主时钟/2=8MHZ,单次转换模式Tad =1/8,未使能ADC
    138              ADC_CR2 = 0x08;               // A/D 结果数据右对齐
    139              ADC_CSR = 0x00;               // 清转换结束标志位EOC，
    140              ADC_CR3 = 0x00;
    141              ADC_TDRH = 0xFF;              //禁止施密特触发功能
    142              ADC_TDRL = 0x00; 
    143              nop(); nop();
    144              ADC_TDRL = 0x08;              // AIN3  0b0000 1000 
    145              CLK_PCKENR2 &=~(0x08);
    146             
    147          }
    148          //==================================================================
    149          //==================================================================
    150          //---------------WatchDog  LSI 128KHz/2 = 64KHz
    151          /*
    152              预分频系数    PR[2:0]   最短超时(RL[7:0]=0x00)    最长超时(RL[7:0]=0xFF)
    153              /4            0         62.5 μs                  15.90 ms     
    154              /8            1         125 μs                   31.90 ms     
    155              /16           2         250 μs                   63.70 ms     
    156              /32           3         500 μs                   127 ms     
    157              /64           4         1.00 ms                   255 ms     
    158              /128          5         2.00 ms                   510 ms     
    159              /256          6         4.00 ms                   1.02 s     
    160          */
    161          /*  */
    162          void ClrWdt(void)
    163          {
    164              IWDG_KR = 0x55;   //解除保护
    165              IWDG_RLR = 0xFF;  //刷新内容
    166              IWDG_PR = 6; 
    167              IWDG_KR = 0xAA;   //刷新及恢复保护
    168              IWDG_KR = 0xCC;   //独立看门狗启动
    169          } 
    170          
    171          //==================================================================
    172          //==================================================================
    173          void PortInit(void)
    174          { 
    175            GPIO_Init(GPIOA, GPIO_PIN_3, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    176            GPIO_Init(GPIOA, GPIO_PIN_2, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    177            GPIO_Init(GPIOA, GPIO_PIN_1, GPIO_MODE_OUT_PP_LOW_FAST);    // undifined
    178            
    179            GPIO_Init(GPIOB, GPIO_PIN_5, GPIO_MODE_OUT_PP_LOW_FAST);           
    180            GPIO_Init(GPIOB, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);       
    181           
    182            GPIO_Init(GPIOC, GPIO_PIN_7, GPIO_MODE_OUT_PP_LOW_FAST);    // ALERT 
    183            GPIO_Init(GPIOC, GPIO_PIN_6, GPIO_MODE_OUT_PP_LOW_FAST);    // chger fault control 
    184            GPIO_Init(GPIOC, GPIO_PIN_5, GPIO_MODE_OUT_PP_LOW_FAST);    // LED1
    185            GPIO_Init(GPIOC, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);    // LED2
    186            GPIO_Init(GPIOC, GPIO_PIN_3, GPIO_MODE_OUT_PP_LOW_FAST);    // LED3 
    187             
    188            GPIO_Init(GPIOD, GPIO_PIN_6, GPIO_MODE_IN_PU_IT);          
    189            GPIO_Init(GPIOD, GPIO_PIN_5, GPIO_MODE_OUT_PP_HIGH_FAST);          
    190            GPIO_Init(GPIOD, GPIO_PIN_4, GPIO_MODE_OUT_PP_LOW_FAST);    // undefined
    191            GPIO_Init(GPIOD, GPIO_PIN_3, GPIO_MODE_IN_FL_NO_IT);        // chger fault input
    192            GPIO_Init(GPIOD, GPIO_PIN_2, GPIO_MODE_IN_FL_NO_IT);        // Triger Voltage measurement
    193          #if 0
    194            CPU_CFG_GCR |=0x01;                                         //SWIN模式被禁用，SWIM引脚可被用作普通I/O口
    195            GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_OUT_PP_HIGH_FAST);   //MUC_DO3
    196          #else
    197            GPIO_Init(GPIOD, GPIO_PIN_1, GPIO_MODE_IN_PU_NO_IT);        //SWIN 
    198          #endif
    199            //EXTI_CR1 |=0x40;//上升沿触发//0x80;//下降沿触发
    200            EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
    201            /*------------------------------------------------------------------------------------
    202              GPIO_MODE_IN_FL_NO_IT 无中断功能的浮动输入。  // ADC input
    203              
    204              GPIO_MODE_IN_PU_NO_IT 无中断功能的上拉输入。  // normal digit input
    205              
    206              GPIO_MODE_IN_FL_IT 带中断功能的浮动输入。  
    207              
    208              GPIO_MODE_IN_PU_IT 带中断功能的上拉输入。	
    209              
    210              GPIO_MODE_OUT_OD_LOW_FAST 高速开漏低电平输出，可工作到10MHz。  
    211              
    212              GPIO_MODE_OUT_PP_LOW_FAST 高速推挽低电平输出，可工作到10MHz。  
    213              
    214              GPIO_MODE_OUT_OD_LOW_SLOW 低速开漏低电平输出，可工作到2MHz。	// undefined port
    215              
    216              GPIO_MODE_OUT_PP_LOW_SLOW 低速推挽低电平输出，可工作到2MHz。	
    217              
    218              GPIO_MODE_OUT_OD_HIZ_FAST 高速开漏高阻态输出，可工作到10MHz。  
    219              
    220              GPIO_MODE_OUT_PP_HIGH_FAST 高速推挽高电平输出，可工作到10MHz。  
    221              
    222              GPIO_MODE_OUT_OD_HIZ_SLOW 低速开漏高阻态输出，可工作到2MHz。	
    223              
    224              GPIO_MODE_OUT_PP_HIGH_SLOW 低速推挽高电平输出，可工作到2MHz。
    225             ------------------------------------------------------------------------------------*/
    226          } 
    227          //============================================UART串口模块 begin
    228          /*--------------------------------
    229            配置 UART1
    230              - BaudRate = 9600 baud
    231              - Word Length = 8 Bits
    232              - One Stop Bit
    233              - No parity
    234              - Receive and transmit enabled
    235              - UART1 Clock disabled
    236          --------------------------------*/
    237          void Uart_Model_Init(void)
    238          {
    239              //UART1_DeInit(); 
    240              //UART1_Init((uint32_t)9600, UART1_WORDLENGTH_8D, UART1_STOPBITS_1, UART1_PARITY_NO,UART1_SYNCMODE_CLOCK_DISABLE, UART1_MODE_TX_ENABLE);//UART1_MODE_TXRX_ENABLE
    241              //================================================================== 
    242              /*  */
    243              CLK_PCKENR1 |= 0x0C;         // 使能fmaster与UART连接 
    244              UART1_BRR2  =  0x02;         // 设置波特率9600
    245              UART1_BRR1  =  0x68;         // 16M/9600 = 0x0682
    246              UART1_CR1   =  0x00;          //UART使能，一个起始位，8个数据位，禁止奇偶校验，禁止中断
    247              UART1_CR3   =  0x00;          //一个停止位    
    248              UART1_CR2   =  0x08;//  send only //0x0C;           //发送及接收使能 
    249              //UART1_CR2   |= 0x20;          //接收中断使能  
    250          } 
    251          //==========================================
    252          void Uart_SendByte(uint8_t DataByte)      
    253          {   
    254              //===单线通讯时，发送数据时避免影响接收管脚，故发送数据时先禁止接收及其中断
    255              //UART1_CR2 &= ~0x04;
    256              //UART1_CR2 &= ~0x20; 
    257              while(!UART1_SR_TXE);
    258              UART1_DR = DataByte;    
    259              nop(); nop(); nop();
    260              while(!(UART1_SR &0x40)); 
    261              //========数据发送完毕，使能接收及其中断
    262              UART1_SR &= ~0x48;
    263              //UART1_CR2 |= 0x24; 
    264          }  
    265          //==========================================
    266          void itoa(char *buf, int i, int base)
    267          {
    268              #define LEN	20
    269              char *s;
    270              int rem;
    271              static char rev[LEN+1];
    272            
    273              rev[LEN] = 0;
    274              if (i == 0)
    275              {
    276                (buf)[0] = '0';
    277                ++(buf);
    278                return;
    279              }
    280              s = &rev[LEN];
    281              while (i)
    282              {
    283                rem = i % base;
    284                if (rem < 10)
    285                {
    286                  *--s = rem + '0';
    287                }
    288                else if (base == 16)
    289                {
    290                  *--s = "abcdef"[rem - 10];
    291                }
    292                i /= base;
    293              }
    294              while (*s)
    295              {
    296                (buf)[0] = *s++;
    297                ++(buf);
    298              }
    299          }
    300          
    301          //==========================================
    302          void Uart_SendStr(unsigned char *tx_pData) 
    303          {
    304              unsigned int i, nLen; 
    305              nLen = strlen(tx_pData);
    306              ClrWdt();
    307              for(i=0; i<nLen; i++)
    308              {
    309                Uart_SendByte(tx_pData[i]);
    310              }
    311          }
    312          
    313          //==========================================
    314          void Uart_SendData(unsigned int tx_data, int base) 
    315          {
    316            unsigned char buf[20] = {0};
    317          
    318            itoa((char *)buf, tx_data, base);
    319            
    320            if (base == 16)
    321            {
    322              Uart_SendStr((unsigned char *)"0x");
    323            }
    324            
    325            Uart_SendStr(buf);
    326          }
    327          //============================================UART串口模块 end
    328          
    329          //==================================================================
    330          void I2C_Model_Init(void)
    331          { 
    332            CLK_PCKENR1 |= 0x01;    // Fmaster 与外设I2C连接 
    333            I2C_CR1 = 0;
    334             
    335            //I2C_ITR   = 0x01;    //使能错误中断
    336            I2C_FREQR = 8;//输入时钟为8MHz
    337            
    338            I2C_TRISER = 9;
    339             
    340            //CRR的计算，确定I2C的通信频率f_SCL =1/(T_high + T_low), 100KHz -->T_hgih = T_low =5000ns
    341            //I2C的输入频率f_CK = 1/T_CK, CRR = T_hgih /T_CK;
    342            I2C_CCRL = 80;//40; // 上升沿及下降沿时间5000s, 
    343            I2C_CCRH = 0;  // 标准模式100KHz,  
    344               
    345            I2C_CR1 |= 0x01;//I2C_CR1_PE;
    346            
    347            I2C_CR2 |= 0x04;
    348          }
    349          //================================================================== 
    350          //=======================================================================
    351          //======================================================================= 
    352          //======================================================================= 
    353          void Timer2Init(void)
    354          { 
    355              CLK_PCKENR1 |= 0x20;    // Fmaster 与外设TIM2连接
    356              TIM2_CR1 = 0x84;        // TIM2_ARR寄存器通过缓冲预装载，使能计数器
    357              TIM2_IER = 0x00;        // 禁止中断
    358              //TIM2_EGR = 0x01;        // 允许产生更新事件 
    359              TIM2_PSCR = 0x07;       // 计数器时钟=主时钟/8=16MHZ/128    8us// 相当于计数器周期为 
    360              TIM2_CNTRH = 0;         //     
    361              TIM2_CNTRL = 0;         //     
    362              TIM2_ARRH = 0x04;       //     10ms
    363              TIM2_ARRL = 0xE2;       //   
    364              TIM2_IER |= 0x01;       // 使能更新中断，禁止触发中断  
    365              TIM2_CR1 |= 0x01;        // TIM2_ARR寄存器通过缓冲预装载，使能计数器
    366          } 
    367          //=======================================================================
    368          //==================================================================
    369          //==================================================================
    370          //--Fmaster = CK_PSC =16MHz, CK_PSC prescaler(128) to CK_CNT(8us)   TIM4_SR1.UIF更新中断标志符
    371          void Timer4_Init_us(void)
    372          {
    373              CLK_PCKENR1 |= 0x10;    //Fmaster 与外设TIM4连接
    374              TIM4_IER = 0x00;        // 禁止中断
    375              TIM4_EGR = 0x01;        // 允许产生更新事件 
    376              //TIM4_PSCR = 0x07;       // 计数器时钟=主时钟/128=16MHZ/128  // 相当于计数器周期为8uS
    377              TIM4_PSCR = 0x00;       // 计数器时钟=主时钟/128=16MHZ/1  // 相当于计数器周期为0.0625uS
    378              TIM4_CR1 = 0x15;        // TIM4_ARR寄存器通过缓冲预装载，使能计数器
    379              TIM4_CNTR = 0;          //     
    380              TIM4_ARR = 16;           // 0.0625*16 = 1us  // 6*8us = 200us  
    381              TIM4_IER |= 0x01;       //更新中断使能，禁止触发中断 
    382              TIM4_CR1 |= 0x01; 
    383          } 
    384          void Timer4_Init_ms(void)
    385          {
    386              CLK_PCKENR1 |= 0x10;    //Fmaster 与外设TIM4连接
    387              TIM4_IER = 0x00;        // 禁止中断
    388              TIM4_EGR = 0x01;        // 允许产生更新事件 
    389              TIM4_PSCR = 0x07;       // 计数器时钟=主时钟/128=16MHZ/128  // 相当于计数器周期为8uS 
    390              TIM4_CR1 = 0x15;        // TIM4_ARR寄存器通过缓冲预装载，使能计数器
    391              TIM4_CNTR = 0;          //     
    392              TIM4_ARR = 125;         // 125*8us = 1ms  
    393              TIM4_IER |= 0x01;       //更新中断使能，禁止触发中断 
    394              TIM4_CR1 |= 0x01; 
    395          } 
    396          void Timer4_Disable(void)
    397          {
    398              TIM4_CR1 &= ~0x01;
    399              TIM4_IER &= ~0x01;
    400              CLK_PCKENR1 &= ~0x10;    //Fmaster 与外设TIM4断开连接 
    401          } 
    402          void Delay_us(uint16_t Delay_time)
    403          {
    404            Delay_time_t = Delay_time;
    405            Timer4_Init_us();
    406            while(Delay_time_t > 0);  
    407            Timer4_Disable();
    408          }
    409          void Delay_ms(uint16_t Delay_time)
    410          {
    411            Delay_time_t = Delay_time;
    412            Timer4_Init_ms();
    413            while(Delay_time_t > 0)
    414            {
    415              if(Delay_time_t >= 300)
    416              {  
    417                ;//ClrWdt(); 
    418              } 
    419            }
    420            Timer4_Disable();
    421          }
    422            
    423          //==================================================================
    424          /*
    425            The following equations show how to use the 14-bit ADC readings in TS1, TS2, and TS3 to determine the
    426            resistance of the external 103AT thermistor:
    427              VTSX = (ADC in Decimal) x 382 μV/LSB                     (4)
    428              RTS = (10,000 × VTSX) ÷ (3.3 C VTSX)                   (5)
    429          */
    430          void TempCheck(void)
    431          {  
    432              static uint8_t DisTemp_Lock = 0;
    433               
    434              Temp_Val = V_TS2_Val;//R_TS2_Val;
    435              if(WorkMode == CHARGE_MODE)//if(Bits_flag.Bit.Chg)
    436              {
    437                 DisTemp_Lock = 0;
    438                 if((Temp_Val >ChgTempL_ON) || (Temp_Val < ChgTempH_ON) || (ChgTemp_cnt >= 10))
    439                 {
    440                   if((ChgTemp_cnt++) >= 10)
    441                   {
    442                     ChgTemp_cnt = 10;
    443                     Bits_flag.Bit.ChgTemp = 1;
    444                   }
    445                 }
    446                 else
    447                 {
    448                   ChgTemp_cnt = 0;
    449                 }
    450              //Bits_flag.Bit.ChgTemp = 1; 
    451                //==========================充电温度保护恢复
    452                if(Bits_flag.Bit.ChgTemp && (Temp_Val < ChgTempL_OFF) && (Temp_Val >ChgTempH_OFF))
    453                {
    454                    ChgTemp_cnt = 0;
    455                    Bits_flag.Bit.ChgTemp = 0;
    456                    
    457                    //Bits_flag.Bit.ChgTemp = 1; 
    458                } 
    459              }
    460              else if(WorkMode == DISCHARGE_MODE) 
    461              {
    462                ChgTemp_cnt = 0;
    463                if((Temp_Val > DisTempL_ON) || (Temp_Val < DisTempH_ON) || (DisTemp_cnt >= 300)) 
    464                {
    465                  if(DisTemp_cnt >= 300)
    466                  {
    467                    DisTemp_cnt = 300;
    468                    Bits_flag.Bit.DisTemp = 1;
    469                    DisTemp_Lock = 1;
    470                  }
    471                }
    472                else
    473                {
    474                  DisTemp_cnt = 0;
    475                  Temp_Protect_Delay_t = 0;
    476                }
    477                /*  
    478                //==========================放电温度保护恢复
    479                if(DisTemp_Lock == 0 && Bits_flag.Bit.DisTemp && (Temp_Val < DisTempL_OFF) && (Temp_Val > DisTempH_OFF))
    480                {
    481                  //if(DisTemp_Lock_Cnt > 30)
    482                  { 
    483                    DisTemp_cnt = 0;
    484                    DisTemp_Lock_Cnt = 30;
    485                    Bits_flag.Bit.DisTemp = 0;
    486                    Temp_Protect_Delay_t = 0;
    487                    DisTemp_Lock = 1;
    488                  } 
    489                }
    490                */
    491              }  
    492              else
    493              { 
    494                DisTemp_Lock = 0;
    495              }
    496          }
    497          //================================================================== 
    498          //==================================================================
    499          /*      SYS_STAT (0x00)/RESET:0x00
    500                  BIT        7      6           5             4       3   2    1     0
    501                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    502          */
    503          void CurrentCheck(void)
    504          {  
    505            if(WorkMode == CHARGE_MODE)
    506            {
    507              if(Current_Val > ChgCurOv_Val_SET || Bits_flag.Bit.ChgCurOv)
    508              {
    509                if(ChgCurOv_t >= ChgCurOv_t_SET)
    510                {
    511                  ChgCurOv_t = ChgCurOv_t_SET;
    512                  Bits_flag.Bit.ChgCurOv = 1;
    513                }
    514              }
    515              else
    516              {
    517                ChgCurOv_t = 0;
    518              } 
    519              /*
    520              if(0)//(Bits_flag.Bit.ChgCurOv && ChgCurOv_Re_t >= ChgCurOv_Re_t_SET)
    521              {
    522                ChgCurOv_t = 0; 
    523                ChgCurOv_Re_t = 0;
    524                Bits_flag.Bit.ChgCurOv = 0;
    525              } */
    526            }
    527            else if(WorkMode == DISCHARGE_MODE)//9A,  15A
    528            {   
    529              if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD || Current_Val >= DisCurOv_2_Val_SET || DisCurOv_t2 >= DisCurOv_t2_SET || DisCurOv_t1 >= DisCurOv_t1_SET)
    530              {
    531                if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD || DisCurOv_t2 >= DisCurOv_t2_SET || DisCurOv_t1 >= DisCurOv_t1_SET)
    532                {
    533                  DisCurOv_t1 = DisCurOv_t1_SET;
    534                  DisCurOv_t2 = DisCurOv_t2_SET;
    535                  Bits_flag.Bit.DisCurOv = 1;
    536                } 
    537              }
    538              else if(Current_Val >= DisCurOv_1_Val_SET)//9A
    539              { 
    540                DisCurOv_t2 = 0;
    541                if(DisCurOv_t1 >= DisCurOv_t1_SET)
    542                {
    543                  DisCurOv_t1 = DisCurOv_t1_SET; 
    544                  Bits_flag.Bit.DisCurOv = 1;
    545                }  
    546              }
    547              else
    548              {
    549                DisCurOv_t1 = 0;
    550                DisCurOv_t2 = 0;
    551              } 
    552              //==========================短路检测
    553              //if(WorkMode != CHARGE_MODE)
    554              {
    555                if( SYS_STAT.Bit.SCD )
    556                {  
    557                   Bits_flag.Bit.DisCurShort = 1; 
    558                }
    559                /*
    560                if(Bits_flag.Bit.DisCurShort && DisCurShort_Re_t >= DisCurShort_Re_t_SET)
    561                { 
    562                  SYS_STAT_Last |= 0x02;   //clear the SCD bit by writing "1" 
    563                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last & 0xF2); 
    564                  SYS_STAT_Last &= ~0x02;
    565                  DisCurOv_Re_t = 0;
    566                  SYS_STAT.Bit.SCD = 0;
    567                  Bits_flag.Bit.DisCurShort =0;
    568                }
    569                */
    570              }
    571            }
    572            
    573            
    574          }
    575          //==================================================================
    576          //==================================================================
    577          /*      SYS_STAT (0x00)/RESET:0x00
    578                  BIT        7      6           5             4       3   2    1     0
    579                  NAME   CC_READY  RSVD   DEVICE_XREADY   OVRD_ALERT  UV  OV  SCD   OCD
    580          */
    581          void VoltCheck(void)
    582          {  
    583            if(WorkMode == CHARGE_MODE)
    584            {
    585              if(Cell_Volt_Max >= CHG_OV_VAL_SET ||SYS_STAT.Bit.OV ||Bits_flag.Bit.ChgOv)
    586              { 
    587                if((ChgOv_t >= ChgOv_t_SET) ||SYS_STAT.Bit.OV)
    588                {
    589                  ChgOv_t = ChgOv_t_SET;
    590                  Bits_flag.Bit.ChgOv = 1;
    591                }
    592              }
    593              else
    594              {
    595                ChgOv_t =0;
    596              }
    597              
    598              if(Bits_flag.Bit.ChgOv && Cell_Volt_Max < CHG_OV_RE_VAL_SET)// Cell_Volt_Avg < CHG_OV_RE_VAL_SET &&
    599              {
    600                //clear the OV bit by writing "1"
    601                if(SYS_STAT.Bit.OV)
    602                {
    603                  //SYS_STAT_Last &= ~0x0F;
    604                  SYS_STAT_Last |= 0x04;
    605                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF4);
    606                  SYS_STAT_Last &= ~0x04;
    607                }
    608                ChgOv_t = 0;
    609                SYS_STAT.Bit.OV = 0;
    610                Bits_flag.Bit.ChgOv = 0;
    611              }
    612                
    613            }
    614            else if(WorkMode == DISCHARGE_MODE)
    615            {
    616              //=========开机整体电芯电压
    617              if(Dis_First_Run_Flag ==0 && WorkMode == DISCHARGE_MODE)
    618              { 
    619                if((Cell_Volt_Avg < 3000) || (Cell_Volt_Min < 3000) || SYS_STAT.Bit.UV)
    620                {
    621                  if(Dis_First_Run_t >= 50)
    622                  {
    623                    Dis_First_Run_t = 50;
    624                    Bits_flag.Bit.DisOv = 1;
    625                    Dis_First_Run_Flag  = 1;
    626                  }
    627                }
    628                else 
    629                {
    630                  if(Dis_First_Run_t >= 30)
    631                  {
    632                    Dis_First_Run_t = 30; 
    633                    Bits_flag.Bit.DisOv = 0;
    634                    Dis_First_Run_Flag  = 1;
    635                    DisOv_t = 0;
    636                    //clear the UV bit by writing "1"
    637                    if(SYS_STAT.Bit.UV)
    638                    {
    639                      //SYS_STAT_Last &= ~0x0F;
    640                      SYS_STAT_Last |= 0x08;
    641                      I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF8);
    642                      SYS_STAT_Last &= ~0x08;
    643                    }
    644                  }
    645                } 
    646              } 
    647          
    648              //==== 放电欠压检测
    649              if((Cell_Volt_Avg < DIS_UV_VAL_SET) ||(Cell_Volt_Min < DIS_UV_MIN_VAL_SET) || SYS_STAT.Bit.UV)// 
    650              {
    651                if((DisOv_t >= DisOv_t_SET) || SYS_STAT.Bit.UV)
    652                {
    653                  DisOv_t = DisOv_t_SET;
    654                  Bits_flag.Bit.DisOv = 1;
    655                }
    656              }
    657              else
    658              {
    659                DisOv_t = 0;
    660              }
    661              /*
    662              if(Bits_flag.Bit.DisOv && Cell_Volt_Min >= DIS_UV_RE_VAL_SET)//Cell_Volt_Avg >= DIS_UV_RE_VAL_SET && 
    663              {
    664                //clear the UV bit by writing "1"
    665                if(SYS_STAT.Bit.UV)
    666                {
    667                  //SYS_STAT_Last &= ~0x0F;
    668                  SYS_STAT_Last |= 0x08;
    669                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF8);
    670                  SYS_STAT_Last &= ~0x08;
    671                }
    672                DisOv_t = 0;
    673                SYS_STAT.Bit.UV = 0;
    674                Bits_flag.Bit.DisOv = 0;
    675              }
    676              */
    677            }
    678          }  
    679          /*
    680          //==========================================================================
    681          void ModeCheck_Backup(void)
    682          {       
    683            //工作模式的检测是依据外部Triger端的电压大小来判定
    684            Check_Val = ADConverse(3); 
    685            if((Check_Val >= 130 && Check_Val < 160) || CC_Val >= 10)
    686            {  
    687              if(ChgExchangeMode_Cnt >= 30)
    688              { 
    689                ChgExchangeMode_Cnt  = 100;
    690                DisExchangeMode_Cnt  = 0;
    691                IdleExchangeMode_Cnt = 0;
    692                WorkMode = CHARGE_MODE;
    693              }
    694            }   
    695            else if((Check_Val >= 220 && Check_Val < 630) || SYS_CTRL1.Bit.LOAD_PRESENT || CC_Val < (-10) )
    696            {  
    697              if(DisExchangeMode_Cnt >= 30)
    698              { 
    699                IdleExchangeMode_Cnt = 0;
    700                ChgExchangeMode_Cnt = 0;
    701                DisExchangeMode_Cnt = 100; 
    702                WorkMode = DISCHARGE_MODE;
    703              }
    704            } 
    705            else if(Check_Val < 10)
    706            { 
    707              if(IdleExchangeMode_Cnt >= 100)
    708              { 
    709                IdleExchangeMode_Cnt = 100;
    710                ChgExchangeMode_Cnt = 0;
    711                DisExchangeMode_Cnt = 0;
    712                WorkMode = IDLE_MODE;
    713              }
    714            } 
    715          }
    716          */
    717          //==========================================================================
    718          void ModeCheck(void)
    719          {       
    720            static uint8_t ModeChange_Lock = 0;
    721            uint32_t OV_tmp = 1;
    722            uint32_t UV_tmp = 1;
    723            uint8_t Trip_tmp = 1;
    724            uint16_t Check_Val_tmp = 0;
    725            //工作模式的检测是依据外部Triger端的电压大小来判定 
    726            // 问题3：（充放电及空载识别问题）欠压状态下，插上充电器时，识别不了充电器;  
    727                    //解决方案：检测无Triger信号时，为空载模式;
    728                                //Triger信号范围在[220,630]时【[350,580]】，或检测到有负载信号、或放电电流 >= 10mA 时，为放电模式，否则为充电模式.
    729            
    730          //========================================================================== 
    731            
    732            //OV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (OV_val - ADCOffset_Val)/ADCGain_Val) >> 4);  
    733            //UV_TRIP_Last = (uint8_t)(((uint32_t)1000 * (UV_val - ADCOffset_Val)/ADCGain_Val) >> 4); 
    734            Check_Val = ADConverse(3); // 充电时Check_Val_MAX == 150
    735             
    736            if(Check_Val < 10)// 无信号
    737            { 
    738              if(IdleExchangeMode_Cnt >= 30)
    739              { 
    740                IdleExchangeMode_Cnt = 30;
    741                ChgExchangeMode_Cnt = 0;
    742                DisExchangeMode_Cnt = 0;
    743                WorkMode = IDLE_MODE;
    744                if(0 != ModeChange_Lock)
    745                { 
    746                  I2C_Read(OV_TRIP_ADDR,&Trip_tmp); 
    747                  OV_tmp = ADCOffset_Val + (((uint32_t)OV_TRIP_Last << 4) * ADCGain_Val)/1000;
    748                    
    749                  I2C_Read(UV_TRIP_ADDR,&Trip_tmp); 
    750                  UV_tmp = ADCOffset_Val + (((uint32_t)UV_TRIP_Last << 4) * ADCGain_Val)/1000;
    751                    
    752                  if((OV_THREHOLD_VAL_SET != OV_tmp) || (UV_THREHOLD_VAL_SET != UV_tmp ))
    753                  {
    754                    Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, UV_THREHOLD_VAL_SET); 
    755                  }
    756                  else
    757                  {
    758                    ModeChange_Lock = 0;
    759                  } 
    760                }
    761              }
    762            } 
    763            else
    764            {
    765              // dsg: Cell_Volt_Total == 31070   Check_Val == [385,394]   Check_Val_tmp == [31018,31743]  Max_Delta == 673
    766              // chg: Cell_Volt_Total == 31050   Check_Val == [204,208]   Check_Val_tmp == [16435,16757]  Max_Delta == [14615,14293]
    767              Check_Val_tmp = (uint16_t)((uint32_t)Check_Val *3300 * 25 /1024);//+-1000mV
    768              if( ((Check_Val_tmp < Cell_Volt_Tol) && (Cell_Volt_Tol - Check_Val_tmp <= 2000)) || ((Check_Val_tmp > Cell_Volt_Tol) && (Check_Val_tmp - Cell_Volt_Tol <= 2000)) || SYS_CTRL1.Bit.LOAD_PRESENT) 
    769              //else if((Check_Val >= 186 && Check_Val < 630) || SYS_CTRL1.Bit.LOAD_PRESENT)// || CC_Val < (-10) )
    770              {  
    771                if(DisExchangeMode_Cnt >= 30)
    772                { 
    773                  IdleExchangeMode_Cnt = 0;
    774                  ChgExchangeMode_Cnt = 0;
    775                  DisExchangeMode_Cnt = 100; 
    776                  WorkMode = DISCHARGE_MODE;
    777                  if(2 != ModeChange_Lock)
    778                  {
    779                    //ModeChange_Lock = 2; 
    780                    //Afe_OV_UV_Threshold_Set(4300, UV_THREHOLD_VAL_SET); // 问题1：放电状态下，电芯电压处于过充时，BQ会自动关闭充电MOS管;   解决方案：放电状态下，重新设置硬件过充电压为4.3V
    781                    I2C_Read(OV_TRIP_ADDR,&Trip_tmp); 
    782                    OV_tmp = ADCOffset_Val + (((uint32_t)OV_TRIP_Last << 4) * ADCGain_Val)/1000;
    783                      
    784                    I2C_Read(UV_TRIP_ADDR,&Trip_tmp); 
    785                    UV_tmp = ADCOffset_Val + (((uint32_t)UV_TRIP_Last << 4) * ADCGain_Val)/1000;
    786                      
    787                     //if((4250 >= OV_tmp) || (2950 >= UV_tmp ))//3000
    788                    if((4400 != OV_tmp) || (UV_THREHOLD_VAL_SET != UV_tmp ))
    789                    {
    790                      Afe_OV_UV_Threshold_Set(4400, UV_THREHOLD_VAL_SET); 
    791                    }
    792                    else
    793                    {
    794                      ModeChange_Lock = 2;
    795                    }
    796                  }
    797                }
    798              }  
    799              else// if((Check_Val >= 130 && Check_Val < 160) || CC_Val >= 10)
    800              {  
    801                if(ChgExchangeMode_Cnt >= 30)
    802                { 
    803                  ChgExchangeMode_Cnt  = 100;
    804                  DisExchangeMode_Cnt  = 0;
    805                  IdleExchangeMode_Cnt = 0;
    806                  WorkMode = CHARGE_MODE;
    807                  if(1 != ModeChange_Lock)
    808                  {
    809                    //ModeChange_Lock = 1; 
    810                    //Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, 0);// 问题2：充电状态下，电芯电压处于过放时，BQ会自动关闭放电MOS管;   解决方案：充电状态下，重新设置硬件过充电压为1.5V
    811                    I2C_Read(OV_TRIP_ADDR,&Trip_tmp); 
    812                    OV_tmp = ADCOffset_Val + (((uint32_t)OV_TRIP_Last << 4) * ADCGain_Val)/1000;
    813                      
    814                    I2C_Read(UV_TRIP_ADDR,&Trip_tmp); 
    815                    UV_tmp = ADCOffset_Val + (((uint32_t)UV_TRIP_Last << 4) * ADCGain_Val)/1000;
    816                      
    817                    //if((4200 < OV_tmp) || (50 >= UV_tmp ))
    818                    if((OV_THREHOLD_VAL_SET != OV_tmp) || (0 != UV_tmp ))
    819                    {
    820                      Afe_OV_UV_Threshold_Set(OV_THREHOLD_VAL_SET, 0); 
    821                    }
    822                    else
    823                    {
    824                      ModeChange_Lock = 1;
    825                    }
    826                  }
    827                }
    828              }  
    829            }
    830          } 
    831          //===========================================
    832          void ClearStatus(void)
    833          {
    834            if(WorkMode == CHARGE_MODE)
    835            {  
    836                DisTemp_Lock_Cnt = 0;
    837                LowPower_MCU_Entry_Flag = 0;
    838                PowerOff_Delay_t = 0;
    839                Dis_First_Run_Flag = 0;
    840                Dis_First_Run_t = 0;
    841                DisOv_t = 0;  
    842                //DisCurOv_t = 0;  
    843                //DisCurOv_Re_t = 0; 
    844                 
    845                //Temp_Protect_Delay_t = 0;
    846                Bits_flag.Bit.DisTemp = 0;
    847                //Bits_flag.Bit.DisCurShort = 0; 
    848                
    849                if(Bits_flag.Bit.DisOv || SYS_STAT.Bit.UV)
    850                { 
    851                  if(SYS_STAT.Bit.UV)  //clear the UV bit by writing "1"
    852                  { 
    853                    //SYS_STAT_Last &= ~0x0F;
    854                    SYS_STAT_Last |= 0x08;
    855                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF8);
    856                    SYS_STAT_Last &= ~0x08;
    857                  }  
    858                  Bits_flag.Bit.DisOv = 0;
    859                }
    860               /* if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD) 
    861                { 
    862                  if(SYS_STAT.Bit.OCD)  //clear the OV bit by writing "1"
    863                  {
    864                    //SYS_STAT_Last &= ~0x0F;
    865                    SYS_STAT_Last |= 0x01;
    866                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF1);
    867                    SYS_STAT_Last &= ~0x01;
    868                  }
    869                  Bits_flag.Bit.DisCurOv = 0;
    870                } */
    871            }/*
    872            else if(WorkMode == DISCHARGE_MODE)
    873            {
    874                ChgOv_t = 0; 
    875                ChgCurOv_t = 0; 
    876                ChgCurOv_Re_t = 0; 
    877                 
    878                Bits_flag.Bit.ChgCurOv = 0;
    879                Bits_flag.Bit.ChgTemp = 0;
    880                if(Bits_flag.Bit.ChgOv || SYS_STAT.Bit.OV)
    881                { 
    882                  if(SYS_STAT.Bit.OV)  //clear the UV bit by writing "1"
    883                  {  
    884                    SYS_STAT_Last |= 0x04;
    885                    I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF4);
    886                    SYS_STAT_Last &= ~0x04;
    887                  }  
    888                  Bits_flag.Bit.ChgOv = 0;
    889                }
    890            }*/
    891            else if(WorkMode == IDLE_MODE)
    892            {   
    893              Chg_Current_Val_Small_Errer_t = 0;
    894              DisTemp_Lock_Cnt = 0;
    895              //Bits_flag.Bit.AfeErr = 0;
    896              Dis_First_Run_Flag = 0;
    897              Dis_First_Run_t = 0;
    898              //if(Bits_flag.Bit.ChgCurOv)// && ChgCurOv_Re_t >= ChgCurOv_Re_t_SET)
    899              { 
    900                DisCurOv_t = 0;
    901                DisCurOv_Re_t = 0;
    902                DisCurOv_t1 = 0;
    903                DisCurOv_t2 = 0; 
    904                Bits_flag.Bit.ChgCurOv = 0;
    905              } 
    906              //=========================================================
    907              /*
    908              DisCurShort_Re_t = 0;
    909              if(Bits_flag.Bit.DisCurShort  || SYS_STAT.Bit.SCD) 
    910              { 
    911                //SYS_STAT_Last &= ~0x0F;
    912                SYS_STAT_Last |= 0x02;
    913                I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF2); //clear the SCD bit by writing "1" 
    914                SYS_STAT_Last &= ~0x02;
    915                Afe_SCD_Set(SCD_THREHOLD_VAL_SET, SCD_DELAY_SET);
    916                DisCurOv_Re_t = 0;
    917                //SYS_STAT.Bit.SCD = 0;
    918                Bits_flag.Bit.DisCurShort = 0;
    919              }
    920              //=========================================================
    921              if(Bits_flag.Bit.DisCurOv || SYS_STAT.Bit.OCD) 
    922              { 
    923                if(SYS_STAT.Bit.OCD)  //clear the OV bit by writing "1"
    924                {
    925                  //SYS_STAT_Last &= ~0x0F;
    926                  SYS_STAT_Last |= 0x01;
    927                  I2C_Write(SYS_STAT_ADDR,SYS_STAT_Last &0xF1);
    928                  SYS_STAT_Last &= ~0x01;
    929                  Afe_OCD_Set(OCD_THREHOLD_VAL_SET, OCD_DELAY_SET);
    930                }
    931                Bits_flag.Bit.DisCurOv = 0;
    932              } */
    933              //=========================================================
    934              
    935              ChgOv_t = 0; 
    936              ChgCurOv_t = 0; 
    937              ChgCurOv_Re_t = 0;
    938              Bits_flag.Bit.ChgOv = 0;
    939              Bits_flag.Bit.ChgCurOv = 0;
    940              Bits_flag.Bit.ChgTemp  = 0;
    941              
    942              
    943              Bits_flag.Bit.DisTemp = 0;
    944              DisTemp_cnt = 0;
    945               
    946            }
    947            else
    948            { 
    949              LowPower_MCU_Entry_Flag = 0; 
    950            }
    951          }  
    952          //==========================================================================
    953            /*The ADC transfer function is a linear equation defined as follows:
    954              V(cell) = GAIN x ADC(cell) + OFFSET
    955              If the DEVICE_XREADY is set, the voltage register values from the device should not be used. If
    956            */ 
    957          void Afe_Volt_Val_Get(void)
    958          { 
    959            uint8_t i = 0;
    960            uint16_t volt_sum = 0;
    961            uint16_t volt_max = 0;
    962            uint16_t volt_min = 0xFFFF;
    963            //====================================250mS
    964            if(Cell_Volt_Sample_Cnt >= 26)
    965            {
    966              Cell_Volt_Sample_Cnt = 0;
    967              for(i =0;i< 20;i += 2)
    968              {  
    969                Adc_value[i/2] = Afe_Get_Adc((VC1_HI_ADDR + i)) & 0x3FFF; //VC1_HI_ADDR =0x0C
    970                Cell_Volt[i/2] = (uint16_t)((uint32_t)ADCGain_Val *Adc_value[i/2]/1000) + ADCOffset_Val;
    971                volt_sum += Cell_Volt[i/2];
    972                if(Cell_Volt[i/2] < volt_min)
    973                {
    974                   volt_min = Cell_Volt[i/2];
    975                }
    976                if(Cell_Volt[i/2] > volt_max)
    977                {
    978                   volt_max = Cell_Volt[i/2];
    979                }
    980              } 
    981              Cell_Volt_Tol = volt_sum; 
    982              Cell_Volt_Avg = Cell_Volt_Tol/10; 
    983              Cell_Volt_Max = volt_max; 
    984              Cell_Volt_Min = volt_min; 
    985                
    986            }
    987            //====================================250mS
    988            /*  Once converted to digital form, each cell voltage is added up and the summation result stored in the BAT
    989                registers. This 16-bit value has a nominal LSB of 1.532 mV. */
    990            //Pack_Volt = (uint16_t)((uint32_t)4 *ADCGain_Val *Afe_Get_Adc(BAT_HI_ADDR)/1000+(10 *ADCOffset_Val));
    991            //Pack_Volt = (uint16_t)((uint32_t)1532 *Afe_Get_Adc(BAT_HI_ADDR)/1000);
    992            
    993            //====================================250mS
    994            //Positive values are charge current; negative values are discharge current.
    995            //an average over the 250-ms integration period.
    996            /*Why does the CC value read not change when I set the CC_ONESHOT bit?
    997                  The CC_READY bit must be cleared before the CC_ONESHOT bit is set. Note also that the CC_EN bit
    998                  should be cleared or a CC conversion may already be in progress.
    999              The full scale range of the CC is ± 270 mV, with a max recommended input range of ± 200 mV, thus yielding an LSB of approximately 8.44 μV.
   1000              The following equation shows how to convert the 16-bit CC reading into an analog voltage if no boardlevel calibration is performed:
   1001              CC Reading (in μV) = [16-bit 2’s Complement Value] × (8.44 μV/LSB) 
   1002            */
   1003            
   1004            I2C_Read(SYS_STAT_ADDR,&SYS_STAT_Last); 
   1005            SYS_STAT.Byte = SYS_STAT_Last; 
   1006            if((CC_Volt_Sample_Cnt >= 26) && SYS_STAT.Bit.CC_READY) //(0)//
   1007            {
   1008              CC_Volt_Sample_Cnt = 0;
   1009              SYS_STAT.Bit.CC_READY = 0;
   1010              CC_AD = Afe_Get_Adc(CC_HI_ADDR);  
   1011              //CC_Val = (int32_t)820 * CC_AD /100; //mA (int32_t)
   1012              CC_Val = (int32_t)820 * CC_AD /500; //mA (int32_t)
   1013               
   1014              Afe_CC_1Shot_Set();
   1015              if(CC_Val < -320000)
   1016              {
   1017                CC_Val = -320000;
   1018              }
   1019              else if(CC_Val > 320000)
   1020              {
   1021                CC_Val = 320000;
   1022              }
   1023              Current_Val = CC_Val;
   1024              if(CC_Val < 0)
   1025              {
   1026                Current_Val = -CC_Val;
   1027              }
   1028            }
   1029            //====================================2S 
   1030            if(Temp_Volt_Sample_Cnt >= 210)
   1031            {
   1032              //V_TS2_Val = (uint16_t)((uint32_t)(382 * ((uint16_t)adcval <<8 | tmpval))/1000);//mV
   1033              V_TS2_Val = Afe_Get_Adc(TS2_HI_ADDR) &0x3FFF ;
   1034              V_TS2_Val = (uint16_t)(((uint32_t)382 * V_TS2_Val /1000));  //mV
   1035              V_TS2_Val = (uint16_t)(((uint32_t)4096 * V_TS2_Val /3300));  //mV
   1036              //R_TS2_Val = (uint16_t)((uint32_t)10000 * V_TS2_Val)/(3300 - V_TS2_Val); 
   1037            }
   1038            //=====================================================================================
   1039            
   1040          }
   1041           /*
   1042          void OpenDetect_Cntrl(void)
   1043          {
   1044            static uint8_t Opendetect_cnt = 0;
   1045            if(Cell_Volt_Max >= 4250)
   1046            {
   1047              if((Opendetect_cnt++) >= 10)
   1048              {
   1049                Opendetect_cnt = 10;
   1050                //Bits_flag.Bit.OpenDetect = 1;
   1051              }
   1052            }
   1053            else
   1054            {
   1055              Opendetect_cnt = 0;
   1056            } 
   1057          }
   1058          */
   1059          //==========================================================================
   1060          /*
   1061            turn on condition  :    >4.0V && deltaVolt >200mV
   1062            turn off condition :   over charge assert the charging protection
   1063          */ 
   1064          void CellBal_Cntrl(void)
   1065          {
   1066            uint8_t i = 0;
   1067            if(WorkMode == CHARGE_MODE)
   1068            {
   1069              if(Cell_Balance_Delay_t >= 100)
   1070              {
   1071                Cell_Balance_Delay_t = 0;
   1072                if((Cell_Volt_Max >= CELLBALANCE_BEGIN_VAL) && ((Cell_Volt_Max - Cell_Volt_Min) >= CELLBALANCE_DELTA_VAL) && !Bits_flag.Bit.ChgOv && !Bits_flag.Bit.ChgTemp && !Bits_flag.Bit.ChgCurOv && !Bits_flag.Bit.AfeErr)
   1073                {
   1074                  CellBal_Cntrl_Lock = 1;
   1075                  for(i =0; i <10; i++)
   1076                  {
   1077                    if(Cell_Volt[i] > CELLBALANCE_BEGIN_VAL && ((Cell_Volt[i] - Cell_Volt_Min) >= CELLBALANCE_DELTA_VAL))
   1078                    {   
   1079                      CellBalance_Cur_Selct |= (0x0001 << i); 
   1080                    }
   1081                    else
   1082                    {
   1083                      CellBalance_Cur_Selct &= ~(0x0001 << i);
   1084                    }
   1085                  }  
   1086                  CellBalance_Selct = 0x0000;
   1087                  //===================================
   1088                  for(i =0; i <10; i++ )
   1089                  {
   1090                    if((CellBalance_Cur_Selct &(0x0001 <<i)))
   1091                    {
   1092                      CellBalance_Selct |=(0x0001 <<i);
   1093                      if(4 != i)
   1094                      {
   1095                        i +=1; 
   1096                      }
   1097                    }  
   1098                  } 
   1099                  Afe_CellBalance_Enable(CellBalance_Selct);
   1100                } 
   1101                else if(CellBal_Cntrl_Lock ==1)
   1102                { 
   1103                  Afe_CellBalance_Disable();
   1104                } 
   1105              }
   1106            }
   1107            else if(CellBal_Cntrl_Lock ==1)
   1108            {
   1109                Afe_CellBalance_Disable();
   1110            }
   1111          }
   1112           
   1113          //==========================================================================
   1114          /*
   1115          1、充电模式：有异常时，电流异常（LED1及LED2闪烁，周期为1秒），温度异常（LED1、LED2及LED3闪烁，周期为1秒）
   1116                       无异常时，低节电量LED常亮，高节电量的LED闪烁，T = 1s
   1117                          0%----50%     LED1闪烁
   1118                          50%---70%     LED1常亮、LED2闪烁
   1119                          70%---99%     LED1、LED2常亮、LED3闪烁
   1120                          过充          LED全亮
   1121                       
   1122          2、放电模式：有异常时，电流异常（LED1及LED2闪烁，周期为1秒），温度异常（LED1、LED2及LED3闪烁，周期为1秒）
   1123                       无异常时，显示当前电量
   1124                          10%           LED1闪烁 0.5Hz
   1125                          10%---30%     LED1常亮
   1126                          30%---50%     LED1、LED2常亮
   1127                          50%           LED全亮
   1128          */  
   1129          void LedShow_Cntrl(void)
   1130          {
   1131            static uint8_t FlowLedCnt = 0;
   1132            static uint8_t FlowLedCnt_Lock = 0;
   1133            static uint8_t FlowLed_Finish_Flag = 0;
   1134            // soc 显示
   1135            // 异常后，报警5s后，熄灭
   1136            if(WorkMode == IDLE_MODE)// ==流水显示方式
   1137            {  
   1138              FlowLedCnt = 0;
   1139              FlowLed_Finish_Flag = 0;
   1140              FlowLedCnt_Lock = 0; 
   1141              LED1_OFF();
   1142              LED2_OFF();
   1143              LED3_OFF();  
   1144            }
   1145            else
   1146            { 
   1147              LedFlash_Off_t = 0;
   1148              if(Bits_flag.Bit.AfeErr)
   1149              { 
   1150                if(LedFlash_t < 50)
   1151                {
   1152                  LED1_ON();
   1153                  LED2_OFF();
   1154                  LED3_OFF();    
   1155                } 
   1156                else if(LedFlash_t < 100)
   1157                {
   1158                  LED1_OFF();
   1159                  LED2_ON();
   1160                  LED3_OFF();   
   1161                } 
   1162                else if(LedFlash_t < 150)
   1163                {
   1164                  LED1_OFF();
   1165                  LED2_OFF();
   1166                  LED3_ON();   
   1167                } 
   1168                else if(LedFlash_t < 200)
   1169                {
   1170                  LED1_OFF();
   1171                  LED2_OFF();
   1172                  LED3_OFF();  
   1173                } 
   1174                else
   1175                {
   1176                  LedFlash_t = 0; 
   1177                }
   1178              }
   1179              else if(WorkMode == CHARGE_MODE)
   1180              { 
   1181                if(FlowLed_Finish_Flag ==0 )
   1182                {
   1183                  if(FlowLedCnt ==0)
   1184                  { 
   1185                    if(FlowLedCnt_Lock ==0)
   1186                    {
   1187                      LedFlash_t = 0;
   1188                      FlowLedCnt_Lock = 1;
   1189                    }
   1190                    LED1_ON();
   1191                    LED2_OFF();
   1192                    LED3_OFF(); 
   1193                    if(LedFlash_t >= 50)
   1194                    {
   1195                      LedFlash_t = 0;
   1196                      FlowLedCnt = 1;
   1197                      FlowLedCnt_Lock = 0;
   1198                    }  
   1199                  }
   1200                  else if(FlowLedCnt ==1)
   1201                  {
   1202                    LED1_OFF();
   1203                    LED2_ON();
   1204                    LED3_OFF(); 
   1205                    if(LedFlash_t >= 50)
   1206                    {
   1207                      LedFlash_t = 0;
   1208                      FlowLedCnt = 2;
   1209                    }  
   1210                  }
   1211                  else if(FlowLedCnt ==2)
   1212                  {
   1213                    LED1_OFF();
   1214                    LED2_OFF();
   1215                    LED3_ON(); 
   1216                    if(LedFlash_t >= 50)
   1217                    {
   1218                      LedFlash_t = 0;
   1219                      FlowLedCnt = 0;
   1220                      FlowLed_Finish_Flag = 1;
   1221                    }  
   1222                  }
   1223                }
   1224                else if(Bits_flag.Bit.ChgOv || Cell_Volt_Avg >= 4150) 
   1225                {
   1226                  LED1_OFF();
   1227                  LED2_OFF(); 
   1228                  LED3_ON(); 
   1229                } 
   1230                else if(SocCalc.soc_rt >= 50)  // 50%     LED1、LED2常亮、LED3闪烁  
   1231                {
   1232                  LED1_OFF();
   1233                  if(LedFlash_t < 50)
   1234                  {
   1235                    LED2_ON();
   1236                    LED3_OFF(); 
   1237                  } 
   1238                  else if(LedFlash_t < 100)
   1239                  {
   1240                    LED2_OFF();
   1241                    LED3_ON();
   1242                  }
   1243                  else
   1244                  {
   1245                    LedFlash_t = 0;
   1246                  } 
   1247                }
   1248                else if(SocCalc.soc_rt >= 20 )//20%---50%     LED1常亮、LED2闪烁
   1249                {
   1250                  if(LedFlash_t < 50)
   1251                  {
   1252                    LED1_ON();
   1253                    LED2_OFF(); 
   1254                  } 
   1255                  else if(LedFlash_t < 100)
   1256                  {
   1257                    LED1_OFF();
   1258                    LED2_ON();
   1259                  }
   1260                  else
   1261                  {
   1262                    LedFlash_t = 0;
   1263                  } 
   1264                  LED3_OFF();
   1265                }
   1266                else //20%     LED1闪烁
   1267                { 
   1268                  if(LedFlash_t >= 50)
   1269                  {
   1270                    LedFlash_t = 0;
   1271                    LED1_XOR();
   1272                  } 
   1273                  LED2_OFF();
   1274                  LED3_OFF();
   1275                } 
   1276              } 
   1277              else if(WorkMode == DISCHARGE_MODE)
   1278              {  
   1279                FlowLedCnt_Lock = 0;
   1280                FlowLed_Finish_Flag = 0;
   1281                if(Bits_flag.Bit.DisOv)
   1282                {
   1283                  LED1_OFF();
   1284                  LED2_OFF(); 
   1285                  LED3_OFF(); 
   1286                }
   1287                else if(SocCalc.soc_rt >= 50)  //50%           LED全亮
   1288                {
   1289                  LED1_OFF();  
   1290                  LED2_OFF(); 
   1291                  LED3_ON(); 
   1292                }
   1293                else if(SocCalc.soc_rt >= 20) //20%---50%     LED1、LED2常亮
   1294                {
   1295                  LED1_OFF();
   1296                  LED2_ON();
   1297                  LED3_OFF();
   1298                }
   1299                else   //20%     LED1闪烁
   1300                {
   1301                  LED1_ON();
   1302                  LED2_OFF();
   1303                  LED3_OFF();
   1304                } 
   1305              }
   1306            }
   1307          }
   1308          /*
   1309          void LedShow_WorkMode(void)
   1310          {
   1311            if(WorkMode == IDLE_MODE)
   1312            {
   1313              //LED1_XOR();
   1314              LED1_ON();
   1315              LED2_OFF(); 
   1316              LED3_OFF(); 
   1317            }
   1318            else if(WorkMode == CHARGE_MODE)
   1319            {
   1320              LED1_OFF();
   1321              //LED2_XOR(); 
   1322              LED2_ON(); 
   1323              LED3_OFF(); 
   1324            }
   1325            else if(WorkMode == DISCHARGE_MODE)
   1326            {
   1327              LED1_OFF();
   1328              LED2_OFF(); 
   1329              LED3_ON(); 
   1330              //LED3_XOR(); 
   1331            }
   1332          }
   1333          */
   1334          //==========================================================================
   1335          /*
   1336          void LowPower_Entry_MCU_Set(void)
   1337          {   
   1338            static uint8_t LowPower_Entry_Exit_Cnt = 0;
   1339            if(WorkMode == IDLE_MODE && (LowPower_Entry_Delay_t >= 500 || LowPower_MCU_Entry_Flag == 1))
   1340            { 
   1341              //if(LowPower_MCU_Entry_Flag == 0)
   1342              {
   1343                 Afe_ADC_Disable(); Afe_Temp_Disable();  
   1344              }
   1345              CLK_PCKENR2 = CLK_PCKENR2_AWU;
   1346              AWU_Init(AWU_TIMEBASE_1S); 
   1347              CLK->ICKR |= CLK_ICKR_SWUAH;
   1348              FLASH->CR1 |= 0x04;	  
   1349              EXTI_SetExtIntSensitivity(EXTI_PORT_GPIOD, EXTI_SENSITIVITY_FALL_ONLY);//Signal_In下降沿触发
   1350              ClrWdt();  
   1351              LowPower_MCU_Entry_Flag = 1; 
   1352              halt(); 
   1353              ClrWdt();  
   1354              Delay_ms(5); 
   1355              //======================================
   1356              if(LowPower_MCU_Entry_Flag == 1)
   1357              {
   1358                if((LowPower_Entry_Exit_Cnt ++) >= 100) 
   1359                {
   1360                  LowPower_MCU_Entry_Flag = 0; 
   1361                  LowPower_Entry_Exit_Cnt = 0; 
   1362                }
   1363              }
   1364              else
   1365              {
   1366                LowPower_Entry_Exit_Cnt = 0; 
   1367                CLK_PCKENR2 &= ~CLK_PCKENR2_AWU; 
   1368                CLK->ICKR &= ~CLK_ICKR_SWUAH; 
   1369                Afe_ADC_Enable(); Afe_Temp_Enable();Delay_ms(10); 
   1370              } 
   1371              //=============================================
   1372              LowPower_Entry_Delay_t = 0; 
   1373            }
   1374          } 
   1375          */
   1376          //========================================================================== 
   1377          void LowPower_Powerdown_Enter(void)
   1378          {
   1379            uint8_t j,i = 0;
   1380            //if(AfeErr_t >= 2000 || (LedFlash_Off_t >= 250) || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Temp_Protect_Delay_t >= 1000)))//PowerOff_Delay_t >= PowerOff_Delay_t_SET && 
   1381            //if(AfeErr_t >= 500 || (LedFlash_Off_t >= 10) || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.DisCurShort)) || (Bits_flag.Bit.ChgTemp && Temp_Protect_Delay_t >= 60000) || ChgOv_t >= 180000)
   1382            { 
   1383              //Afe_Temp_Disable();
   1384              SOC_SavedtoEEPROM();
   1385              Delay_ms(10);
   1386              while(1)
   1387              {   
   1388                for(j =0; j < 10; j++)
   1389                {
   1390                  ClrWdt();
   1391                  Delay_ms(10);
   1392                }
   1393                Afe_EnterShipMode(); 
   1394                
   1395                if((i ++) < 10)
   1396                { 
   1397                  for(j =0;j < 100;j++)
   1398                  {
   1399                    ClrWdt();
   1400                    Delay_ms(10);
   1401                  }
   1402                }
   1403                else
   1404                {
   1405                  Delay_ms(1000);
   1406                }
   1407              } 
   1408            }  
   1409          }
   1410          //==============================================================================
   1411          void LowPower_Cntrl(void)
   1412          {  
   1413            static uint8_t Afe_Temp_Disable_Lock = 0;
   1414            uint8_t Afe_Temp_Disable_Tmp = 0x08;
   1415            //if(WorkMode == IDLE_MODE || AfeErr_t >= 2000 || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Temp_Protect_Delay_t >= 1000)))
   1416            //if(AfeErr_t >= 500 || (LedFlash_Off_t >= 10) || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.DisCurShort)) || (Bits_flag.Bit.ChgTemp && Temp_Protect_Delay_t >= 60000) || ChgOv_t >= 180000)
   1417            if(WorkMode == IDLE_MODE || AfeErr_t >= 500 || (Dis_First_Run_Flag ==1 && Bits_flag.Bit.DisOv) || (WorkMode == DISCHARGE_MODE && (Bits_flag.Bit.AfeErr || Bits_flag.Bit.DisCurOv || Bits_flag.Bit.DisTemp || Bits_flag.Bit.DisCurShort)) || (Bits_flag.Bit.ChgTemp && Temp_Protect_Delay_t >= 60000) || ChgOv_t >= 180000 || ChgCurOv_t >= 600)
   1418            {
   1419              Afe_Temp_Disable();
   1420              //VCC1_OFF();
   1421              if(Afe_Temp_Disable_Lock ==0)
   1422              { 
   1423                I2C_Read(SYS_CTRL1_ADDR,&Afe_Temp_Disable_Tmp);
   1424                if((Afe_Temp_Disable_Tmp & 0x08) == 0)
   1425                {
   1426                  Afe_Temp_Disable_Lock = 1;
   1427                }
   1428              }
   1429              else
   1430              { 
   1431                I2C_Read(SYS_CTRL2_ADDR,&SYS_CTRL2_Last); 
   1432                SYS_CTRL2.Byte = SYS_CTRL2_Last;
   1433                if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1434                { 
   1435                  VCC1_OFF();
   1436                  LowPower_Powerdown_Enter();  
   1437                } 
   1438              }
   1439            }
   1440            else
   1441            {
   1442              PowerOff_Delay_t = 0;
   1443              Afe_Temp_Disable_Lock = 0;
   1444            }
   1445          }
   1446          /*
   1447          //==============================================================================
   1448          void LowPower_Cntrl_1(void)
   1449          { 
   1450            if(LowPower_MCU_Entry_Flag ==0)//(0)//
   1451            {
   1452              if(!SYS_CTRL1.Bit.ADC_EN) 
   1453              { 
   1454                Afe_ADC_Enable(); 
   1455              }
   1456              if(!SYS_CTRL1.Bit.TEMP_SEL )
   1457              {
   1458                Afe_Temp_Enable();
   1459              }
   1460            }
   1461            if(WorkMode == CHARGE_MODE)
   1462            {
   1463              return;
   1464            }
   1465            if(Bits_flag.Bit.DisOv)  
   1466            {
   1467              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1468              {
   1469                LowPower_Powerdown_Enter();  
   1470              }
   1471            }
   1472            else
   1473            {
   1474              LowPower_Entry_MCU_Set();  
   1475            }
   1476          }
   1477          //==============================================================================
   1478          void LowPower_Cntrl_Backup(void)
   1479          { 
   1480            if(LowPower_MCU_Entry_Flag ==0)//(0)//
   1481            {
   1482              if(!SYS_CTRL1.Bit.ADC_EN) 
   1483              { 
   1484                Afe_ADC_Enable(); 
   1485              }
   1486              if(!SYS_CTRL1.Bit.TEMP_SEL )
   1487              {
   1488                Afe_Temp_Enable();
   1489              }
   1490            }
   1491            if(WorkMode == CHARGE_MODE)
   1492            {
   1493              return;
   1494            }
   1495            if(Bits_flag.Bit.DisOv)  
   1496            {
   1497              if(!SYS_CTRL2.Bit.DSG_ON && !SYS_CTRL2.Bit.CHG_ON )  
   1498              {
   1499                LowPower_Powerdown_Enter();  
   1500              }
   1501            }
   1502            else
   1503            {
   1504              LowPower_Entry_MCU_Set();  
   1505            }
   1506          }
   1507          */
   1508          uint8_t CRC8_Caculate(uint8_t *ptr,uint8_t len)
   1509          {
   1510            uint8_t i;
   1511          	
   1512            uint8_t crc = 0;
   1513          
   1514            uint8_t key = 0x07; //_Poly_07
   1515            while((len--) != 0)
   1516          	
   1517            {
   1518          		
   1519              for(i = 0x80; i != 0; i /= 2)
   1520          		
   1521              {
   1522          			
   1523                if((crc & 0x80) != 0)
   1524          			
   1525                {
   1526          				
   1527                  crc *= 2;
   1528          				
   1529                  crc ^= key;
   1530          			
   1531                }
   1532          			
   1533                else
   1534          				
   1535                {
   1536                  crc *= 2;
   1537          
   1538                }
   1539          			
   1540                if((*ptr & i) != 0)
   1541          				
   1542                {
   1543                  crc ^= key;
   1544                }
   1545          		
   1546              }
   1547          		
   1548              ptr++;
   1549          	
   1550            }
   1551            return (crc);
   1552          
   1553          } 
   1554          
   1555          
   1556          //==========================================================================
   1557          /*
   1558          In a single-byte read transaction, the CRC is calculated after the second start and uses the slave address and data byte.
   1559          */
   1560          void I2C_Read(uint8_t addr,uint8_t *data)//slave device address 0x18
   1561          {      
   1562            uint16_t OverTimeDelay = OverTimeDelay_SET;
   1563            uint8_t CRC_ReData,Retry_Cnt = 5; 
   1564            Buf[0] = SLAVE_ADDR; 
   1565            while(Retry_Cnt > 0)
   1566            {
   1567              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图）  
   1568              disableInterrupts(); 
   1569              I2C->CR2 |= 0x04; //ack使能 
   1570              //=============================发送起始位 I2C_Start() 
   1571              while(I2C->SR3 & 0x02){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;I2C_COM_ERROR_Flag = 1;break;}}    // 等待总线空闲   检测i2c-SR3 busy位        
   1572              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位  
   1573              
   1574              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1575              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1576              while(!(I2C->SR1 & 0x01));  //等待START发送完 E5  
   1577              I2C->DR = (SLAVE_ADDR << 1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1578              
   1579              while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;break;}}// I2C_COM_ERROR_Flag = 1; //等特7位器件地址发送完并且收到ack,ADDR置1    
   1580              //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1581              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1582              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1583              I2C->SR3; //然后读SR3 清  ADDR 
   1584              
   1585              if(I2C_COM_ERROR_Flag == 0)
   1586              {
   1587                //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1588                I2C->DR = (u8)(addr);      
   1589                //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1590                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1591                //在发送地址和清除ADDR 之后，I2C接口进入主设备接收模式。以下见stm8s中文数据手册P252（图97主设备接收模式接收序列图）  
   1592                
   1593                //=============================I2C_Start()        
   1594                I2C->CR2 |= 0x01;  //产生重复起始位   
   1595                //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1596                while(!(I2C->SR1 & 0x01));  //等待START发送完     
   1597                //ADDRESS (接收)   
   1598                I2C->DR = (SLAVE_ADDR <<1) + 0x01;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)      
   1599                //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除改位   
   1600                
   1601                while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;break;}} // I2C_COM_ERROR_Flag = 1;//等特7位器件地址发送完并且收到ack,ADDR置1    
   1602                //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1  
   1603                I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1604                I2C->SR3; //然后读SR3 清  ADDR   
   1605                   Buf[0] = 0x31;  Buf[1] = 0;     Buf[2] = 0;           
   1606                //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1607                while(!(I2C->SR1 & 0x40));                                        
   1608                Buf[1] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)                                               
   1609                 
   1610               
   1611                
   1612                //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1613                while(!(I2C->SR1 & 0x40));                                        
   1614                Buf[2] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)  
   1615                  //EV7_1 ：RxNE=1 ，读DR寄存器清除该标志。设置ACK=0和STOP 请求。(在接收最后一个字节前)     
   1616                I2C->SR3;
   1617                I2C->DR; 
   1618                I2C->CR2 &= ~0x04; //ack使能  
   1619                I2C->CR2 |= 0x02;  //停止位产生stop      
   1620                 
   1621                enableInterrupts(); 
   1622                //while((I2C->CR2 & I2C_CR2_STOP));
   1623                CRC_ReData = CRC8_Caculate(Buf,2);
   1624                /*Uart_SendByte(0x11);
   1625                Uart_SendByte(Buf[0]);
   1626                Uart_SendByte(Buf[1]);
   1627                Uart_SendByte(Buf[2]);*/
   1628                if(CRC_ReData == Buf[2])
   1629                {
   1630                  *data = Buf[1];
   1631                  OverTimeDelay = 200; while((OverTimeDelay --) >0);
   1632                  return;
   1633                }
   1634              }
   1635              I2C_COM_ERROR_Flag = 0;
   1636              Retry_Cnt -= 1;
   1637            }
   1638            enableInterrupts(); 
   1639            //Uart_SendByte(0xDD);
   1640            //Uart_SendByte(0xDD);
   1641          }
   1642          
   1643          //==========================================================================
   1644          /*
   1645          In a single-byte write transaction, the CRC is calculated over the slave address, register address, and data.
   1646          */
   1647          void I2C_Write(uint8_t addr,uint8_t data )
   1648          {     
   1649            uint8_t Write_Retry_Cnt = 5,CRC_data = 0;
   1650            uint16_t OverTimeDelay = OverTimeDelay_SET;
   1651            Buf[0] = SLAVE_ADDR <<1 ;
   1652            Buf[1] = addr;
   1653            Buf[2] = data;
   1654            CRC_data = CRC8_Caculate(Buf,3);//slave_addr + reg_addr + data + CRC
   1655            I2C_COM_ERROR_Flag =0;
   1656            
   1657            while(Write_Retry_Cnt > 0)
   1658            { 
   1659              disableInterrupts();
   1660              I2C_CR2 |= 0x04;
   1661              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1662              //=============================发送起始位 I2C_Start() 
   1663              while(I2C->SR3 & 0x02) {if((OverTimeDelay --) == 0){OverTimeDelay = 500;I2C_COM_ERROR_Flag = 1;break;}}//   // 等待总线空闲   检测i2c-SR3 busy位
   1664              //I2C_CR2 &= ~0x04;        
   1665              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位    
   1666              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1667              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1668              while(!(I2C->SR1 & 0x01));// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}} //等待START发送完 E5  
   1669              
   1670              I2C->DR = (SLAVE_ADDR <<1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1671              
   1672              OverTimeDelay = 100; while((OverTimeDelay --) >0);OverTimeDelay = OverTimeDelay_SET;
   1673              //while(!(I2C->SR1 & 0x02 == 0x02)) {if((OverTimeDelay --) == 0){OverTimeDelay = OverTimeDelay_SET;I2C_COM_ERROR_Flag = 0;break;}} // //等特7位器件地址发送完并且收到ack,ADDR置1    
   1674              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1675              I2C->SR1;   
   1676              I2C->SR3; //然后读SR3 清  ADDR 
   1677              if(I2C_COM_ERROR_Flag == 0)
   1678              {
   1679                //I2C_CR2 |= 0x04;
   1680                //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1681                I2C->DR = (u8)(addr);      
   1682                //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1683                while(!(I2C->SR1 & 0x84));//84//0x80  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1684                 
   1685                //============================= 发送数据  
   1686                I2C->DR = data;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)    
   1687                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1688                //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1689                
   1690                //============================= 发送数据  
   1691                I2C->DR = CRC_data;    
   1692                while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1693                //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1694                
   1695                I2C->DR;  //清除I2C_SR2的BTF位
   1696                I2C->CR2 |= 0x02;  //停止位产生stop  //*注意： 发送停止位时，必须先清除I2C_SR2的BTF位  
   1697                
   1698                enableInterrupts();
   1699                OverTimeDelay = 200; while((OverTimeDelay --) >0);
   1700                if(I2C_COM_ERROR_Flag == 0)
   1701                {  
   1702                  return;
   1703                }
   1704              }
   1705              I2C_COM_ERROR_Flag = 0;
   1706              Write_Retry_Cnt -= 1; 
   1707            } 
   1708            enableInterrupts();
   1709            //Uart_SendByte(0xCC);
   1710            //Uart_SendByte(0xCC);
   1711          }
   1712           
   1713          void I2C_Read_Backup(uint8_t addr,uint8_t *data)//slave device address 0x18
   1714          {      
   1715            uint16_t OverTimeDelay = 50;
   1716            uint8_t CRC_ReData,Retry_Cnt = 5; 
   1717            Buf[0] = SLAVE_ADDR; 
   1718            while(Retry_Cnt > 0)
   1719            {
   1720              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1721              
   1722              I2C->CR2 |= 0x04; //ack使能 
   1723              //=============================发送起始位 I2C_Start() 
   1724              while(I2C->SR3 & 0x02);//{if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}    // 等待总线空闲   检测i2c-SR3 busy位        
   1725              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位  
   1726              
   1727              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1728              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1729              while(!(I2C->SR1 & 0x01));  //等待START发送完 E5  
   1730              I2C->DR = (SLAVE_ADDR << 1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1731              
   1732              while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1733              //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1734              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1735              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1736              I2C->SR3; //然后读SR3 清  ADDR 
   1737              
   1738              //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1739              I2C->DR = (u8)(addr);      
   1740              //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1741              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1742              //在发送地址和清除ADDR 之后，I2C接口进入主设备接收模式。以下见stm8s中文数据手册P252（图97主设备接收模式接收序列图）  
   1743              
   1744              //=============================I2C_Start()        
   1745              I2C->CR2 |= 0x01;  //产生重复起始位   
   1746              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1747              while(!(I2C->SR1 & 0x01));  //等待START发送完     
   1748              //ADDRESS (接收)   
   1749              I2C->DR = (SLAVE_ADDR <<1) + 0x01;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)      
   1750              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除改位   
   1751              
   1752            while(!(I2C->SR1 & 0x02 == 0x02)){if((OverTimeDelay --) == 0){OverTimeDelay = 50;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1753            //while(!(I2C->SR1 & 0x02));  //等特7位器件地址发送完并且收到ack,ADDR置1  
   1754              I2C->SR1; //见P251 读SR1 (实验证明可以不要)  
   1755              I2C->SR3; //然后读SR3 清  ADDR   
   1756                 Buf[0] = 0x31;  Buf[1] = 0;     Buf[2] = 0;           
   1757              //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1758              while(!(I2C->SR1 & 0x40));                                        
   1759              Buf[1] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)                                               
   1760               
   1761             
   1762              
   1763              //测试EV7 RxNE=1（收到一个字节后RxNE置1） ，判断DR寄存器有数据    
   1764              while(!(I2C->SR1 & 0x40));                                        
   1765              Buf[2] = I2C->DR;//在接收模式下，收到完整字节后,自动发送ack(提前是CR2 ack位使能，不需要专门CR2 ack位置1)  
   1766                //EV7_1 ：RxNE=1 ，读DR寄存器清除该标志。设置ACK=0和STOP 请求。(在接收最后一个字节前)     
   1767              I2C->SR3;
   1768              I2C->DR; 
   1769              I2C->CR2 &= ~0x04; //ack使能  
   1770              I2C->CR2 |= 0x02;  //停止位产生stop      
   1771               
   1772              //while((I2C->CR2 & I2C_CR2_STOP));
   1773              CRC_ReData = CRC8_Caculate(Buf,2);
   1774              /*Uart_SendByte(0x11);
   1775              Uart_SendByte(Buf[0]);
   1776              Uart_SendByte(Buf[1]);
   1777              Uart_SendByte(Buf[2]);*/
   1778              if(CRC_ReData == Buf[2])
   1779              {
   1780                *data = Buf[1];
   1781                OverTimeDelay =100; while((OverTimeDelay --) >0);
   1782                return;
   1783              }
   1784              Retry_Cnt -= 1;
   1785            } 
   1786            //Uart_SendByte(0xAA);
   1787          }
   1788          
   1789          void I2C_Write_Backup(uint8_t addr,uint8_t data )
   1790          {     
   1791            uint8_t Write_Retry_Cnt = 5,CRC_data = 0;
   1792            uint16_t OverTimeDelay = 50;
   1793            Buf[0] = SLAVE_ADDR <<1 ;
   1794            Buf[1] = addr;
   1795            Buf[2] = data;
   1796            CRC_data = CRC8_Caculate(Buf,3);//slave_addr + reg_addr + data + CRC
   1797            
   1798            while(Write_Retry_Cnt > 0)
   1799            {
   1800              I2C_CR2 |= 0x04;
   1801              //以下见stm8s中文数据手册P251（图96主设备发送模式发送序列图） 
   1802              //=============================发送起始位 I2C_Start() 
   1803              while(I2C->SR3 & 0x02);// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}}   // 等待总线空闲   检测i2c-SR3 busy位
   1804              //I2C_CR2 &= ~0x04;        
   1805              I2C->CR2 |= 0x01;        // 产生起始位     CR2 start位    
   1806              //=============================发送器件地址 I2C_SendDAdr(0xD0)
   1807              //EV5：SB=1，读SR1 然后将地址写入DR寄存器将清除该标志。  
   1808              while(!(I2C->SR1 & 0x01));// {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}} //等待START发送完 E5  
   1809              
   1810              I2C->DR = (SLAVE_ADDR <<1) + 0x00;  //发送 器件地址(最后一位是0,表示发送) 
   1811              while(!(I2C->SR1 & 0x02 == 0x02)) {if((OverTimeDelay --) == 0){OverTimeDelay = 50;I2C_COM_ERROR_Flag = 1;break;}}  //等特7位器件地址发送完并且收到ack,ADDR置1    
   1812              //EV6:ADDR 在软件读取SR1后，对SR3寄存器读操作 将清除该位 
   1813              I2C->SR1;   
   1814              I2C->SR3; //然后读SR3 清  ADDR 
   1815              
   1816              //I2C_CR2 |= 0x04;
   1817              //=============================DATA 发送寄存器地址 I2C_SendDat()  
   1818              I2C->DR = (u8)(addr);      
   1819              //EV8_2 TxE=1 ，BTF=1，产生停止条件时由硬件清除。   
   1820              while(!(I2C->SR1 & 0x84));//84//0x80  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1821               
   1822              //============================= 发送数据  
   1823              I2C->DR = data;  //发送MLX90615器件地址(最后一位是1,表示接收)，发送完后自动发送ack(提前是CR2 ack位使能)    
   1824              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1825              //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1826              
   1827              //============================= 发送数据  
   1828              I2C->DR = CRC_data;    
   1829              while(!(I2C->SR1 & 0x84));  //检测SR1: TXE1(数据寄存器为空"1") BTF(字节发送结束"1")位置(只有当stm8收到ack,TxE才会置1，其实这句相当于判断收到ack没有？)
   1830              //EV8_2：TxE=1，BTF=1，产生停止条件时由硬件清除。  
   1831              
   1832              I2C->DR;  //清除I2C_SR2的BTF位
   1833              I2C->CR2 |= 0x02;  //停止位产生stop  //*注意： 发送停止位时，必须先清除I2C_SR2的BTF位  
   1834              
   1835              OverTimeDelay =100; while((OverTimeDelay --) >0);
   1836              if(I2C_COM_ERROR_Flag == 1)
   1837              {
   1838                return;
   1839              }
   1840              I2C_COM_ERROR_Flag = 0;
   1841              Write_Retry_Cnt -= 1;
   1842            }  
   1843          }
   1844          //===========================================================
   1845          void SOC_Init(void)
   1846          {
   1847            uint8_t result = 0;
   1848            uint8_t Soc_Tmp = 0;
   1849            result = FLASH_ReadByte(ADJUST_ADDR);
   1850            
   1851            if(result == 0xAA)//判断校验地址中数据是否为0xAA, Y: EEPROM 中保存有SOC数据;  N: EEPROM 中保存有SOC数据
   1852            {
   1853              Soc_Tmp = FLASH_ReadByte(SOC_ADDR);     // 读取SOC数据
   1854              SocReg.soc = Soc_Tmp; //SocReg.ah = SocCalc.curAh; // 计算SOC。 
   1855              SocCalc.curAh = ((uint32_t)SocReg.rated_cap * Soc_Tmp) / 100;
   1856              SocReg.ah = SocCalc.curAh;
   1857              SocCalc.soc_rt = SocReg.soc;
   1858              Soc_OCV_CorrectEn_Flag = 0;  // 上电禁止SOC的OCV校准  
   1859              
   1860              FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1861              FLASH_ProgramByte(ADJUST_ADDR,0x00);    // 清除校验地址中数据 
   1862              FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1863               
   1864              FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1865              FLASH_ProgramByte(0x004008,SocCalc.soc_rt);    // 清除校验地址中数据 
   1866              FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1867               /*
   1868                      FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1869                      FLASH_ProgramByte(0x00400C,(uint8_t)SocReg.ah);    // 清除校验地址中数据 
   1870                      FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1871                      FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1872                      FLASH_ProgramByte(0x00400D,(uint8_t)(SocReg.ah>>8));    // 清除校验地址中数据 
   1873                      FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1874                      FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1875                      FLASH_ProgramByte(0x00400E,(uint8_t)(SocReg.ah>>16));    // 清除校验地址中数据 
   1876                      FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1877                      FLASH_Unlock(FLASH_MEMTYPE_DATA);       // 解锁EEPROM
   1878                      FLASH_ProgramByte(0x00400F,(uint8_t)(SocReg.ah>>24));    // 清除校验地址中数据 
   1879                      FLASH_Lock(FLASH_MEMTYPE_DATA);         // 加锁EEPROM
   1880              */
   1881            }
   1882            else
   1883            {
   1884              Soc_OCV_CorrectEn_Flag = 1;  // 上电允许SOC的OCV校准
   1885            } 
   1886          }
   1887          void SOC_SavedtoEEPROM(void)
   1888          {   
   1889            static uint8_t soc_rt_lock = 0;
   1890            static uint8_t soc_rt_tmp = 0;
   1891            if(soc_rt_lock ==0)
   1892            {
   1893              soc_rt_tmp  = SocCalc.soc_rt;
   1894              soc_rt_lock = 1;
   1895            }
   1896            //soc_rt_tmp  = 80;
   1897            FLASH_Unlock(FLASH_MEMTYPE_DATA);               // 解锁EEPROM
   1898            FLASH_ProgramByte(SOC_ADDR,soc_rt_tmp);     // 保存SOC到EEPROM 
   1899            FLASH_Lock(FLASH_MEMTYPE_DATA);                 // 加锁EEPROM
   1900            
   1901            if(soc_rt_tmp == FLASH_ReadByte(SOC_ADDR))  // 读取数据 ?= 写入数据
   1902            {
   1903              FLASH_Unlock(FLASH_MEMTYPE_DATA);             // 解锁EEPROM
   1904              FLASH_ProgramByte(ADJUST_ADDR,0xAA);          // 写入保存SOC成功标志符
   1905              FLASH_Lock(FLASH_MEMTYPE_DATA);               // 加锁EEPROM
   1906            } 
   1907          }
   1908          //======================================
   1909          void Var_Init(void)
   1910          { 
   1911            uint8_t i = 0;
   1912            ChgTemp_cnt = 0;
   1913            DisTemp_cnt = 0;
   1914            
   1915              SocReg.rated_cap = 2050;
   1916            Chg_Current_Val_Small_Errer_t = 0;
   1917            Temp_Protect_Delay_t = 0;
   1918            LowPower_MCU_Entry_Flag = 0; // MCU运行于低功耗状态标识符
   1919            LedFlash_Off_t = 0;
   1920            ChgExchangeMode_Cnt  = 0;
   1921            DisExchangeMode_Cnt  = 0;
   1922            IdleExchangeMode_Cnt = 0;
   1923            for(i =0; i <10; i++)
   1924            {
   1925              Adc_value[i] = 0;
   1926              Cell_Volt[i] = 0;
   1927            }
   1928            Temp_Volt_Sample_Cnt = 0;
   1929            Cell_Volt_Sample_Cnt = 0;
   1930            I2C_COM_ERROR_Flag   = 0;
   1931            Current_Val   = 0;
   1932            ADCOffset_Val = 0;
   1933            CC_Val = 0;
   1934            Cell_Volt_Tol = 0;
   1935            Cell_Volt_Avg = 0;
   1936            Cell_Volt_Max = 0;
   1937            Cell_Volt_Min = 0; 
   1938            ADCGain_Val = 0; 
   1939            Pack_Volt = 0;
   1940            Temp_Val = 0;
   1941            V_TS2_Val = 0; 
   1942            R_TS2_Val = 0; 
   1943            
   1944            SYS_STAT_Last = 0;
   1945            CELLBAL1_Last = 0;
   1946            CELLBAL2_Last = 0;
   1947            SYS_CTRL1_Last = 0;
   1948            SYS_CTRL2_Last = 0; 
   1949            PROTECT1_Last = 0;
   1950            PROTECT2_Last = 0;
   1951            PROTECT3_Last = 0;
   1952            OV_TRIP_Last = 0;
   1953            UV_TRIP_Last = 0;
   1954            CC_CFG_Last = 0;
   1955            
   1956            
   1957            ChgOv_t = 0;
   1958            ChgCurOv_t = 0;
   1959            ChgCurOv_Re_t = 0;  
   1960            DisOv_t = 0;
   1961            DisCurOv_t = 0;
   1962            DisCurOv_t1 = 0;
   1963            DisCurOv_t2 = 0;
   1964            DisCurOv_Re_t = 0;
   1965            DisCurShort_Re_t = 0;
   1966            
   1967            //DEVICE_XREADY_Re_t = 0;
   1968            
   1969            CellBalance_Cur_Selct = 0;  
   1970            LedFlash_t = 0;
   1971            PowerOff_Delay_t = 0;
   1972            Delay_time_t = 0;
   1973             
   1974            
   1975            SYS_STAT.Byte = 0;
   1976            
   1977            RevcComData.uintdata = 0;
   1978            Bits_flag.Byte = 0;
   1979            
   1980            SocCalc.inAh = 0;
   1981            SocCalc.inAh_bak = 0;
   1982            SocCalc.totalInAh = 0;
   1983            SocCalc.totalInAh_bak = 0;
   1984            SocCalc.outAh = 0;
   1985            SocCalc.outAh_bak = 0;
   1986            SocCalc.totalOutAh = 0;
   1987            SocCalc.totalOutAh_bak = 0;
   1988            SocCalc.curAh = 0;
   1989            SocCalc.ov_cnt = 0;
   1990            SocCalc.uv_cnt = 0;
   1991            SocCalc.stb_cnt = 0;
   1992            SocCalc.soc_rt = 0; 
   1993            
   1994          }
   1995          
   1996          #endif

   Section sizes:

     Function/Label           Bytes
     --------------           -----
     _A_PA_ODR                   1
     _A_PC_ODR                   1
     _A_CLK_ICKR                 1
     _A_CLK_ECKR                 1
     _A_CLK_SWCR                 1
     _A_CLK_CKDIVR               1
     CLK_PCKENR1                 1
     CLK_PCKENR2                 1
     IWDG_KR                     1
     _A_IWDG_PR                  1
     IWDG_RLR                    1
     _A_I2C_CR1                  1
     _A_I2C_CR2                  1
     _A_I2C_FREQR                1
     I2C_CCRL                    1
     _A_I2C_CCRH                 1
     _A_I2C_TRISER               1
     _A_UART1_SR                 1
     UART1_DR                    1
     UART1_BRR1                  1
     UART1_BRR2                  1
     _A_UART1_CR1                1
     _A_UART1_CR2                1
     _A_UART1_CR3                1
     _A_TIM2_CR1                 1
     _A_TIM2_IER                 1
     TIM2_CNTRH                  1
     TIM2_CNTRL                  1
     _A_TIM2_PSCR                1
     TIM2_ARRH                   1
     TIM2_ARRL                   1
     _A_TIM4_CR1                 1
     _A_TIM4_IER                 1
     _A_TIM4_EGR                 1
     TIM4_CNTR                   1
     _A_TIM4_PSCR                1
     TIM4_ARR                    1
     _A_ADC_CSR                  1
     _A_ADC_CR1                  1
     _A_ADC_CR2                  1
     _A_ADC_CR3                  1
     ADC_DRH                     1
     ADC_DRL                     1
     ADC_TDRH                    1
     ADC_TDRL                    1
     ADC                        47
     ?Subroutine36              15
     ?Subroutine4                7
     ADConverse                122
     SysInit                    60
     ClrWdt                     21
     PortInit                  118
     ?Subroutine41               6
     ?Subroutine40               3
     ??Subroutine57_0            4
     ?Subroutine39               6
     ?Subroutine38               7
     ?Subroutine46               8
     Uart_Model_Init            29
     Uart_SendByte              25
     itoa                      110
     rev                        21
     Uart_SendStr               38
     Uart_SendData              57
     I2C_Model_Init             33
     Timer2Init                 41
     Timer4_Init_us             18
     ?Subroutine29               9
     ?Subroutine28               9
     ?Subroutine25              13
     Timer4_Init_ms             18
     Timer4_Disable             13
     Delay_us                   14
     Delay_ms                   14
     ?Subroutine26               6
     TempCheck                 150
     DisTemp_Lock                1
     ?Subroutine24               3
     ??Subroutine55_0            3
     ??Subroutine56_0            6
     CurrentCheck              165
     VoltCheck                 235
     ?Subroutine45               1
     ??Subroutine54_0            7
     ?Subroutine49               8
     ?Subroutine11               4
     ?Subroutine47               6
     ModeCheck                 307
     ?Subroutine16               9
     ?Subroutine7                9
     ?Subroutine1                9
     ?Subroutine0               15
     ?Subroutine42              30
     ?Subroutine48               8
     ModeChange_Lock             1
     ClearStatus               112
     ?Subroutine37               9
     ?Subroutine10              10
     Afe_Volt_Val_Get          399
     ?Subroutine35               4
     ?Subroutine33               6
     CellBal_Cntrl             197
     ?Subroutine34              10
     ?Subroutine9                8
     ?Subroutine6                7
     LedShow_Cntrl             340
     ?Subroutine32               5
     ?Subroutine31               9
     ?Subroutine30               4
     ??Subroutine53_0            7
     ?Subroutine5                5
     FlowLedCnt                  1
     FlowLedCnt_Lock             1
     FlowLed_Finish_Flag         1
     LowPower_Powerdown_Enter   52
     ?Subroutine27              11
     LowPower_Cntrl            151
     Afe_Temp_Disable_Lock       1
     CRC8_Caculate              66
     ?Subroutine22               5
     ?Subroutine21               5
     ?Subroutine19               6
     ?Subroutine14               2
     ??Subroutine52_0            6
     ?Subroutine44               9
     ?Subroutine8               10
     I2C_Read                  155
     ?Subroutine23              11
     ?Subroutine20               7
     ?Subroutine43               7
     ?Subroutine18              16
     ?Subroutine17              11
     ?Subroutine15              21
     I2C_Write                 116
     ?Subroutine13              32
     I2C_Read_Backup           137
     I2C_Write_Backup          101
     ?Subroutine3                3
     ??Subroutine50_0            6
     SOC_Init                   87
     ?Subroutine12               5
     ?Subroutine2                3
     ??Subroutine51_0           11
     SOC_SavedtoEEPROM          44
     soc_rt_lock                 1
     soc_rt_tmp                  1
     Var_Init                  267
     ?<Constant "abcdef">        7
     ?<Constant {0}>            20
     ?<Constant "0x">            3

 
    29 bytes in section .near.bss
    45 bytes in section .near.noinit
    30 bytes in section .near.rodata
 4 341 bytes in section .near_func.text
 
 4 341 bytes of CODE  memory
    30 bytes of CONST memory
    29 bytes of DATA  memory (+ 45 bytes shared)

Errors: none
Warnings: 2
