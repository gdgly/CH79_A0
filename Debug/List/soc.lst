###############################################################################
#                                                                             #
# IAR C/C++ Compiler V1.31.1.20058 [Evaluation] for STM807/Apr/2016  11:54:40 #
# Copyright 2010-2012 IAR Systems AB.                                         #
#                                                                             #
#    Source file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \soc.c                                                   #
#    Command line =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src #
#                    \soc.c -e -Ohz --debug --code_model small --data_model   #
#                    medium -o D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_ #
#                    A0\Debug\Obj\ --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\stm8\LIB\dlstm8smn.h" -lcN                    #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /user/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79 #
#                    _A0/user/src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/user/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_ #
#                    C-version\CH79_A0/addon/\ -I                             #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/addon/s #
#                    rc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0 #
#                    /addon/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version #
#                    \CH79_A0/sys/\ -I D:\ProjectPath\STMPath\CH79_A0_C-versi #
#                    on\CH79_A0/sys/inc/\ -I D:\ProjectPath\STMPath\CH79_A0_C #
#                    -version\CH79_A0/sys/src/\ -I                            #
#                    D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/\   #
#                    -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0/lib/ #
#                    src/\ -I D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A #
#                    0/lib/inc/\ --vregs 16                                   #
#    List file    =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\L #
#                    ist\soc.lst                                              #
#    Object file  =  D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\Debug\O #
#                    bj\soc.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProjectPath\STMPath\CH79_A0_C-version\CH79_A0\sys\src\soc.c
      1          
      2          #include "stm8s.h" 
      3          #include"user.h"
      4          
      5           
      6          typedef struct
      7          {
      8              uint8_t soc;   // 对应的soc。
      9              uint16_t volt;  // 开路电压
     10          } X_SOC_2_OCV;
     11          
     12          typedef struct
     13          {
     14              int8_t temp;     // 温度
     15              uint16_t rated_cap; // 对应的额定容量
     16          } X_TEMP_2_CAP;
     17          
     18          /*
     19          const X_SOC_2_OCV Soc2OcvTbl[11] =  // 根据实际修改
     20          {// soc, volt,
     21              {0, 3440}, {10, 3523}, {20, 3585}, {30, 3615}, {40, 3643}, {50, 3690}, // 润丰电池
     22              {60, 3755}, {70, 3850}, {80, 3930}, {90, 4040}, {100, 4190},
     23              //{0, 3435}, {10, 3510}, {20, 3572}, {30, 3610}, {40, 3635}, {50, 3675}, // 天能电池
     24              //{60, 3755}, {70, 3890}, {80, 3935}, {90, 4041}, {100, 4188},
     25          };
     26          
     27          const X_TEMP_2_CAP Temp2CapacityTbl[10] =   // 根据实际修改
     28          {// temp, ratedcap
     29              // -20drg -> 50%, -10drg -> 75%, 0drg -> 90%, 10drg -> 95%, 25drg -> 100%
     30              { -20, 11000}, { -15, 14000},
     31              { -10, 16500}, { -5, 17800},
     32              {0, 19800}, {5, 19950},
     33              {10, 21000}, {15, 21333},
     34              {20, 21666}, {25, 22000},
     35          };
     36          */
     37          ///const 
     38          X_SOC_2_OCV Soc2OcvTbl[11] =  // 根据实际修改
     39          {
     40              //{0, 3440}, {10, 3523}, {20, 3585}, {30, 3615}, {40, 3643}, {50, 3690}, {60, 3755}, {70, 3850}, {80, 3930}, {90, 4040}, {100, 4190},
     41              //{0, 3335}, {10, 3510}, {20, 3572}, {30, 3610}, {40, 3635}, {50, 3675},{60, 3755}, {70, 3890}, {80, 3935}, {90, 4041}, {100, 4188},
     42              {0, 3035}, {10, 3210}, {20, 3472}, {30, 3610}, {40, 3635}, {50, 3675},{60, 3755}, {70, 3890}, {80, 3935}, {90, 4041}, {100, 4188},
     43          };
     44          /*const X_SOC_2_OCV Soc2OcvTbl_10deg[11] = // 10'C
     45          {
     46              {0, 3440}, {10, 3512}, {20, 3571}, {30, 3605}, {40, 3633}, {50, 3674},
     47              {60, 3749}, {70, 3836}, {80, 3931}, {90, 4038}, {100, 4191},
     48          };*/
     49          const X_SOC_2_OCV Soc2OcvTbl_0deg[11] = // 0'C - 20160131
     50          {
     51              {0, 3339}, {10, 3500}, {20, 3555}, {30, 3594}, {40, 3629}, {50, 3671}, {60, 3736}, {70, 3830}, {80, 3932}, {90, 4040}, {100, 4196},
     52          };
     53          const X_SOC_2_OCV Soc2OcvTbl_N10deg[11] = // -10'C
     54          {
     55              {0, 3303}, {10, 3385}, {20, 3531}, {30, 3574}, {40, 3611}, {50, 3656}, {60, 3720}, {70, 3811}, {80, 3918}, {90, 4029}, {100, 4184},
     56          };
     57          
     58          const X_TEMP_2_CAP Temp2CapacityTbl[10] =  // 根据实际修改
     59          {
     60              // -20drg -> 50%, -10drg -> 75%, 0drg -> 90%, 10drg -> 95%, 25drg -> 100%
     61              //{ -20, 11000}, { -15, 14000}, { -10, 16500}, { -5, 17800}, {0, 19800}, {5, 19950}, {10, 21000}, {15, 21333}, {20, 21666}, {25, 22000}, 
     62              // -20drg -> 83%, -10drg -> 87%, 0drg -> 92%, 10drg -> 98%, 25drg -> 100%
     63              { -20, 18260}, { -15, 18700}, { -10, 19140}, { -5, 19800}, {0, 20020}, {5, 20900}, {10, 21560}, {15, 21780}, {20, 21890}, {25, 22000},
     64          };
     65          
     66            
     67           
     68          
     69          /*  计算电流积分，每10ms 调用一次。
     70          *
     71          *   输入参数:
     72          *  SocReg.curr                  实时电流
     73          *  SocReg.curr_dir              电流方向
     74          *
     75          *   输出:   用于计算的中间值。
     76          *
     77          */
     78          void SOCAhIntergrate(void)
     79          {
     80              uint32_t tmpah;
     81              tmpah = Current_Val;    // xmA 10ms
     82               
     83              //if(WorkMode == CHARGE_MODE)
     84              if(CC_Val > 0)
     85              {
     86                SocCalc.inAh_bak += tmpah;
     87          
     88                if(SocCalc.inAh_bak > 360000)
     89                {
     90                  SocCalc.totalInAh += SocCalc.inAh_bak / 360000;
     91                  SocCalc.inAh_bak = SocCalc.inAh_bak % 360000; // 充入1Ah。
     92                }
     93              }
     94              //else if(WorkMode == DISCHARGE_MODE)
     95              else// if(WorkMode == CHARGE_MODE)
     96              {
     97                
     98                //tmpah = Current_Val;    // xmA 10ms
     99                //if(WorkMode == DISCHARGE_MODE && SocCalc.totalOutAh > SocCalc.totalOutAh_bak) // 放出。
    100                //deltAh = (uint16_t)(SocCalc.totalOutAh - SocCalc.totalOutAh_bak);
    101                //SocCalc.totalOutAh_bak = SocCalc.totalOutAh;
    102                SocCalc.outAh_bak += tmpah;
    103          
    104                if(SocCalc.outAh_bak > 360000)
    105                {
    106                  SocCalc.totalOutAh += SocCalc.outAh_bak / 360000;
    107                  SocCalc.outAh_bak = SocCalc.outAh_bak % 360000; // 放出1Ah。
    108                }
    109              }/*
    110              else if(WorkMode == IDLE_MODE)//
    111              {
    112                //if((SocCalc.stb_cnt ++) >= 120000)//静置20分钟后，允许进行OCV校准
    113                {
    114                  SocCalc.stb_cnt = 120000;
    115                  //Soc_OCV_CorrectEn_Flag = 1;
    116                }
    117              }*/
    118          }
    119          //================= 将soc 范围 10~90 转换为 soc_rt 所需的 0~100。
    120          void SOCConvert(void)
    121          {
    122            if(SocReg.soc > 90)
    123            {
    124              SocCalc.soc_rt = 100;
    125            }
    126            else if(SocReg.soc < 10)
    127            {
    128              SocCalc.soc_rt = 0;
    129            }
    130            else
    131            {
    132              SocCalc.soc_rt = (SocReg.soc -10)*5/4;
    133            }
    134          }
    135          /*  计算SOC，每100ms 调用一次。
    136          *
    137          *   输入参数:
    138          *  SocReg.ah                当前剩余容量
    139          *  SocReg.max_cell_vlt      最高单节电压
    140          *  SocReg.max_cell_chg_vlt  过冲电压
    141          *  SocReg.min_cell_vlt      最低单节电压
    142          *  SocReg.min_cell_dchg_vlt 过放电压
    143          *  SocReg.rated_cap         额定容量
    144          *
    145          *   输出:
    146          *  SocReg.ah            新的容量
    147          *  SocReg.soc           新的SOC
    148          *
    149          */
    150          void SOCCalculate(void)
    151          {
    152              uint32_t deltAh;
    153              SocCalc.curAh = SocReg.ah; 
    154              SocReg.rated_cap = 2050;
    155              SocReg.min_cell_temp_vlt = V_TS2_Val; 
    156              SocReg.min_cell_vlt = Cell_Volt_Min;
    157              SOCCorrectOCV();      // OCV 校准
    158              //SOCCorrectTemp();   // 温度校准 
    159              
    160              if( SocCalc.totalInAh > SocCalc.totalInAh_bak)   // 充入。
    161              {
    162                deltAh = (uint16_t)(SocCalc.totalInAh - SocCalc.totalInAh_bak);
    163                SocCalc.totalInAh_bak = SocCalc.totalInAh;
    164                SocCalc.curAh += deltAh; 
    165          
    166                if(SocCalc.curAh > SocReg.rated_cap)    // 防止大于额定容量。
    167                {
    168                  SocCalc.curAh = SocReg.rated_cap; 
    169                } 
    170              }
    171          
    172              if( SocCalc.totalOutAh > SocCalc.totalOutAh_bak) // 放出。
    173              {
    174                deltAh = (uint16_t)(SocCalc.totalOutAh - SocCalc.totalOutAh_bak);
    175                SocCalc.totalOutAh_bak = SocCalc.totalOutAh;
    176           
    177                if(SocCalc.curAh < deltAh)  // 防止小于0。
    178                {
    179                  SocCalc.curAh = 0;
    180                }
    181                else
    182                { 
    183                  SocCalc.curAh -= deltAh; 
    184                } 
    185              } 
    186              if(WorkMode == CHARGE_MODE  )   // 充入。
    187              {  
    188                if(Bits_flag.Bit.ChgOv)   // 过充 
    189                {
    190                  if((SocCalc.ov_cnt ++) >= 30 && (Cell_Volt_Max >= 4100 && Cell_Volt_Avg >= 4100))
    191                  {
    192                    SocCalc.ov_cnt = 30;
    193                    SocCalc.curAh = SocReg.rated_cap;
    194                    SocCalc.totalInAh = 0;
    195                    SocCalc.totalInAh_bak = 0;
    196                  } 
    197                }
    198                else
    199                {
    200                  SocCalc.ov_cnt = 0;
    201                }
    202              }
    203              else //(WorkMode == DISCHARGE_MODE ) // 放出。 
    204              {  
    205                if(Bits_flag.Bit.DisOv)  // 有任一电池过放了。
    206                {
    207                  if(SocReg.min_cell_vlt > 0)
    208                  {
    209                    if((SocCalc.uv_cnt++) >= 30)
    210                    {
    211                      SocCalc.uv_cnt = 30;
    212                      SocCalc.curAh = 0;
    213                      SocCalc.totalOutAh = 0;
    214                      SocCalc.totalOutAh_bak = 0;
    215                    } 
    216                  }
    217                }
    218                else
    219                {
    220                  SocCalc.uv_cnt = 0;
    221                }
    222          
    223              } 
    224             
    225              SocReg.ah = SocCalc.curAh; // 计算SOC。  
    226              SocReg.soc = (uint8_t)(SocCalc.curAh * 100 / SocReg.rated_cap);
    227              SocCalc.soc_rt = SocReg.soc;
    228               
    229          }
    230          void SOCCalculate1(void)
    231          {
    232              uint32_t deltAh;
    233              SocCalc.curAh = SocReg.ah; 
    234              SocReg.rated_cap = 2050;
    235              SocReg.min_cell_temp_vlt = V_TS2_Val; 
    236              SocReg.min_cell_vlt = Cell_Volt_Min;
    237              SOCCorrectOCV();      // OCV 校准
    238              //SOCCorrectTemp();   // 温度校准 
    239              
    240              if(WorkMode == CHARGE_MODE && SocCalc.totalInAh > SocCalc.totalInAh_bak)   // 充入。
    241              {
    242                deltAh = (uint16_t)(SocCalc.totalInAh - SocCalc.totalInAh_bak);
    243                SocCalc.totalInAh_bak = SocCalc.totalInAh;
    244                SocCalc.curAh += deltAh; 
    245          
    246                if(SocCalc.curAh > SocReg.rated_cap)    // 防止大于额定容量。
    247                {
    248                  SocCalc.curAh = SocReg.rated_cap;
    249                }
    250           
    251                if(Bits_flag.Bit.ChgOv)   // 过充 
    252                {
    253                  if((SocCalc.ov_cnt ++) >= 30)
    254                  {
    255                    SocCalc.ov_cnt = 30;
    256                    SocCalc.curAh = SocReg.rated_cap;
    257                  } 
    258                }
    259                else
    260                {
    261                  SocCalc.ov_cnt = 0;
    262                }
    263              }
    264          
    265              if(WorkMode == DISCHARGE_MODE && SocCalc.totalOutAh > SocCalc.totalOutAh_bak) // 放出。
    266              {
    267                deltAh = (uint16_t)(SocCalc.totalOutAh - SocCalc.totalOutAh_bak);
    268                SocCalc.totalOutAh_bak = SocCalc.totalOutAh;
    269           
    270                if(SocCalc.curAh < deltAh)  // 防止小于0。
    271                {
    272                  SocCalc.curAh = 0;
    273                }
    274                else
    275                { 
    276                  SocCalc.curAh -= deltAh; 
    277                }
    278           
    279                if(Bits_flag.Bit.DisOv)  // 有任一电池过放了。
    280                {
    281                  if(SocReg.min_cell_vlt > 0)
    282                  {
    283                    if((SocCalc.uv_cnt++) >= 30)
    284                    {
    285                      SocCalc.uv_cnt = 30;
    286                      SocCalc.curAh = 0;
    287                    } 
    288                  }
    289                }
    290                else
    291                {
    292                  SocCalc.uv_cnt = 0;
    293                }
    294          
    295              }
    296          /*
    297              
    298              SocReg.soc = soc;   
    299              SocCalc.curAh = (uint32_t)(SocReg.rated_cap * soc) / 100;
    300              SocReg.ah = SocCalc.curAh;
    301              */
    302             
    303              SocReg.ah = SocCalc.curAh; // 计算SOC。  
    304              SocReg.soc = (uint8_t)(SocCalc.curAh * 100 / SocReg.rated_cap);
    305              SocCalc.soc_rt = SocReg.soc;
    306              
    307              
    308              //SOCSmooth();
    309              //SOCConvert();//BMSRegs.soc_rt = SocReg.soc;
    310              //BMSReflashFromSOC();
    311          }
    312          /*  静置后进行OCV 修正。
    313          *
    314          *   需要输入的参数:
    315          *
    316          *  1. SocReg.curr           实时电流
    317          *  2. SocReg.min_cell_vlt   最低单节电压(关键参数)
    318          *
    319          *   输出:
    320          *
    321          *  1. SocReg.soc
    322          *  2. SocCalc.curAh
    323          */
    324          void SOCCorrectOCV(void)
    325          {
    326            uint8_t i, soc;
    327            uint32_t tmpah;
    328            uint16_t deltV;
    329            tmpah = SocReg.curr;    // xmA 10ms 
    330            if(WorkMode != IDLE_MODE && Soc_OCV_CorrectEn_Flag == 1) 
    331            { 
    332              Soc_OCV_CorrectEn_Flag = 0; 
    333              /*
    334              //if(SocReg.min_cell_temp >= 0) // 20160131 - add for OCV tbl under different temp.
    335              if(SocReg.min_cell_temp_vlt < 757)  // 20160224 - add for OCV tbl under different temp.
    336              {
    337                for(i = 0; i < 11; i++)
    338                { 
    339                  Soc2OcvTbl[i].volt = Soc2OcvTbl_0deg[i].volt; 
    340                }
    341              }
    342              else
    343              {
    344                for(i = 0; i < 11; i++)
    345                { 
    346                  Soc2OcvTbl[i].volt = Soc2OcvTbl_N10deg[i].volt; 
    347                }
    348              }
    349              */
    350              if(SocReg.min_cell_vlt <= Soc2OcvTbl[0].volt)   // 防止超范围
    351              {
    352                soc = 0;
    353              }
    354              else if(SocReg.min_cell_vlt >= Soc2OcvTbl[10].volt)
    355              {
    356                soc = 100;
    357              }
    358              else
    359              {
    360                for(i = 1; i < 11; i++)     // 查表根据OCV 表取soc。
    361                {
    362                  if(SocReg.min_cell_vlt == Soc2OcvTbl[i].volt)   // NOTE: 采用最低电压的一节电池来比较。
    363                  {
    364                    soc = Soc2OcvTbl[i].soc;
    365                    break;
    366                  }
    367                  else if(SocReg.min_cell_vlt > Soc2OcvTbl[i-1].volt && SocReg.min_cell_vlt < Soc2OcvTbl[i].volt)
    368                  {
    369                    deltV = (uint16_t)(Soc2OcvTbl[i].soc - Soc2OcvTbl[i - 1].soc) * 1000 / (Soc2OcvTbl[i].volt - Soc2OcvTbl[i - 1].volt);
    370                    soc = Soc2OcvTbl[i - 1].soc + (uint8_t)((SocReg.min_cell_vlt - Soc2OcvTbl[i - 1].volt) * deltV / 1000);
    371                    break;
    372                  } 
    373                }
    374                /*
    375                for(i = 1; i < 11; i++)     // 查表根据OCV 表取soc。
    376                {
    377                  if(SocReg.min_cell_vlt == Soc2OcvTbl[i].volt)   // NOTE: 采用最低电压的一节电池来比较。
    378                  {
    379                    soc = Soc2OcvTbl[i].soc;
    380                    break;
    381                  }
    382                  else if(SocReg.min_cell_vlt < Soc2OcvTbl[i].volt)
    383                  {
    384                    deltV = (Soc2OcvTbl[i].soc - Soc2OcvTbl[i - 1].soc) * 1000 / (Soc2OcvTbl[i].volt - Soc2OcvTbl[i - 1].volt);
    385                    soc = Soc2OcvTbl[i - 1].soc + (SocReg.min_cell_vlt - Soc2OcvTbl[i - 1].volt) * deltV / 1000;
    386                    break;
    387                  }
    388                }*/
    389              }
    390          
    391              SocReg.soc = soc; //SocReg.ah = SocCalc.curAh; // 计算SOC。 
    392              SocCalc.curAh = ((uint32_t)SocReg.rated_cap * soc) / 100;
    393              SocReg.ah = SocCalc.curAh;
    394              SocCalc.soc_rt = SocReg.soc;
    395            }
    396          }
    397          
    398          /*  进行温度和额定容量的校正。
    399          *
    400          *   需要输入的参数:
    401          *
    402          *  1. SocReg.min_cell_temp  最低单节温度
    403          *  2. SocReg.temp_corr      校正使能标志位
    404          *
    405          *   输出:
    406          *
    407          *  1. SocReg.rated_cap      修正后的额定容量
    408          */
    409          void SOCCorrectTemp(void)
    410          {
    411              int8_t minTemp;
    412              uint16_t deltT;
    413              uint8_t i;
    414              minTemp = SocReg.min_cell_temp;
    415          
    416              if(SocReg.temp_corr == 1)
    417              {
    418                  SocReg.temp_corr = 0;
    419          
    420                  if(minTemp <= Temp2CapacityTbl[0].temp)
    421                  {SocReg.rated_cap = Temp2CapacityTbl[0].rated_cap;}
    422                  else if(minTemp >= Temp2CapacityTbl[9].temp)
    423                  {SocReg.rated_cap = Temp2CapacityTbl[9].rated_cap;}
    424                  else
    425                  {
    426                      for(i = 1; i < 10; i++)
    427                      {
    428                          if(minTemp == Temp2CapacityTbl[i].temp)
    429                          {
    430                              SocReg.rated_cap = Temp2CapacityTbl[i].rated_cap;
    431                              break;
    432                          }
    433                          else if(minTemp < Temp2CapacityTbl[i].temp)
    434                          {
    435                              // 线性化再等分。
    436                              deltT = (Temp2CapacityTbl[i].rated_cap - Temp2CapacityTbl[i - 1].rated_cap)
    437                                      / (Temp2CapacityTbl[i].temp - Temp2CapacityTbl[i - 1].temp);
    438                              SocReg.rated_cap = Temp2CapacityTbl[i - 1].rated_cap
    439                                                 + (SocReg.min_cell_temp - Temp2CapacityTbl[i - 1].temp) * deltT;
    440                              break;
    441                          }
    442                      }
    443                  }
    444              }
    445          }
    446          
    447          /************************************************************************/
    448          /************************************************************************/
    449          /************************************************************************/
    450          /************************************************************************/
    451          /************************************************************************/
    452          /************************************************************************/
    453          
    454          uint8_t smooth_cnt;
    455          //sword smooth_delt_v;
    456          uint32_t smooth_delt_v;
    457          uint16_t old_v = 0;
    458          uint16_t new_v = 0;
    459          
    460          /*  10 秒内将SocReg.soc  值平滑变化到BMSRegs.soc_rt  值。
    461          */
    462          void SOCSmooth(void)
    463          {
    464              new_v = SocReg.soc * 10;
    465          
    466              //if((old_v != new_v)&&(abs(old_v-new_v)<10))
    467              if(old_v != new_v)
    468              {
    469                  smooth_cnt++;
    470          
    471                  if(smooth_cnt > 5) // 100ms=1 x 100ms
    472                  {
    473                      smooth_cnt = 0;
    474          
    475                      if(old_v > new_v)
    476                      {
    477                          smooth_delt_v = (old_v - new_v) / 10;
    478                          old_v -= smooth_delt_v;
    479                      }
    480                      else
    481                      {
    482                          smooth_delt_v = (new_v - old_v) / 10;
    483                          old_v += smooth_delt_v;
    484                      }
    485          
    486                      if(smooth_delt_v == 0)
    487                      { old_v = new_v; }
    488                  }
    489              }
    490              else
    491              { smooth_cnt = 0; }
    492          
    493              SocCalc.soc_rt = (uint8_t)(old_v / 10);
    494          }
    495          
    496          

   Section sizes:

     Function/Label    Bytes
     --------------    -----
     Soc2OcvTbl          33
     Soc2OcvTbl_0deg     33
     Soc2OcvTbl_N10deg   33
     Temp2CapacityTbl    30
     SOCAhIntergrate     94
     ?Subroutine15        8
     ?Subroutine13       18
     ??Subroutine19_0     6
     SOCConvert          47
     ?Subroutine17        3
     ??Subroutine20_0     6
     ?Subroutine0        49
     ?Subroutine12        3
     ??Subroutine21_0     4
     SOCCalculate       157
     ?Subroutine14       10
     ?Subroutine11        9
     ??Subroutine22_0     9
     ?Subroutine10       30
     ?Subroutine9        14
     ?Subroutine8        14
     ?Subroutine7         9
     ?Subroutine6         7
     ?Subroutine18        6
     ?Subroutine5        13
     ?Subroutine3         4
     ??Subroutine23_0     8
     ?Subroutine1        18
     ?Subroutine16       12
     SOCCalculate1      115
     ?Subroutine4         3
     SOCCorrectOCV      233
     SOCCorrectTemp     192
     smooth_cnt           1
     smooth_delt_v        4
     old_v                2
     new_v                2
     SOCSmooth          117
     ?Subroutine2        14

 
     9 bytes in section .near.bss
    33 bytes in section .near.data
    96 bytes in section .near.rodata
 1 232 bytes in section .near_func.text
 
 1 232 bytes of CODE  memory
    96 bytes of CONST memory
    42 bytes of DATA  memory

Errors: none
Warnings: 1
